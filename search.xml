<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iWork需求分析规约</title>
      <link href="/2019/12/15/iWork%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%A7%84%E7%BA%A6/"/>
      <url>/2019/12/15/iWork%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%A7%84%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="招聘用例"><a href="#招聘用例" class="headerlink" title="招聘用例"></a>招聘用例</h1><table><thead><tr><th>用例编号</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 软件工程文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2019/11/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/2019/11/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习要求：翻看笔记+高珍老师PPT，然后挑重点理解，要记得刷题</p></blockquote><ul><li><input disabled type="checkbox"> 绪论</li><li><input disabled type="checkbox"> 高级语言及其文法</li><li><input disabled type="checkbox"> 词法分析</li><li><input disabled type="checkbox"> 语法分析</li><li><input disabled type="checkbox"> 语法制导翻译</li><li><input disabled type="checkbox"> 中间代码生成</li><li><input disabled type="checkbox"> 优化</li></ul><blockquote><p>视频：</p></blockquote><ul><li><input disabled type="checkbox"> 绪论 1-6</li><li><input disabled type="checkbox"> 语言及其文法 2.5完整看完</li><li><input checked disabled type="checkbox"> 你</li><li><input disabled type="checkbox"> chapter 9</li><li><input disabled type="checkbox"> </li><li><input disabled type="checkbox"> </li></ul><p>考点用<code>重点考点</code>进行标识</p><p>需要补充的地方<code>[?]</code></p><p>参考网址：<a href="https://blog.csdn.net/qq_33414271/category_9292415.html" target="_blank" rel="noopener">编译原理MOOC笔记</a></p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="课件PPT"><a href="#课件PPT" class="headerlink" title="课件PPT"></a>课件PPT</h2><p><img alt="image-20191212212425319" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u9az56ptj30ve0c60uj.jpg" class="lazyload"></p><h2 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h2><p>计算机程序语言可以自顶向下可以分为高级语言、汇编语言和机器语言三种，其中开发程序员最长接触的为高级语言，如JAVA，高级语言经过编译就会生成汇编语言或机器语言，具体关系如下图：</p><p><img alt="image-20191127165753230" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpaz1yxvj312i0n84a1.jpg" class="lazyload"></p><p>编译的过程就是将<code>高级语言</code>翻译成<code>汇编语言或机器语言</code>的过程 ，即将<code>源语言</code>转化为<code>目标语言</code>的过程。</p><p>编译器在语言处理系统中的位置如下图所示：</p><p><img alt="image-20191127165935095" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpcqqihfj310o0oan77.jpg" class="lazyload"></p><ul><li><p>可重定位(Relocatable)： 在内存中存放的起始位置L不是固定的</p></li><li><p>加载器：修改可重定位地址；将修改后的指令和数据放到内存中适当的位置</p><center>起始位置+相对地址=绝对地址</center></li><li><p><code>链接器</code>的作用：</p><ol><li>将多个可重定位的机器代码文件（包括库文件）</li><li>连接到一起解决外部内存地址问题</li></ol></li></ul><h2 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h2><p>在有了高级语言程序之后（如一段C语言代码），编译器应该怎么翻译成汇编语言程序或机器语言程序呢？</p><p>我们先来看一下人工英汉怎么进行翻译的，编译器所做的工作有类似之处。</p><p><img alt="image-20191127170344850" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cph2jthrj311m0k07e8.jpg" class="lazyload"></p><p>首先我们分析源语言，即英文，先拆分名词、动词等，然后组成短语，最终才能组合成句。即一段语言的分析理解包括了<code>3个基本的小部分</code>,最终才能连接成为一个完整的句子</p><ol><li>词法分析（Lexical Analysis）</li><li>语法分析（Syntax Analysis）</li><li>语义分析（Semantic Analysis）</li></ol><p>那么一个完整的编译器结构如下图所示：</p><p><img alt="image-20191127170550711" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpj9ct2bj30so0tu7d2.jpg" class="lazyload"></p><h2 id="词法分析概述"><a href="#词法分析概述" class="headerlink" title="词法分析概述"></a>词法分析概述</h2><p>词法分析顾名思义就是通过扫描源程序，识别出每一个单词，确定单词类型，然后转化为统一的机内表示——<code>词法单元（token）</code>形式。</p><p>token：&lt; 种别码，属性值&gt;</p><p>例如if、else对应唯一的表示形式。具体的表示形式如下表所示：</p><p><img alt="image-20191127170722792" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpkudcwfj30yc0dkte0.jpg" class="lazyload"></p><p>例如有一句代码为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(value!=<span class="number">100</span>)&#123;num++;&#125;</span><br></pre></td></tr></table></figure><p>则经过词法分析后如下所示，其中每句后的&lt;-,-&gt;表示每个单词的含义。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>      &lt; WHILE ,    -  &gt;  <span class="comment">// 关键词，一词一码</span></span><br><span class="line">(          &lt;SLP    ,    -  &gt;  <span class="comment">// 界限符，一词一码</span></span><br><span class="line">value      &lt;IDN    ,  value&gt;  <span class="comment">// 标识符，多词一码，&lt; 种别码，属性值value&gt;</span></span><br><span class="line">!=         &lt;NE     ,    -  &gt;  <span class="comment">// 运算符，一词一码</span></span><br><span class="line"><span class="number">100</span>        &lt;CONST,<span class="number">100</span>&gt; <span class="comment">// 常 量，一型一码</span></span><br><span class="line">)          &lt;SRP,-&gt;            <span class="comment">// 界限符，一词一码</span></span><br><span class="line">&#123;          &lt;LP,-&gt;             <span class="comment">// 界限符，一词一码</span></span><br><span class="line">num        &lt;IDN,num&gt;          <span class="comment">// 标识符，多词一码，&lt; 种别码，属性值value&gt;</span></span><br><span class="line">++         &lt;INC,-&gt;            <span class="comment">// 运算符，一词一码</span></span><br><span class="line">;          &lt;SEMI,-&gt;           <span class="comment">// 界限符，一词一码</span></span><br><span class="line">&#125;          &lt;RP,-&gt;             <span class="comment">// 界限符，一词一码</span></span><br></pre></td></tr></table></figure><h2 id="语法分析概述"><a href="#语法分析概述" class="headerlink" title="语法分析概述"></a>语法分析概述</h2><p>语法分析器(parser)从词法分析器输出的token序列中识别出各类短语，并构造<code>语法分析树(parsetree)</code>。简而言之就是将词法分析后识别出来的单词构成短语，将短语整合成一个完整的句子。</p><p>语法分析树描述了句子的语法结构。如下是<code>赋值语句</code>的语法分析树：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">position</span>      =      initial      +    rate      *    <span class="number">60</span>     ;  </span><br><span class="line">&lt;id，<span class="built_in">position</span>&gt;  &lt;=&gt;   &lt;id,initial&gt;  &lt;+&gt; &lt;id, rate&gt; &lt;*&gt; &lt;num,<span class="number">60</span>&gt; &lt;;&gt;</span><br></pre></td></tr></table></figure><p><img alt="image-20191127180738395" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9crbjmk6gj312o0dytcs.jpg" class="lazyload"></p><p>例如我们需要得到<code>变量声明的分析树</code>，变量声明可以是int a；也可以是int a,b,c；抽象成文法（变量声明的规则）和分析树为：</p><p><img alt="image-20191127181449598" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9crj1i7inj31460fg78x.jpg" class="lazyload"></p><h2 id="语义分析概述"><a href="#语义分析概述" class="headerlink" title="语义分析概述"></a>语义分析概述</h2><p>语义分析的主要任务是<code>收集标识符的属性信息</code>，其中包括种属（简单变量、复合变量···）、类型（整型、实型···）、存储位置、长度等；除此之外语义分析还要进行<code>语义检查</code>，其中包括变量是否是没有声明就使用了。</p><h2 id="中间代码生成及编译器后端概述"><a href="#中间代码生成及编译器后端概述" class="headerlink" title="中间代码生成及编译器后端概述"></a>中间代码生成及编译器后端概述</h2><p>常见的中间表示形式为：</p><ul><li><p><code>三地址码(Three-address Code)</code>：三地址码由类似于汇编语言的指令序列组成， 每个指令最多有三个操作数(operand)。</p></li><li><p><code>语法结构树/语法树(Syntax Trees)</code></p></li></ul><p>常见的为三地址形式，其中表示方法为<code>四元式(Quadruples)</code>：(op, y, z, x)。</p><p><img alt="image-20191127182026339" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9crouz1dzj310s0p8wn7.jpg" class="lazyload"></p><p>中间代码生成的案例为：</p><blockquote><p>[!!!重点题]先画出语法分析树，然后再进行分析</p></blockquote><p><img alt="image-20191127182553003" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cruj4rhyj313o0hcwn5.jpg" class="lazyload"></p><h1 id="语言及其文法"><a href="#语言及其文法" class="headerlink" title="语言及其文法"></a>语言及其文法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>正如英语是由句子组成的集合，而句子又是由单词和标点符号组成的序列那样。程序设计语言 C 语言，是由 C 程序所组成的集合，而程序是由类似 if , begin, end 的符号，字母和数字这样一些基本符号所组成。</p><p>从字面上看，每个程序都是一个“基本符号”串，设有一基本符号串，那么 C 语言可看成是在这个基本符号集上定义的，按一定规则构成的一切基本符号串组成的集合。</p><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表$$\sum$$是一个<strong>有穷</strong>的符号集合，其中符号包括<strong>字母、数字和标点符号</strong>等</p><p>如:</p><ul><li><p>二进制字母表：{ 0,1 } ；</p></li><li><p>ASCII字符集 ；</p></li><li><p>Unicode字符。</p></li></ul><h3 id="字母表上的运算"><a href="#字母表上的运算" class="headerlink" title="字母表上的运算"></a>字母表上的运算</h3><blockquote><p> 字母表 $\sum_1$ 和 $\sum_2$ 的<code>乘积</code>( product)</p></blockquote><p><img alt="image-20191127203325412" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvj89hi8j30rs07gabz.jpg" class="lazyload"></p><blockquote><p>字母表 $\sum$ 的<code>n次幂</code>( power)：长度为n的符号串构成的集合</p></blockquote><p><img alt="image-20191127203359267" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvjtdnjzj30u80a6go6.jpg" class="lazyload"></p><blockquote><p> 字母表 $\sum$ 的<code>正闭包</code>( positive closure)：长度为正数的符号串构成的集合</p></blockquote><p><img alt="image-20191127203508021" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvl0gye3j30wu09iad6.jpg" class="lazyload"></p><blockquote><p>字母表 $\sum$ 的克林闭包(Kleene closure)：任意符号串(<code>跟正闭包相比长度可以为零</code>）构成的集合</p></blockquote><p><img alt="image-20191127203705801" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvn26xlzj30ym08itbn.jpg" class="lazyload"></p><h3 id="符号串"><a href="#符号串" class="headerlink" title="符号串"></a>符号串</h3><p><strong>由字母表中的符号组成的任何有穷序列称为符号串。</strong></p><p><strong>串 s 的长度</strong>，通常记作 |s| ，是指 s 中符号的个数。例：|aab|=3。</p><p><strong>空串是长度为 0 的串</strong>，用 ε 表示，|ε|=0。</p><h3 id="串上的运算"><a href="#串上的运算" class="headerlink" title="串上的运算"></a>串上的运算</h3><blockquote><p>串的连接</p></blockquote><p>如果 x 和 y 是串，那么 x 和 y 的连接，是把 y 附加到 x 后面而形成的串，记作 xy。</p><p>例如，如果 x=dog 且 y=house，那么 xy=doghouse。</p><p>空串是连接运算的单位元，即，对于任何串 s 都有， εs=sε=s。</p><blockquote><p>串的幂运算：将 n 个 串连接起来。</p></blockquote><p><img alt="image-20191127204538740" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvvyj03cj30xs0buwh1.jpg" class="lazyload"></p><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><p>自然语言中句子的构成规则为：句子由名词短语构和动词短语成，名词短语由形容词和名词短语构成···，直到最终特定的名词、动词、形容词等。</p><p><strong>分析一个自然语言的例子，得出句子的构成规则。</strong></p><p><img alt="image-20191127201802385" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cv3an5odj314g0k8qcd.jpg" class="lazyload"></p><h3 id="文法的形式化定义"><a href="#文法的形式化定义" class="headerlink" title="文法的形式化定义"></a>文法的形式化定义</h3><p>$$<br>G = (V_T , V_N , P , S )<br>$$</p><ul><li><p>G：表示文法，文法由一个四元组定义</p></li><li><p><strong>终结符集合和非终结符集合都是字母表</strong></p></li><li><p><strong>终结符集合与非终结符集合是不相交的</strong> -&gt; $V_T∩V_N=Φ$ </p></li><li><p><strong>终结符集合与非终结符集合的并集是文法符号集</strong> -&gt; $V_T∪V_N$：文法符号集</p></li><li><p>$V_T$：</p><p><img alt="image-20191127210706311" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwiac7sij30y807amzp.jpg" class="lazyload"></p></li><li><p>$V_N$：<strong>因为从它们可以推出其他的语法成分，所以被称为非终结符</strong></p><p><img alt="image-20191127210747647" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwjbrw6nj30wi08kmzw.jpg" class="lazyload"></p></li><li><p>P：产生式集合，注意左部和右部的取值，左部是正闭包，右部是克林闭包</p><p>例： P = &lt;句子&gt; → &lt;名词短语&gt;&lt;动词短语&gt;, &lt;名词短语&gt; → &lt;形容词&gt;&lt;名词短语&gt;</p><p><img alt="image-20191127211430931" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwq1999lj30x60aqwie.jpg" class="lazyload"></p></li><li><p>S：开始符号</p><p>$S∈V_N$，开始符号(start symbol)表示的是该文法中最大的语法成分。例：S = &lt;句子&gt;</p><p><img alt="image-20191127212009896" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwvvddqrj30yg050gn9.jpg" class="lazyload"></p><p>例：<img alt="image-20191127212046791" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwwi6n07j30y408kgok.jpg" class="lazyload"></p></li></ul><h3 id="产生式的简写"><a href="#产生式的简写" class="headerlink" title="产生式的简写"></a>产生式的简写</h3><p><img alt="image-20191127212509659" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx138jbzj30ys0gsq7a.jpg" class="lazyload"></p><h3 id="符号的约定"><a href="#符号的约定" class="headerlink" title="符号的约定"></a>符号的约定</h3><ul><li><p>终结符</p><p><img alt="image-20191127213016136" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx6fd6qwj30xg0cuwkb.jpg" class="lazyload"></p></li><li><p>非终结符</p></li></ul><p><img alt="image-20191127213110142" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx7ceu2nj30yw0ck0zh.jpg" class="lazyload"></p><ul><li><p>其他</p><p><img alt="image-20191127213523082" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxbpc4g8j30ny0aqdqa.jpg" class="lazyload"></p></li></ul><h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><h3 id="推导与规约"><a href="#推导与规约" class="headerlink" title="推导与规约"></a>推导与规约</h3><p>假设自然语言的<strong>文法</strong>可以表示为</p><p><img alt="image-20191127213748634" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxe85up2j30sg0jijz9.jpg" class="lazyload"></p><p><strong>单词串</strong>：little boy eats apple</p><p>有了文法（语言规则），如何判定一个单词串是否是满足文法的句子？</p><p>答案是：<strong>推导和规约</strong>。</p><p>$ a_0$ 经过 n 步推导出$ a_n$ ，可简记为：$ a_0 -&gt; a_n$ </p><p><img alt="image-20191127215130972" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxsi5orij316209udl7.jpg" class="lazyload"></p><p><img alt="image-20191127215144948" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxspwvmpj31600ce42p.jpg" class="lazyload"></p><p>例：</p><p>由上而下为推导，即具体化的过程——-从生成语言的角度</p><p>由下而上为规约，即抽象化的过程——从识别语言的角度</p><p><img alt="image-20191127214236911" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxj8iz9dj315i0k444b.jpg" class="lazyload"></p><h3 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h3><blockquote><p>句型：</p></blockquote><p><img alt="image-20191127214426061" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxl48vy4j315y07owhd.jpg" class="lazyload"></p><blockquote><p>句子：<strong>句子是不包含非终结符的句型</strong></p></blockquote><p><img alt="image-20191127214450796" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxljms1mj316a024q3r.jpg" class="lazyload"></p><p>例：</p><p><img alt="image-20191127214531118" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxm92s64j31600fm0yl.jpg" class="lazyload"></p><h3 id="语言的形式化定义"><a href="#语言的形式化定义" class="headerlink" title="语言的形式化定义"></a>语言的形式化定义</h3><p>由文法 G 的开始符号 S 推导出的所有<code>句子</code>构成的集合称为<code>文法G生成的语言</code>，记作 L(G)，即：`</p><p><img alt="image-20191127215520196" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxwg8l4aj315g0203ym.jpg" class="lazyload"></p><blockquote><p>例1：</p></blockquote><p>$E-&gt;E+E | E * E | (E) | id$ 生成的语言中包含多少个<code>句子</code></p><p>答案是无数个，文法解决了无穷语言的有穷表示问题</p><blockquote><p>例2：</p></blockquote><p>我们现在拥有的文法 G 如下所示，其生成的语言标识符，即以字母开头的字符串。因为S定义为一个字母或以字母开头的字母数字串，即用于表示标识符。</p><p><img alt="image-20191127215638460" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxxthzt9j31640fo42p.jpg" class="lazyload"></p><h3 id="语言上的运算"><a href="#语言上的运算" class="headerlink" title="语言上的运算"></a>语言上的运算</h3><p><img alt="image-20191127220637268" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cy87ik0hj315w0fogrn.jpg" class="lazyload"></p><h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><h3 id="0型文法，无限制文法，短语结构文法"><a href="#0型文法，无限制文法，短语结构文法" class="headerlink" title="0型文法，无限制文法，短语结构文法"></a>0型文法，无限制文法，短语结构文法</h3><ul><li>α中至少包含1个非终结符</li></ul><p><img alt="image-20191127221027086" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyc6uglwj31600fe78m.jpg" class="lazyload"></p><h3 id="1型文法，上下文有关文法-CSG"><a href="#1型文法，上下文有关文法-CSG" class="headerlink" title="1型文法，上下文有关文法(CSG)"></a>1型文法，上下文有关文法(CSG)</h3><ul><li><p>产生式左部符号的个数不能多于右部</p></li><li><p>CSG不包含 $\varepsilon$ 产生式，即产生式<strong>右部是空串的产生式</strong>，因为左部至少包含一个非终结符，左部长度至少为1，如果右部是 $\varepsilon$ ，右部长度为1，与CGS定义不符合。</p></li></ul><p><img alt="image-20191127221328301" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyfbx748j315y0i2afd.jpg" class="lazyload"></p><h3 id="2型文法，上下文无关文法-CFG"><a href="#2型文法，上下文无关文法-CFG" class="headerlink" title="2型文法，上下文无关文法(CFG)"></a>2型文法，上下文无关文法(CFG)</h3><ul><li>左边是一个非终结符，将其替换不需要考虑其上下文</li><li>所举的例子即2型文法</li></ul><p><img alt="image-20191127221344869" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyfm18zwj315w0ig786.jpg" class="lazyload"></p><h3 id="3型文法，正规文法，正则文法-RG"><a href="#3型文法，正规文法，正则文法-RG" class="headerlink" title="3型文法，正规文法，正则文法(RG)"></a>3型文法，正规文法，正则文法(RG)</h3><ul><li>3型文法分为2种文法</li><li>产生式右部最多只有一个非终结符，且只能在一侧</li><li>例子中的两个文法都是指标识符，即一个字母或以字母开头的字母数字串</li><li>程序语言中的多数单词都能用正则文法表示</li></ul><p><img alt="image-20191127222052426" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyn3744ej315u0ian4k.jpg" class="lazyload"></p><h3 id="四种文法之间的关系"><a href="#四种文法之间的关系" class="headerlink" title="四种文法之间的关系"></a>四种文法之间的关系</h3><p><img alt="image-20191127222635614" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyszv3q5j31620fi43y.jpg" class="lazyload"></p><h2 id="上下文无关文法的分析树"><a href="#上下文无关文法的分析树" class="headerlink" title="上下文无关文法的分析树"></a>上下文无关文法的分析树</h2><p>程序语言中的多数单词都能用正则文法表示，但正则文法生成能力有限，句子构造则需要用上下文无关文法进行描述。</p><h3 id="CFG分析树定义"><a href="#CFG分析树定义" class="headerlink" title="CFG分析树定义"></a>CFG分析树定义</h3><p>例：图中跟节点表示的是对第三个式子的应用</p><p><img alt="image-20191127222833264" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyv3e5bpj315y0hwq9o.jpg" class="lazyload"></p><h3 id="分析树是推导的图形化表示"><a href="#分析树是推导的图形化表示" class="headerlink" title="分析树是推导的图形化表示"></a>分析树是推导的图形化表示</h3><p>推导过程中产生许多<code>句型</code>,最终推导出分析树的边缘</p><p><img alt="image-20191127223759244" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cz4u6zi1j315q0fktds.jpg" class="lazyload"> </p><h3 id="句型的短语"><a href="#句型的短语" class="headerlink" title="句型的短语"></a>句型的短语</h3><p>给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个<code>短语</code>。</p><p>如果子树只有父子两代节点，那么这课子树的边缘称为该句型的一个<code>直接短语</code>。</p><p><strong>直接短语一定是产生式的右部，但产生式的右部不一定是给定句型的直接短语，但可能是其他句型的直接短语</strong></p><p><img alt="image-20191127224229562" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cz9jcs2rj316609077h.jpg" class="lazyload"></p><p>例：人民、生活、水平是该句子的直接短语，而高人、民生、活水虽然也是第5个产生式的右部，但是在这棵分析树中，它们不是直接短语。</p><p><img alt="image-20191127225119891" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cziqh449j30o40bigub.jpg" class="lazyload"></p><h3 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h3><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。</p><p>下面这个例子产生二义的原因是else可以跟第一个if条件语句和第二个if条件语句相配。</p><p><code>消歧规则</code>：每个else和最近的尚未匹配的if进行匹配，所以只有第一个分析树</p><p><img alt="image-20191127225609332" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cznqxtqrj315y0fcadz.jpg" class="lazyload"></p><h3 id="二义性文法的判定"><a href="#二义性文法的判定" class="headerlink" title="二义性文法的判定"></a>二义性文法的判定</h3><p>对于任意一个上下文无关文法，不存在一个算法，判断它是无二义性的，但能给出一组充分条件，满足这组充分条件的文法是无二义性的。</p><ul><li>满足，肯定无二义性</li><li>不满足，也未必就是有二义性的</li></ul><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>词法分析这一章从正则表达式到有穷自动机，讲述了如何利用<strong>确定性的有穷自动机</strong>来进行单词的识别。其中正则表达式和有穷自动机之间也有相应的<strong>转化</strong>关系。</p><p>本文内容：介绍正则定义，正则表达式，有穷自动机（确定的有穷自动机 DFA，不确定的有穷自动机 NFA），NFA 转换为等价的 DFA，DFA 的化简，识别单词的 DFA ，典型例题及详细解答。</p><p>在前面我们说过，程序设计语言中的大多数单词都可以用<strong>正则文法</strong>来描述，在这一章中我们将介绍描述<strong>正则语言的更紧凑的方法——正则表达式</strong>。</p><h2 id="正则表达式（RE）"><a href="#正则表达式（RE）" class="headerlink" title="正则表达式（RE）"></a>正则表达式（RE）</h2><p>语言是一个集合，因此我们可以在语言上进行多种集合运算。比如说并运算，乘积运算（即连接运算），闭包运算等等。</p><blockquote><p>正则表达式示例</p></blockquote><p>接下来我们看一个语言的例子，如下图所示：</p><p><img alt="image-20191127234530543" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d138lzjdj30na0bmdnz.jpg" class="lazyload"></p><p>这个语言的字首是字母 a，接下来连接一个任意长度的 a,b 串，再接下来连接一个空串。连接一个空串就代表句子已经结束了。除此之外，我们还可以连接一个点号（.）或者下划线（_）或者一个长度大于等于1 的 a,b串。</p><p>这个式子写起来比较复杂，因此我们要介绍正则表达式。</p><p><strong>正则表达式（Regular Expression，RE）是一种用来描述正则语言的更紧凑的表达方式。</strong></p><p>例如上面的语言可以用正则表达式来表示，如上图所示。</p><p>这个正则表达式表示，句子的第一个符号是字母 a ，接下来连接<strong>一个任意长度的 a,b串</strong>，再接下来连接一个空串。连接一个空串就代表句子已经结束了。除此之外，我们还可以连接一个点号（.）或者下划线（_）或者一个长度大于等于1 的 a,b 串。</p><p>从这个例子中，我们可以看出，正则表达式可以用<strong>较小的正则表达式</strong>根据特定规则来<code>递归</code>构建。</p><p>每个正则表达式 r 定义（表示）一个语言，记为 $L(r)$。这个语言也是根据 r 的子表达式所表示的语言<code>递归</code>定义的。</p><h3 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h3><ul><li>空串是一个正则表达式，那么它所表达的语言也只包括空串。</li><li>字母表上的任何一个符号都是一个正则表达式，那么它所表示的语言只包含它本身。</li><li>假设 r 和 s 都是正则表达式，它们表示的语言分别是 $L(r)$ 和  $L(s)$ ，则:<ul><li>$r|s$ （r 或 s）也是一个正则表达式，它表示的语言是 $L(r|s) = L(r) ∪ L(s)$</li><li>rs（r 和 s 的连接）也是一个正则表达式，它表示的语言是 $L(rs) = L(r)L(s)$</li><li>$r^<em>$（r 的克林闭包）也是一个正则表达式，它表示的语言是也 $L(r^</em>) = (L(r))^*$</li><li>$(r)$ 是一个正则表达式，它表示的语言就是 $L(r)$，即 $L((r))=L(r)$</li></ul></li></ul><p><img alt="image-20191127234942937" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d17haqe3j31680fs0xj.jpg" class="lazyload"></p><p>例：</p><p>假设符号表中有 a,b。则 a 是一个正则表达式，b 也是一个正则表达式。可以推导出以下的正则表达式：</p><p><img alt="image-20191127235851699" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1h3chy5j315y0gi0x5.jpg" class="lazyload"></p><p>例：</p><p>描述 C 语言中无符号整数的正则表达式</p><ul><li>十进制整数的正则表达式：第一个符号是1<del>9中的一个数字，接下来连接若干个 0</del>9 的数字，或者连接符号 0。</li><li>八进制整数的正则表达式：<strong>第一个符号是数字0</strong>，第二个符号是1<del>7中的一个数字，接下来连接若干个 0</del>7 中的数字。</li><li>十六进制整数的正则表达式：<strong>第一个符号是0，第二个符号是 x</strong>，第三个符号是 1～f 中的符号，接下来连接若干个 0～f 中的符号。</li></ul><p><img alt="image-20191128000002054" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1i7wi9kj315w0g20wu.jpg" class="lazyload"></p><h3 id="正则表达式的代数定律"><a href="#正则表达式的代数定律" class="headerlink" title="正则表达式的代数定律"></a>正则表达式的代数定律</h3><blockquote><p>正则语言：可以用正则表达式定义的语言叫做正则语言或正则集合。</p></blockquote><p>正则表达式也遵循一些<strong>代数定律</strong>，如下图所示：</p><p><img alt="image-20191128000355664" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1mdaijjj315w0g2q76.jpg" class="lazyload"></p><p><strong>正则文法与正则表达式等价</strong>：</p><ul><li><p>对于任何一个正则文法 G，存在定义同一语言的正则表达式 r。</p></li><li><p>对任何正则表达式 r，存在生成同一语言的正则文法 G。</p></li><li><p>总之，有 G 就有 r ，有 r 就有 G 。</p></li></ul><h2 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h2><p>为了方便起见，我们可以给某些<code>正则表达式命名</code>，像使用字母表中的符号一样，使用这些名字来构造正则表达式。（这就是正则定义提出的定义和基本思想）</p><p>正则定义就是给正则表达式命名，右侧是字母表与已定义的正则定义的并集</p><p><img alt="image-20191128000623988" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1p2ykz0j315y0igwm9.jpg" class="lazyload"></p><h3 id="例1：C语言的标识符"><a href="#例1：C语言的标识符" class="headerlink" title="例1：C语言的标识符"></a>例1：C语言的标识符</h3><p><strong>C语言中标识符的正则定义</strong>：</p><ul><li><p>第一个正则表达式，表示0~9中的某个数字，我们给它取一个名字，digit</p></li><li><p>第二个正则表示式，表示一个字母（小写字母或大写字母）和一个下划线。我们给它取一个名字，letter_</p></li><li><p>接下来我们用起好的这两个名字，来构造第三个正则表达式。</p></li><li><p>第三个正则表示式，首先是一个 letter_，接下来连接一个 letter _ 或 digit 构成的字符串。这个表达式表示的是字母打头的字符数字串。（正是标识符的定义）</p></li></ul><p><img alt="image-20191128001129801" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1u5ogn2j315m0aqmzw.jpg" class="lazyload"></p><h3 id="例2：无符号数"><a href="#例2：无符号数" class="headerlink" title="例2：无符号数"></a>例2：无符号数</h3><p><strong>（整型或浮点数）无符号数的正则定义</strong>：</p><ul><li><p>digit，还是表示一个数字</p></li><li><p>digits，digit <strong>连接</strong>上一个 digit 的克林闭包，表示的是一个长度&gt;=1 的数字串。</p></li><li><p>optionalFraction，点号（.）后面连接一个 digits 或 这个表达式是一个空串。（这个符号表示的是一个小数部分，或一个空串）代表<strong>可选</strong>的小数部分。</p></li><li><p>optionalExponent，大写字母 E 后面连接一个 + （正号）或 一个 -（负号）或直接连接一个长度大于等于1 的数字串（digits），或者这个表达式为空串。可选的指数部分。</p></li><li><p>number，长度大于等于1 的数字串，连接一个可选的小数部分，连接一个可选的指数部分。</p><ul><li><p>当可选的小数部分为空串时，这个表达式为一个整数的若干次幂，如 2E-3<br>若可选的指数部分为空串时，这个正则表达式为小数。比如说 2.15</p></li><li><p>若可选的小数部分和可选的指数部分都为空串时，这个正则表达式为整数。比如说 2</p></li><li><p>若可选的小数部分和可选的指数部分都不为空串时，这个正则表达式为指数形式的浮点数。比如说 2.15E+3, 2.15E-3。<br>当指数为正号时，指数是可以省略的，如 2.15E3</p></li></ul></li></ul><p><img alt="image-20191128001235949" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1vanyfbj31600hygrx.jpg" class="lazyload"></p><h2 id="有穷自动机（FA）"><a href="#有穷自动机（FA）" class="headerlink" title="有穷自动机（FA）"></a>有穷自动机（FA）</h2><p>有穷自动机（Finite Automata，FA）由两位神经物理学家Meculoch 和 Pitts 于 1948年提出，是对一类处理系统建立的数学模型。</p><p><strong>重要的理论基础</strong></p><p>这类系统具有一系列<code>离散的输入输出信息和有穷数目的内部状态</code>。</p><p>系统只需要根据当前所处的状态和当前面临的输入信息，就可以决定系统的<strong>后继行为</strong>。每当系统处理了当前的输入后，系统的<strong>内部状态也将发生改变</strong>。</p><h3 id="FA-的典型例子"><a href="#FA-的典型例子" class="headerlink" title="FA 的典型例子"></a>FA 的典型例子</h3><p>电梯控制装置</p><ul><li>输入：顾客的<strong>乘梯需求</strong>（所要到达的层号）</li><li>状态：电梯<strong>所处的层数+运动方向</strong></li><li>电梯控制装置<strong>并不需要记住先前全部的服务要求</strong>，只需要知道电梯<strong>当前所处的状态</strong>以及<strong>还没有满足的所有服务请求</strong>。</li></ul><h3 id="FA-模型"><a href="#FA-模型" class="headerlink" title="FA 模型"></a>FA 模型</h3><p><strong>FA模型</strong>由以下三部分组成：</p><ul><li><p>输入带：用来存放输入符号串</p></li><li><p>读头：<strong>从左向右</strong>逐个读取输入符号，不能修改（只读），不能往返移动</p></li><li><p>有穷控制器：具有有穷个状态数，根据<strong>当前的状态 + 当前输入符号</strong>控制转入<strong>下一状态</strong>。</p></li></ul><p><img alt="image-20191128002151798" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d24xnuskj315w07qaat.jpg" class="lazyload"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>有穷自动机可以用<strong>转换图</strong>来表示。</p><p><strong>结点</strong>：FA 的<strong>状态</strong></p><ul><li>初始状态（开始状态）：只有一个，由 <strong>start 箭头指向</strong></li><li>终止状态：可以由多个，用<strong>双圈</strong>表示（下例中的 3）</li></ul><p>带标记的<strong>有向边</strong>：如果对于<strong>输入 a</strong> ，存在一个从状态 p 到状态 q 的转换，就在 p、q 之间画一条有向边，并标记上 a。</p><p><img alt="image-20191128002520110" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d28lwfx1j316205yq43.jpg" class="lazyload"></p><p>在这个图中，一共有4个状态，分别为状态0，状态1，状态2，状态3。状态0为初始状态，由start箭头指向，状态3为终止状态，用双圈表示。</p><h3 id="FA定义（接受）的语言"><a href="#FA定义（接受）的语言" class="headerlink" title="FA定义（接受）的语言"></a>FA定义（接受）的语言</h3><p>给定输入串 x，如果存在一个对应于串 x 的<strong>从初始状态到某个终止状态的转换序列</strong>，则称 <strong>串 x 被该 FA 接受</strong>。</p><p>由一个<strong>有穷自动机 M 接受的所有串构成的集合</strong>称为是<strong>该 FA定义（或接收）的语言，记为  $ L(M)$</strong>。</p><p><img alt="image-20191128002951076" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2d8z3s8j315w080419.jpg" class="lazyload"></p><p>对于 abbaabb来说，我们可以判断是否为这个 FA 所接受。能。</p><p>接受第一个 a后，由初始状态0转换到状态 0，再遇到两个 b 后，依然保持状态 0，遇到下个 a 时，还保持状态 0，再遇到一个 a 时，转换到状态1，接下来两个 b，分别转换到状态2，和最终状态3。</p><h3 id="最长子串匹配原则"><a href="#最长子串匹配原则" class="headerlink" title="最长子串匹配原则"></a>最长子串匹配原则</h3><p>当<strong>输入串的多个前缀与一个或多个模式匹配时</strong>，我们总是<strong>选择最长的前缀</strong>进行匹配。</p><p><img alt="image-20191128003035729" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2e05g95j315y066q44.jpg" class="lazyload"></p><p>对于上图来说，当遇到 &lt; 号时，转换到状态1，当遇到 &lt; = 号时，转换到状态2。</p><p>即：在到达某个<code>终态</code>之后，只要输入带上还有符号，DFA 就<strong>继续前进</strong>，以便找到尽可能长的匹配。</p><h2 id="有穷自动机的分类"><a href="#有穷自动机的分类" class="headerlink" title="有穷自动机的分类"></a>有穷自动机的分类</h2><ul><li>确定的有穷自动机（DFA）</li><li>不确定的有穷自动机（NFA）</li></ul><h3 id="确定的有穷自动机-DFA"><a href="#确定的有穷自动机-DFA" class="headerlink" title="确定的有穷自动机 (DFA)"></a>确定的有穷自动机 (DFA)</h3><ul><li><p>DFA定义为一个五元组</p></li><li><p>假设字母表中没有 $\varepsilon$</p></li></ul><p><img alt="image-20191128003106533" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2ejg4ayj315s0cgwjf.jpg" class="lazyload"></p><p>例：</p><p>在这个有穷自动机DFA 中，</p><p>状态集S 包含4个状态。分别是：状态0， 状态1， 状态2， 状态3。</p><p>输入字母表Σ 中包含的元素是：符号a，符号b。</p><p>转换函数 δ ，我们用一个转换表来表示。</p><p>例：状态0 遇到符号 a 时，变成状态1，状态0 遇到 符号 b 时，依旧是状态 0。以此类推，完成<code>转换表(重点考点)</code>。</p><ul><li>3是终止态，用 * 标识。</li></ul><blockquote><p>DFA可以用状态图或转换表两种等价方式来表示。</p></blockquote><p><img alt="image-20191128003129846" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2eyc12zj31480cetbl.jpg" class="lazyload"></p><blockquote><p>DFA 的算法实现</p></blockquote><ul><li><p>输入：以文件结束符 eof 结尾的字符串 x，DFA 的开始状态为 s0，接受状态集 F，转换函数 move</p></li><li><p>输出：如果 D 接受 x，则回答“yes”，否则回答“no”</p></li><li><p>方法：将下述算法应用于输入串 x</p><p><img alt="image-20191128173024112" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dvv3vc2ej30po0eggzw.jpg" class="lazyload"></p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s=s0;</span><br><span class="line">c=nextChar();    <span class="comment">//返回输入串x的下一个符号</span></span><br><span class="line"><span class="keyword">while</span>(c!=eof)</span><br><span class="line">&#123;</span><br><span class="line">    s=<span class="built_in">move</span>(s,c); <span class="comment">//从状态s出发，沿着标记为c的边所能到达的状态</span></span><br><span class="line">    c=nextChar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s在F中)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"yes"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"no"</span>;</span><br></pre></td></tr></table></figure><h3 id="非确定的FA-NFA"><a href="#非确定的FA-NFA" class="headerlink" title="非确定的FA (NFA)"></a>非确定的FA (NFA)</h3><ul><li><p>DFA定义为一个五元组</p></li><li><p><strong>同样假设字母表中没有 $\varepsilon$</strong></p></li><li><p>NFA 与 DFA <strong><code>唯一的区别</code>是：从状态 s 出发，能到达的状态可能有多个。（并不是唯一确定的）</strong></p><p><strong>因此，转换函数为集合，而不是元素。</strong></p></li></ul><p><img alt="image-20191128011646974" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3q2x2fcj315w0cc78p.jpg" class="lazyload"></p><p>例：</p><p>在这个例子中，在初始状态0，遇到符号 a 的时候，它进入的状态包含状态0和状态1 ，两个元素。在状态0 时，遇到符号 b 时，它进入的状态只有 状态 0，因此集合中只有状态 0 一个元素。</p><p>如果转换函数 <strong>没有给出对应于状态-输入对的信息</strong>，就把<strong>空集放入到相应的表项中。</strong></p><p><img alt="image-20191128011817554" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3rmyp15j314c0cugpe.jpg" class="lazyload"></p><blockquote><p>带有 ε边 的 NFA</p></blockquote><p>在状态 a，不需要遇到任何符号，即可进入状态 b，在状态 b，不需要任何符号，即可进入状态 c。</p><p>一旦进入状态 b，就不再接受符号 0，同理，一旦进入状态 c，就不在接受符号 1。</p><p>这个带有 空边 的NFA 接受的语言是 由若干个 0 连接 若干个 1 再连接上 若干个 2。（r=0 * 1 * 2*）</p><p><img alt="image-20191128011907201" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3shyfkpj315m0do43u.jpg" class="lazyload"></p><blockquote><p>带有 ε边 和 不带有 ε边 的 NFA的等价性</p></blockquote><ul><li>不带空边的状态 A：由若干个 0 构成</li><li>不带空边的状态 B：由若干个 0 连接若干个 1 构成</li><li>不带空边的状态 C：由若干个 0 连接 若干个 1 连接 若干个 2 构成</li></ul><p>但是状态A,B,C 都可以概括为若干个 0 连接 若干个 1 再连接上 若干个 2 构成。</p><p><img alt="image-20191128012012232" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3tn0qdzj315o0b0tcb.jpg" class="lazyload"></p><h3 id="DFA和NFA的等价性-重点考点"><a href="#DFA和NFA的等价性-重点考点" class="headerlink" title="DFA和NFA的等价性(重点考点)"></a>DFA和NFA的等价性(重点考点)</h3><p>对任何非确定的有穷自动机 NFA，存在定义<strong>同一语言</strong>的确定的有穷自动机 DFA。</p><p>对任何确定的有穷自动机 DFA，存在定义同一语言的非确定的有穷自动机 NFA。</p><blockquote><p>DFA 和 NFA 可以识别相同的语言</p></blockquote><p>这两个 DFA 和 NFA 都识别的是以 abb结尾 的 a,b 串。</p><p><img alt="image-20191128163557050" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9duagii6zj31500cgdjt.jpg" class="lazyload"></p><blockquote><p>等价性<code>(重点考点)</code></p></blockquote><ol><li><p><code>(重点考点)</code>：正则文法(即3型文法，a-&gt;b形式) = 正则表达式(大概是字符串，正则表达式是正则语言更紧凑的表达方式) = 有穷自动机</p></li><li><p>给定正则文法，可以构造等价的有穷自动机，给定有穷自动机，能够构造出相应的正则文法。</p></li><li><p><code>(重点)</code>：DFA和NFA都可以识别同一种语言，但就在表现形式而言，NFA比DFA更加直观，就计算机实现而言，NFA比DFA更难实现。</p></li><li><p>从<strong>正则表达式</strong>构造<strong>NFA</strong>比较简单，然后再将NFA转换成<strong>DFA</strong></p></li><li><p>带有 ε边 和 不带有 ε边 的 NFA也具有等价性</p></li></ol><h2 id="正则表达式和有穷自动机之间的转换"><a href="#正则表达式和有穷自动机之间的转换" class="headerlink" title="正则表达式和有穷自动机之间的转换"></a>正则表达式和有穷自动机之间的转换</h2><p><code>(重点考点)</code></p><blockquote><p>记住几个常见的，然后把RE不停分解即可</p></blockquote><p>正则表达式是采用<strong>符号序列</strong>的模式，它可以很直观的描述单词的构成。但在构造分析器时，我们真正实现和模拟的是 <strong>DFA</strong>。因此这涉及到从正则表达式到有穷自动机的转换。</p><p>从<strong>正则表达式</strong>到 <strong>DFA</strong> 的转换是比较困难的。所以我们通常是 <strong>将正则表达式 转换成 NFA ，再将 NFA 转换 成 DFA。</strong></p><p>即：<strong>RE -&gt; NFA -&gt; DFA</strong></p><p><img alt="image-20191128163642655" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dub8l8j0j315m0dyq5w.jpg" class="lazyload"></p><h3 id="从RE到NFA"><a href="#从RE到NFA" class="headerlink" title="从RE到NFA"></a>从RE到NFA</h3><p><img alt="image-20191128214119559" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e346vsuwj315u0bmac9.jpg" class="lazyload"></p><p>正则表达式经过运算，仍然是正则表达式</p><p><img alt="image-20191128214307836" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e362sh7pj31660fkgpf.jpg" class="lazyload"></p><p><strong>不停的分解子表达式，即可求得最终的 NFA。</strong></p><p>例：</p><p>将正则表达式 r=（a|b）*abb 对应的 NFA，不断地进行分解。</p><p>首先将 （a|b)* abb 分解成 4 个子表达式连接的形式。再将 （a|b）* 继续进行分解，最终得到最后结果。</p><p><img alt="image-20191128214509128" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e386ff3xj315u0cytai.jpg" class="lazyload"></p><h2 id="从NFA到DFA的转换"><a href="#从NFA到DFA的转换" class="headerlink" title="从NFA到DFA的转换"></a>从NFA到DFA的转换</h2><p><code>(重点考点)</code></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>例1:</strong></p><p><img alt="image-20191128214827894" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3bmlyezj313g0dyn1p.jpg" class="lazyload"></p><blockquote><p> NFA转换表 -&gt; 根据表新的状态</p></blockquote><p><strong>从 NFA 转换到 DFA 时，我们要构造新的状态。</strong></p><p>比如说，在初始状态 a ，遇到符号 a 时，可能继续保持 状态 a，也有可能转换到 状态 b。因此构造新的状态 a,b。</p><p>验证NFA和DFA是否等价：表达的正则表达式一样</p><p><strong>DFA 的每个状态都是由 NFA 中的状态构成的集合</strong>，即 NFA 状态集合的一个子集。</p><p><strong>例2：</strong>带有 ε 边 的 NFA 到 DFA 的转换</p><p>==注意转换表的生成==，A遇到0可以到状态ABC，遇到1可以到状态BC,遇到2可以到状态C.</p><p><code>转换表中有几个非空集合，最后DFA就有几条状态转移线-&gt;这是错误的结论，应该跟着它的思路去推导出来，这种题要重新自己做一遍</code></p><p>因为 状态 A 不需要任何输入，即可转换成状态 B，状态 C。所有在遇到输入 0时，它既可以是状态 A，也可以是 状态 B，状态 C。后面同理，即可得状态表。</p><p>![image-20191128215348210](/Users/hamster/Library/Application Support/typora-user-images/image-20191128215348210.png)</p><p>把ABC组合起来构成start，同时也是终结态。注意<code>跟着这个表达式的结构画出NFA和DFA</code></p><h3 id="子集构造法"><a href="#子集构造法" class="headerlink" title="子集构造法"></a>子集构造法</h3><p><code>这个MOOC讲的比较模糊，建议结合课堂例题再看一下，感觉期末肯定会考</code></p><p>DFA的每个状态都是一个由 NFA中的状态构成的集合,即 NFA状态集合的一个<strong>子集</strong>：</p><p><img alt="image-20191128215642257" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3k7d3npj315u0j67b7.jpg" class="lazyload"></p><h3 id="计算-ε-closure-空闭包函数"><a href="#计算-ε-closure-空闭包函数" class="headerlink" title="计算 ε-closure 空闭包函数"></a>计算 ε-closure 空闭包函数</h3><p><img alt="image-20191128220820422" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3wanifwj31620f8tch.jpg" class="lazyload"></p><h2 id="识别单词的DFA"><a href="#识别单词的DFA" class="headerlink" title="识别单词的DFA"></a>识别单词的DFA</h2><p><code>过程总结：先写出正则定义，再写出NFA，最后把NFA转化成DFA</code> </p><h3 id="识别标识符的-DFA"><a href="#识别标识符的-DFA" class="headerlink" title="识别标识符的 DFA"></a>识别标识符的 DFA</h3><p>下面图中识别标识符的 DFA，第一部分识别字母和下划线，第二部分识别字母和下换线和数字组成的串。</p><p>因为这个 NFA 就是 DFA，因此不需要进行转换。</p><p><img alt="image-20191128220851091" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3wufgpzj315w0di777.jpg" class="lazyload"></p><h3 id="识别无符号数的-DFA"><a href="#识别无符号数的-DFA" class="headerlink" title="识别无符号数的 DFA"></a>识别无符号数的 DFA</h3><p>第一部分是长度大于等于1的数字串，第二部分是可选的小数部分（两个子表达式进行或运算得到的），第三部分是可选的指数部分（两个子表达式进行或运算得到的）。</p><p><img alt="image-20191128220929335" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3xhzsydj31620bygpj.jpg" class="lazyload"></p><p>再将 NFA 转换成 DFA，如下图所示：</p><p><code>自己推导一遍</code></p><p><img alt="image-20191128221020821" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3ydxik7j313a0fcgyy.jpg" class="lazyload"></p><h3 id="识别各进制无符号整数的-DFA"><a href="#识别各进制无符号整数的-DFA" class="headerlink" title="识别各进制无符号整数的 DFA"></a>识别各进制无符号整数的 DFA</h3><p><img alt="image-20191128221044975" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3ytas6aj315u0dkgrb.jpg" class="lazyload"></p><h3 id="识别注释的-DFA"><a href="#识别注释的-DFA" class="headerlink" title="识别注释的 DFA"></a>识别注释的 DFA</h3><p><img alt="image-20191128221107888" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3z7kk1oj315s05kabh.jpg" class="lazyload"></p><h3 id="识别-token-的-DFA"><a href="#识别-token-的-DFA" class="headerlink" title="识别 token 的 DFA"></a>识别 token 的 DFA</h3><p>识别关键字时把IDN与关键字表对照查询</p><p><img alt="image-20191128221135193" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3zop5plj315y0dgtcg.jpg" class="lazyload"></p><h2 id="词法分析阶段的错误处理"><a href="#词法分析阶段的错误处理" class="headerlink" title="词法分析阶段的错误处理"></a>词法分析阶段的错误处理</h2><h3 id="词法分析阶段可检测错误的类型"><a href="#词法分析阶段可检测错误的类型" class="headerlink" title="词法分析阶段可检测错误的类型"></a>词法分析阶段可检测错误的类型</h3><ol><li><p>单词拼写错误</p><p>例：int i=0x3G,float j=1.05e</p></li><li><p>非法字符</p><p>例：~@<br>词法错误检测<br>如果当前状态与当前输入符号在转换表对应项中的信息为空，而当前状态又不是终止状态，则调用错误处理程序。</p></li></ol><h3 id="错误处理程序"><a href="#错误处理程序" class="headerlink" title="错误处理程序"></a>错误处理程序</h3><p>根据<strong>最长子串匹配原则</strong>，查找已扫描字符串中最后一个对应于某终态的字符</p><ul><li>如果找到了，将该字符与其前面的字符识别成一个单词。然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词</li><li>如果没找到，则确定出错，采用错误恢复策略。</li></ul><h3 id="错误恢复策略"><a href="#错误恢复策略" class="headerlink" title="错误恢复策略"></a>错误恢复策略</h3><p>最简单的错误恢复策略：“<strong>恐慌模式</strong>”恢复</p><p>从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止。</p><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>语法分析的任务是根据给定的文法，识别数据中的各类短语，并构造<strong>语法分析树</strong>。如果输入串的各个单词恰好自左至右地站在分析树的各个节点上，则该词串就是该语言的一个<strong>句子</strong>。</p><p>构造的方法主要分为2类，包括<strong>自顶向下分析</strong>和<strong>自底向上分析</strong>。</p><h2 id="自顶向下分析概述"><a href="#自顶向下分析概述" class="headerlink" title="自顶向下分析概述"></a>自顶向下分析概述</h2><p>自顶向下的分析是指从分析树的顶部（根节点）向底部（叶节点）方向构造分析树，可以看做是从文法<strong>开始符号S</strong>推导出单词串w的过程，例如：</p><p><img alt="image-20191130114221614" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9fx1lv4vwj315y0bgaeo.jpg" class="lazyload"></p><p>输入为id+(id+id)，可以理解为通过语法分析树可以最终得到id+(id+id)，即将叶子节点连接起来就可以构成id+(id+id)。</p><p>每次推导中都要作两个选择：</p><ul><li>替换哪一个非终结符</li><li>用哪个候选式来替换非终结符</li></ul><h3 id="最左推导和最右推导"><a href="#最左推导和最右推导" class="headerlink" title="最左推导和最右推导"></a>最左推导和最右推导</h3><p><strong>最左推导</strong></p><p>在最左推导中，从文法的开始符号起，总是选择每个句型的最左非终结符进行替换，得到的句型称 为当前文法的最左句型(left-sentential form)</p><p><strong>最右推导与最左规约</strong></p><p>在最右推导中，总是选择每个句型的最右非终结符进行替换</p><p><img alt="image-20191130114317278" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9fx2k8ypfj315s0bmgpm.jpg" class="lazyload"></p><p>在<strong>自底向上</strong>的分析中，总是采用<strong>最左归约</strong>的方式，因此把最左归约称为<strong>规范归约</strong>，而最右推导相应地称为<strong>规范推导</strong></p><blockquote><p>从右边开始推导比较规范</p><p>自底向上：最左规约</p><p>自顶向下：最左推导 </p></blockquote><p>最左推导和最右推导具有<strong>唯一性</strong>。</p><h3 id="自顶向下的语法分析采用最左推导方式"><a href="#自顶向下的语法分析采用最左推导方式" class="headerlink" title="自顶向下的语法分析采用最左推导方式"></a>自顶向下的语法分析采用最左推导方式</h3><p><img alt="image-20191201002921672" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9gj7pzz0jj30p405e79m.jpg" class="lazyload"></p><p><strong>自顶向下</strong>的语法分析采用<strong>最左推 导</strong>方式，总是选择每个句型的最左非终结符进行替换 ，根据输入流中的下一个终结符，选择最左非终结符的一个候选式。</p><p><code>试着写一下下面的题，用最左推导</code></p><p><img alt="image-20191130114354939" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9fx37mbodj315s0dmwhd.jpg" class="lazyload"></p><p>当非终结符的选择不止一种的时候，叶子节点是什么要参考当前的输入指针是什么。当前指针指向的符号已经使用则进行后移。如指针指向+号表示：此次要选择以+号开头的非终结符。</p><h3 id="自顶向下语法分析的通用形式"><a href="#自顶向下语法分析的通用形式" class="headerlink" title="自顶向下语法分析的通用形式"></a>自顶向下语法分析的通用形式</h3><p>递归下降分析(Recursive-Descent Parsing)，由一组<strong>过程</strong>组成，每个过程对应一个<strong>非终结符</strong> 。</p><p>从文法开始符号S对应的过程开始，其中递归调用文法中其它非终结符对应 的过程。如果S对应的过程体恰好扫描了整个输入串，则成功完成语法分析。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">( )</span> </span>&#123; </span><br><span class="line"><span class="number">1</span>)选择一个A产生式，A →X1X2… Xk； </span><br><span class="line"><span class="number">2</span>)<span class="keyword">for</span>( i = <span class="number">1</span> to k) &#123; </span><br><span class="line"><span class="number">3</span>)<span class="keyword">if</span>( Xi是一个非终结符号) </span><br><span class="line"><span class="number">4</span>)调用过程Xi ( ) ; </span><br><span class="line"><span class="number">5</span>)<span class="keyword">else</span>  <span class="keyword">if</span> ( Xi等于当前的输入符号a)       </span><br><span class="line"><span class="number">6</span>)读入下一个输入符号; </span><br><span class="line"><span class="number">7</span>)<span class="keyword">else</span> <span class="comment">/* 发生了一个错误*/</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但可能需要回溯，从而导致效率比较低。需要回溯的分析器叫做不确定的分析器。</p><h3 id="预测分析-Predictive-Parsing"><a href="#预测分析-Predictive-Parsing" class="headerlink" title="预测分析(Predictive Parsing)"></a>预测分析(Predictive Parsing)</h3><p>预测分析是递归下降分析技术的一个特例，通过在输入中向前看固定个数（通常是一个）符号来选 择正确的A-产生式。</p><p>可以对某些文法构造出<strong>向前看k个</strong>输入符号的预测分析器，该类文法有时也称为<strong>LL(k) 文法</strong>类</p><p><strong>预测分析不需要回溯</strong>，是一种确定的自顶向下分析方法<br>。</p><h2 id="文法转化"><a href="#文法转化" class="headerlink" title="文法转化"></a>文法转化</h2><p>并不是所有的文法都适合自顶向下的分析。</p><p>同一非终结符的多个候选式存在<strong>共同前缀</strong>，将导致<strong>回溯现象</strong>，例如：</p><p><strong>问题1:</strong>此时就会在a的时候产生歧义。</p><p><img alt="image-20191201004042231" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9gjjg6a5tj30ke0a8dlx.jpg" class="lazyload"></p><p><strong>问题2</strong>:左递归文法会使递归下降分析器陷入<strong>无限循环</strong></p><p>含有A→Aα形式产生式的文法称为是直接左递归的 (immediate left recursive)</p><p>如果一个文法中有一个非终结符 A 使得对某个串α存 在一个推导A⇒+AαA\Rightarrow ^+AαA⇒<br>+<br> Aα ，那么这个文法就是左递归的。</p><p>经过两步或两步以上推导产生的左递归称为是间接左递归的。</p><p><img alt="image-20191201004426055" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9gjnbtvm9j30os08igqh.jpg" class="lazyload"></p><h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><h1 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h1><h2 id="语法制导翻译概述"><a href="#语法制导翻译概述" class="headerlink" title="语法制导翻译概述"></a>语法制导翻译概述</h2><p>将语义分析和中间代码生成统称为语义翻译，而语义翻译和语法分析统称为<strong>语法制导翻译</strong>，边分析语法，边完成制导翻译的过程</p><p><img alt="image-20191128110328713" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dkoj6pfyj312a0d40xh.jpg" class="lazyload"></p><h2 id="语法制导定义-SDD"><a href="#语法制导定义-SDD" class="headerlink" title="语法制导定义(SDD)"></a>语法制导定义(SDD)</h2><h3 id="综合属性和继承属性"><a href="#综合属性和继承属性" class="headerlink" title="综合属性和继承属性"></a>综合属性和继承属性</h3><h3 id="SDD的求值顺序"><a href="#SDD的求值顺序" class="headerlink" title="SDD的求值顺序"></a>SDD的求值顺序</h3><h3 id="S-属性定义与L-属性定义"><a href="#S-属性定义与L-属性定义" class="headerlink" title="S-属性定义与L-属性定义"></a>S-属性定义与L-属性定义</h3><h2 id="语法制导翻译方案"><a href="#语法制导翻译方案" class="headerlink" title="语法制导翻译方案"></a>语法制导翻译方案</h2><p>语法制导翻译方案(SDT)是在产生式右部中嵌入了程序片段(称为语义动作)的CFG。<strong>SDT可以看作是SDD的具体实施方案</strong>，本节主要关注如何使用SDT来实现两类重要的SDD， 因为在这两种情况下，SDT可在语法分析过程中实现 ：</p><ul><li>基本文法可以使用LR分析技术，且SDD是S属性的</li><li>基本文法可以使用LL分析技术，且SDD是L属性的</li></ul><h3 id="S-SDD转换为SDT"><a href="#S-SDD转换为SDT" class="headerlink" title="S-SDD转换为SDT"></a>S-SDD转换为SDT</h3><p>将一个S-SDD转换为SDT的方法：将每个语义动作 都放在产生式的最后。例如：</p><p><img alt="image-20191128104350111" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dk432vycj315q09u0zg.jpg" class="lazyload"></p><h3 id="L-SDD转换为SDT"><a href="#L-SDD转换为SDT" class="headerlink" title="L-SDD转换为SDT"></a>L-SDD转换为SDT</h3><h3 id="在非递归的预测分析过程中进行语义翻译"><a href="#在非递归的预测分析过程中进行语义翻译" class="headerlink" title="在非递归的预测分析过程中进行语义翻译"></a>在非递归的预测分析过程中进行语义翻译</h3><h3 id="在递归的预测分析过程中进行语义翻译"><a href="#在递归的预测分析过程中进行语义翻译" class="headerlink" title="在递归的预测分析过程中进行语义翻译"></a>在递归的预测分析过程中进行语义翻译</h3><h3 id="在LR分析过程中进行语义翻译"><a href="#在LR分析过程中进行语义翻译" class="headerlink" title="在LR分析过程中进行语义翻译"></a>在LR分析过程中进行语义翻译</h3><h1 id="中间代码的生成"><a href="#中间代码的生成" class="headerlink" title="中间代码的生成"></a>中间代码的生成</h1><h2 id="课件PPT-1"><a href="#课件PPT-1" class="headerlink" title="课件PPT"></a>课件PPT</h2><h3 id="中间语言"><a href="#中间语言" class="headerlink" title="中间语言"></a>中间语言</h3><p><code>?这个四元表达式之前有MOOC讲解的知识点，后期记得补上</code></p><ol><li>中间语言（复杂性界于<strong>源语言</strong>和<strong>目标语言</strong>之间） 的好处：</li></ol><p>中间代码也叫中间语言（Intermediate code /language）是：源程序的一种内部表示，不依赖目标机的结构，复杂性介于源语言和机器语言之间。</p><p><img alt="image-20191212214030712" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9u9ru5y9lj30wi05mgmm.jpg" class="lazyload"></p><ol start="2"><li>常用中间语言，重点讲了三地址代码的四元式，==给一个语句要求写出四元式==</li></ol><p><img alt="image-20191212215641717" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ua8i7xbyj30to0fwjtp.jpg" class="lazyload"></p><ol start="3"><li><blockquote><p>四元式<code>例题</code></p></blockquote></li></ol><ol start="4"><li>三地址语句的种类，<code>?有些种类的不是到怎么写四元式</code></li></ol><p><img alt="image-20191212214431636" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u9vuauclj30v80e2gnp.jpg" class="lazyload"></p><h3 id="说明语句的翻译"><a href="#说明语句的翻译" class="headerlink" title="说明语句的翻译"></a>说明语句的翻译</h3><p><code>?PPT没有内容,要掌握吗</code></p><h3 id="赋值语句的翻译"><a href="#赋值语句的翻译" class="headerlink" title="赋值语句的翻译"></a>赋值语句的翻译</h3><ol><li><p>赋值语句的基本文法</p><p>赋值语句翻译的主要任务是生成对表达式求值的<strong>三地址码</strong></p><blockquote><p>例题，根据表达式写出三地址码和四元式 -&gt;</p></blockquote><p><img alt="image-20191212215432319" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ua697mt9j30wq0emq60.jpg" class="lazyload"></p></li><li><p>赋值语句对应的语法制导翻译SDT</p><p>赋值语句翻译的主要任务是生成对表达式求值的<strong>三地址码</strong>，因此为<strong>基本文法</strong>中的非终结符S和E分别设置了<strong>综合属性code</strong>，用来表示这两个文法符号对应的三地址码，另外E还有一个综合属性addr，用来表示表达式的值的存放地址</p></li></ol><p>   几个其中函数：</p><ul><li>lookup(name)：查询符号表 返回name对应的记录；</li><li>gen(code)：生成三地址指令code；</li><li>newtemp( )：生成一个新的临时变量t， 返回t的地址addr。</li></ul><ol start="3"><li></li></ol><h3 id="布尔表达式的翻译"><a href="#布尔表达式的翻译" class="headerlink" title="布尔表达式的翻译"></a>布尔表达式的翻译</h3><h3 id="控制语句的翻译"><a href="#控制语句的翻译" class="headerlink" title="控制语句的翻译"></a>控制语句的翻译</h3><h3 id="过程调用的处理"><a href="#过程调用的处理" class="headerlink" title="过程调用的处理"></a>过程调用的处理</h3><p>dfsagg</p><h2 id="控制流语句及STD"><a href="#控制流语句及STD" class="headerlink" title="控制流语句及STD"></a>控制流语句及STD</h2><p>先分析控制流语句的代码结构，定义文法符号的属性</p><p>其中包含的继承属性为：</p><p>S.next：是一个地址，该地址中存放了紧跟在S代码之后的指令 (S的后继指令)的标号</p><p>B.true：是一个地址，该地址中 存放了当B为真时控制流转向的 指令的标号</p><p>B.false：是一个地址，该地址 中存放了当B为假时控制流转向 的指令的标号</p><p>用指令的<strong>标号</strong>标识一条三地址指令</p><p><img alt="image-20191212092405477" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9tohgoz5zj30uy0hc1ap.jpg" class="lazyload"></p><p>然后编写控制流语句的基本文法及STD</p><p>newlabel( ): 生成一个地址；</p><p>label(L): 将下一条 三地址指令的标号赋给L</p><p>1.P-&gt;S</p><p><img alt="image-20191212092630864" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9tojy0ne2j31280b8wj5.jpg" class="lazyload"></p><h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="11-07"><a href="#11-07" class="headerlink" title="11.07"></a>11.07</h2><p>1.概念：算符(要相邻)，素短语，算符优先关系</p><p>2.例题：书本P89<br>3.判断是否为算法优先文法，算符之间只能有一个关系<br>4.算符优先关系表<br>5.FIRSTVT和LASTVT，可以用来构造优先关系表<br>6.PPT41页例题和书本P91笔记<br>7.根据PPT41写出PPT44例题<br>8.PPT46的素短语和最左素短语<br>9.PPT47的规约过程<br>10.PPT51页例题<br>11.规约准确率高，算符优先法速度快</p><blockquote><p>11.14<br>一、复习<br>1.规约：找句柄<br>2.算符优先文法：找最左素短语，i直接返回为最顶端的N，有算符才能规约，否则都是占位符，一定要包含算符。速度快但有时不准确，前提是符合算符优先文法才能用。很多都不适用<br>3.另一种：LR分析法</p></blockquote><p>二、LR分析法：<br>1.从左到右扫描符号串，用最左规约，最右推导。能解决大部分语法规则，但二义文法，需要处理才能用。<br>2.LR(1)分析表，算FIRST和FELLOW，有多个候选式。而LR分析法我们用的是LR分析法，有很多能自动构造LR分析表。<br>3.课本P101例题，状态栈和符号栈，遇到s5:状态转为5，移入i，指针后移；r2：用(2)表达式进行规约右侧符号，消除此时状态，写入规约后符号，查询Goto表更新状态。栈顶的状态显示了分析的历史信息/进度。<br>4.根据有限状态自动机DFA，LR(0)item组成的集合</p><h2 id="11-28"><a href="#11-28" class="headerlink" title="11.28"></a>11.28</h2><p>一、书本125，二义文法不能用LR分析法，图5.11和表5.7的第7行，对于二义文法进行人为选择优先级以规避冲突</p><p>二、进入第六章</p><ul><li>综合属性、继承属性</li><li>终结符只有综合属性，比如digit</li><li>S-属性定义属于L-属性定义</li><li>L-属性需要综合属性时可能尚未计算结束，需要多扫描几遍才行，参考其他文件的从左到右计算</li><li>PPT第22页例题，10进制实数</li></ul><p>三、进入第7章</p><ol><li><p>语义分析和中间代码的生成</p></li><li><p>本章目录，这些翻译在参考资料里好像没有</p><p><img alt="image-20191128112512716" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dlb51a8cj31740ou426.jpg" class="lazyload"></p></li><li><p>常见的中间语言，用的比较多的是三地址代码，四元式表达</p><p><img alt="image-20191128110501843" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dkq4j6pej30xo0g4mzh.jpg" class="lazyload"></p></li><li><p>本书涉及的三地址语句类型</p><p>布尔表达式和控制流语句，两种方法，一种按部就班，一种进行优化，一真一假的话短路掉部分计算</p></li></ol><h2 id="12-05"><a href="#12-05" class="headerlink" title="12.05"></a>12.05</h2><ol><li>条件为真/假的时候，出口不一样，还要加上一个GOTO语句</li><li>如果边分析边生成的话，会比较难一遍扫描完成-》回填机制</li><li>引入ture\false\next三个属性</li></ol><p><img alt="image-20191205101010915" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lmh87o3mj314i0u0n2y.jpg" class="lazyload"></p><p>循环体也要有一个GOTO,为S增加begin属性</p><p>顺序执行，保留S.next的原因，因为S可能是条件/循环语句等，</p><p><img alt="image-20191205101347847" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lmkzxugbj318k0r0dlf.jpg" class="lazyload"></p><p>布尔表达式两种翻译方式：</p><ul><li>两遍扫描：为给定的输入串构造一棵语法树；对语法树进行深度优先遍历，进行语义规则中规定的翻译。</li><li>一遍扫描</li></ul><p>分析语法都用LR分析法</p><p>一遍扫描的困难：</p><p>如If-then-else，在这个语句中，if会有两个jump（j, ， ,跳转地址），插入GOTO语句，用M来用链条连起来，用回填语句M整个扫描完后要规约为一个<strong>S</strong>;但是扫描到if的时候还不知道入口的跳转地址，定义一个M,示例PPT36页，</p><p><strong>emit是要增加一条中间代码</strong></p><p>merge合成一个</p><p>backpatch是用于回填，先用指针指向</p><blockquote><p>老师上课重点讲了这两个的作用，为了一遍扫描生成中间码</p></blockquote><p><code>M的作用</code>：用M.quad回填E.turelist，用于记录<strong>S1和S2的入口地址</strong>，两个backpatch回填</p><p><code>N的作用</code>：对于if-then，完成之后要跳出这个条件语句,强制跳转语句</p><p><strong>M与N都是空字</strong></p><p>这个语句知道E的真和假，E的假不用执行了，真需要回填</p><p>总共三个跳转：只回填真语句的回填，N的回填，假的回填不用</p><p>把不知道的地方放到S的属性，S.nextlist=merge(),不知道的先merge到S.nextlist上去，指针附在nextlist后面，什么时候回填还不知道，需要回填的时候在进行回填</p><p>边扫描边生成代码：不知道的全部空着，然后用链条把这个放到上一级S的属性，等到知道入口在哪里再进行回填</p><p><img alt="image-20191205102810201" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lmzy016oj31860u0af7.jpg" class="lazyload"></p><p>当E1为假才去看E2，用M记录入口地址</p><p><img alt="image-20191205104225017" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnetvevpj317c0mymyy.jpg" class="lazyload"></p><p>一条中间代码都没有产生。由于不知道E1和E2的真出口，所以要用第2句把E1和E2链接到E上，AorB都是假的话需要一个假出口，那么跳出，所以E2E2的假出口也是E的假出口，这时整个AorB都是假。</p><p>merge是链表的合并</p><p><img alt="image-20191205104611691" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnipey4wj315c0cs75r.jpg" class="lazyload"></p><p><strong>AND</strong></p><p>E1的真出口是E2的入口地址</p><p>E2的真出口是E的真出口</p><p>E2、E1的假出口都是E的假出口</p><p><img alt="image-20191205105832546" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnvjd9bjj316i0bkabk.jpg" class="lazyload">NOT () </p><p><img alt="image-20191205105903510" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnw2tduqj315u0haq4h.jpg" class="lazyload"></p><p>OR AND NOT （）都没有中间代码的生成，只有涉及到id的时候才产生中间代码。</p><p>中间代码：如果满足relop.op操作，操作数满足该关系，就往这个真出口出去，为假的话就强制执行假出口；所以这里总共有2个出口。</p><p>中间代码也有需要回填，所以要把真假出口挂到E的链条上</p><p>如果回填了的话nextquad会发生改变</p><p><img alt="image-20191205110007147" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnx6yqlxj318k0logp4.jpg" class="lazyload"></p><p><code>举例</code>：E(C)的假出口需要往105回填为106，不知道怎么回填的出口还是挂到上一级。8条代码里3个地址确定，不确定的其他传到E上</p><p><img alt="image-20191205110523628" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lo2ojzlaj315u0u046o.jpg" class="lazyload"></p><p>两种方法，以上一种(画图、生成中间代码)，<code>以下方法</code>：PPT28页</p><p>优先级：先做and后做or，图中标出了两个真出口和两个假出口</p><p><img alt="image-20191205111639649" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9loeec3wsj316s0migq9.jpg" class="lazyload"></p><h3 id="控制语句的翻译-1"><a href="#控制语句的翻译-1" class="headerlink" title="控制语句的翻译"></a>控制语句的翻译</h3><p>while要跳回头部判断，S1.begin</p><p>对E的真出口进行回填，假出口要挂在S上，S.nexilist也要回填！！！</p><p><img alt="image-20191205113019738" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9losp46jkj315i0hoq5o.jpg" class="lazyload"></p><p>例题，包含了布尔、控制、赋值语句</p><p>a&lt;b的假出口为S.next，不要随意写跳到107</p><p><img alt="image-20191205113230955" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9louvzm6jj315u0t8dkw.jpg" class="lazyload"></p><h2 id="12-12"><a href="#12-12" class="headerlink" title="12.12"></a>12.12</h2><blockquote><p>控制语句的翻译</p></blockquote><p>begin不见了，用M1代替</p><p><img alt="image-20191212101929099" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9tq3294s5j30ps0fkmzj.jpg" class="lazyload"></p><p><code>[？？？？]</code></p><p>S-&gt;begin L end</p><p>S-&gt;A  【S定义为一个语句】</p><p>{S.nextList:=makelist()}</p><p>A如果是一个赋值语句，因为要用S来表示它，A要规约为S，</p><p>为了和其他while等保持一致，留一个接口，但是直接给个空就行</p><p>L-&gt;S</p><p>{L.nextlist:=S.nextlist}</p><p>向前转移和向后转移</p><p><img alt="image-20191212103511132" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9tqjek7g0j30sy0f4gnm.jpg" class="lazyload"></p><p>L已经定义为了变量而不是标号或者还没定义，报错</p><p>L:</p><p><strong><img alt="image-20191212103721251" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9tqlnwz0bj30su0jwgrb.jpg" class="lazyload"></strong></p><p><strong>case语句</strong>，也有叫做switch</p><p>两种翻译法生成语义的方法是一样的，但是第一种比较方便优化</p><p>把L都标出来，最后统一做判断</p><blockquote><p>过程调用的处理</p></blockquote><p>我们只讲转地址，不讨论传参数</p><p>过程调用的翻译子程序</p><p>？？？ 没听懂</p><p>把MOOC看了</p><blockquote><p>优化</p></blockquote><p>符号表和内存，跳过</p><p>==先讲了循环优化啥的再讲的基本块==</p><p>单一入口没有入口和goto跳转，顺序执行的</p><p>循环是优化的重点</p><p><img alt="image-20191212112633270" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ts0uvh3oj30to0ge40w.jpg" class="lazyload"></p><h2 id="12-19"><a href="#12-19" class="headerlink" title="12.19"></a>12.19</h2><h3 id="局部优化"><a href="#局部优化" class="headerlink" title="局部优化"></a>局部优化</h3><p>什么是基本块、怎么划分、</p><p><img alt="image-20191219101408869" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1t9o0t1fj30uq0cwq70.jpg" class="lazyload"></p><p><img alt="image-20191219101658878" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1tcmg1v4j30uy0hsdlo.jpg" class="lazyload"></p><p>划分基本块，<code>课堂详讲的练习，讲了2次</code></p><p><img alt="image-20191219101826384" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1te5881rj30u20lon6g.jpg" class="lazyload"></p><blockquote><p>在一个基本块内进行优化</p></blockquote><p>基本块用DAG表示</p><p>叶子结点是标识符或常数，然后添加到上级结点(附加操作符)</p><p>常见DAG：</p><p>基本块的DAG构造算法：<code>举例课本P284，看！！！</code></p><p><img alt="image-20191219103216509" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1tsiyrwsj30v20m8b29.jpg" class="lazyload"></p><p>合并已知量：如果来两个都是常数，则删除，参考步骤b，还有其他规则。。。。建议看MOOC</p><p><code>DAG图的优化</code>：</p><p><img alt="image-20191219104454583" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1udoy4h8j30xm0jiwiu.jpg" class="lazyload">)<img alt="image-20191219105123608" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1ucfbnysj30v20n80ys.jpg" class="lazyload"></p><p>最后简化为4个运算，公共变量用S代替</p><h3 id="目标代码生成——最后一章"><a href="#目标代码生成——最后一章" class="headerlink" title="目标代码生成——最后一章"></a>目标代码生成——最后一章</h3><p>四元式有一个优化，最后代码也有一个优化</p><p>==第一个操作数==</p><p>了解一个简单的代码生成器</p><p>附加在四元式的待用/活跃信息表</p><p>每一个变量是否会在后面被引用</p><p>比如第一个表：T=A-B,T在第3个被引用，A在第2个引用，B在右操作数被引用</p><p><img alt="image-20191219111824648" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1v4jb5n8j311s0s2478.jpg" class="lazyload"></p><h4 id="代码生成算法"><a href="#代码生成算法" class="headerlink" title="代码生成算法"></a>代码生成算法</h4><h1 id="作业习题"><a href="#作业习题" class="headerlink" title="作业习题"></a>作业习题</h1><p>作业，P306 3(B2)</p><h1 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h1><p>选A卷</p><p>判断题10分，</p><p>目标码</p><p>前3重中之重</p><p>做过的题一定会做</p><p>词法分析</p><p>优化放在B卷考</p><p>词法、语法、中间代码。 伪代码，目标有一点</p><p>概念性的东西</p><p>2*5，2题，每题5分 判断</p><p>3*8 选</p><p>22*3 大题</p><p>词法分析 语法分析（分析器要会） 中间码生成（子程序提供，要用过程）蓝色基本上可以忽略</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程</title>
      <link href="/2019/11/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>/2019/11/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>软工复习：<a href="https://wenku.baidu.com/view/b5dfce3303d8ce2f00662382.html" target="_blank" rel="noopener">领域模型——如何从用例图转为概念类图</a></p><p>格式说明</p><p>每章节/附录用一级标题</p><blockquote><p>用这个表示每章节的重点内容回顾和考点分析</p></blockquote><p>考点用<code>重点考题</code>标识</p><p>其他考点总结附在最后</p><p><code>考题</code>：会考用例图、[活动图不知道考不考]</p><ul><li><input disabled type="checkbox"> chapter 8</li><li><input checked disabled type="checkbox"> 附件-正规技术评审</li><li><input disabled type="checkbox"> chapter 9</li><li><input disabled type="checkbox"> 附件-领域模型和设计类图的区别</li></ul><h1 id="Ch8"><a href="#Ch8" class="headerlink" title="Ch8"></a>Ch8</h1><h2 id="PPT内容整理"><a href="#PPT内容整理" class="headerlink" title="PPT内容整理"></a>PPT内容整理</h2><p><img alt="image-20191127102108246" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cdu9088fj30pq03imyb.jpg" class="lazyload"></p><blockquote><p> Stockholders：甲方、乙方等</p></blockquote><blockquote><p>一定考：Elaboration阶段，分析建模阶段，得到一个完整的规约</p></blockquote><p>首先完善Use case图，每个Use case有acticity图、初步分析类图、可能还要有sequence图(对需要类图的哪些类以及类之间的交互)、初步状态图，明白各种图之间的关系，</p><p>画一下概念类图，学生、成绩、老师等：首先话Use case图，挑两个重要的Use case图构建初步类图和时序图</p><p>此时得到了需求规约(文字需求和用例图)和需求分析规约(功能、分析、行为建模)</p><p>评审：遗漏的、模糊的、不一致的地方，如用户名、密码数据结构描述、密码可以错几次等要清晰</p><h1 id="附件-正规技术评审"><a href="#附件-正规技术评审" class="headerlink" title="附件-正规技术评审"></a>附件-正规技术评审</h1><blockquote><p>正规技术评审(见附件)</p></blockquote><ol><li><p><code>意义(重点)</code>：质量保证的手段、是对软件开发过程中的需求规约、需求分析规约、概要设计规约、详细设计规约、代码进行评审的重要手段。</p></li><li><p><code>目的(重点重点考题)</code>：</p></li></ol><p>![image-20191127122638197](/Users/hamster/Library/Application Support/typora-user-images/image-20191127122638197.png)</p><p>具体如指针错误、代码风格、保证各阶段的输出可以成功辅助下一阶段(需求规约-&gt;需求分析规约)</p><ol start="3"><li><p><code>评审员Reviewer等角色</code></p></li><li><p><code>[?]检查要点列表（Checklist）(重点考题)</code>：**checkList内容具体有哪些，请举例：类图正确否变量调用的耦合、数组等</p></li><li><p>流程：先自己评审、汇总、召开评审会(控制评审时间两小时，过大的评审可分成子系统)、没有解决的问题在修正会继续讨论。评审会旨在<strong>阐明问题而非解决问题</strong>，适合需求规约、需求分析规约、概要设计规约、详细设计规约、代码各个阶段的评审。</p></li><li><p>评审也叫静态测试，即未运行代码的质量保证</p></li><li><p><code>[?]work through(重点考题)</code></p></li></ol><h1 id="Ch9-需求建模：基于类的方法"><a href="#Ch9-需求建模：基于类的方法" class="headerlink" title="Ch9  需求建模：基于类的方法"></a>Ch9  需求建模：基于类的方法</h1><h2 id="9-1-需求分析"><a href="#9-1-需求分析" class="headerlink" title="9.1 需求分析"></a>9.1 需求分析</h2><ul><li>基于场景的需求模型</li><li>基于对象</li><li>基于行为和模式</li></ul><blockquote><p>两种开发：面向对象、面向结构开发</p></blockquote><p>包含7个重要的阶段：</p><p>需求工程的两种工作产品：需求规约和需求分析规约，分为活动图的工程建模，类图的数据(类)建模[是设计数据库、详细类的基础]，状态图和。。行为建模</p><h1 id="附件-领域模型和设计类图的区别"><a href="#附件-领域模型和设计类图的区别" class="headerlink" title="附件-领域模型和设计类图的区别"></a>附件-领域模型和设计类图的区别</h1><p>考试一定考，自己看</p><h1 id="Ch10-需求建模：基于类的方法"><a href="#Ch10-需求建模：基于类的方法" class="headerlink" title="Ch10  需求建模：基于类的方法"></a>Ch10  需求建模：基于类的方法</h1><p>注意实际上是课本第九章！！！</p><blockquote><p>需求建模策略 Requirements Modeling Strategies</p></blockquote><ul><li>一种需求建模的视图，称<code>结构化分析</code>，将数据对象和数据对象的transform过程作为单独的实体。<ul><li>数据对象用定义其属性和相互关系的方式建模。</li><li>操作数据对象的过程是通过展示日和将数据transform为系统中的数据对象流的方式建模</li></ul></li><li>建模的第二种方法称为<code>面向对象分析</code>，专注于<ul><li>类的定义和</li><li>他们彼此通过协作的方式一起完成客户需求。</li></ul></li></ul><blockquote><p>基于类的建模 Class - Based Modeling</p></blockquote><ul><li><p>基于类的建模意味着：</p><ul><li>系统将操作的<code>objects</code></li><li><code>options</code>（也称为<code>methods</code>或<code>services</code>），将用于对象以实现manipulation</li><li>对象之间的<code>关系</code>（某些<code>hierarchical</code>）</li><li><code>collaborations</code>,发生于各个被定义的类之间。</li></ul></li><li><p>基于类的模型的元素包括类和对象，属性，操作， CRC(class-responsibility-collaborator)模型，协作图和软件包[objects,attributes,operations,CRC models,collaboration diagrams and packages.]</p></li></ul><blockquote><p>如何识别分析类 Manifestations of Analysis Classes</p></blockquote><ul><li>将检查usage scenarios使用场景的开发作为需求模型的一部分，然后执行“ 语法分析 ” (也就是说要检查之前的Use case并进行语法扫描)<ul><li>划出每个名词或名词短语并将其输入到一个简单表格中。</li><li>应注意同义词。</li><li>如果类（名词）是用于实现一个solution，那么它就是solution space的一部分；如果类（名词）是用于描述一个solution，它是problem space的一部分。</li></ul></li><li>但是我们能只扫描一遍就找出所有被隔离出来的名词吗？</li></ul><blockquote><p>分析类的表现方式 Manifestations of Analysis Classes</p></blockquote><p>类通过以下其中一种方式manifest themselves表现他们自己：</p><ul><li><code>External entities外部实体</code>（例如，其他系统，设备，人员），用于生成或使用信息</li><li><code>Things事情</code>（例如，报告，信件，信号），是问题中info domain的一部分</li><li><code>Occurrences or events事件</code>（例如财产转移或完成在以下情况下发生的一系列机器人运动）发生或发生的事件系统运作• 由以下人员扮演的角色（例如，经理，工程师，销售人员）与系统互动• 组织UNI TS（如师，团，队）是有关到一个应用程序•建立的场所（例如，生产车间或装卸场）问题的背景和整体功能•具有以下功能的结构（例如传感器，四轮车或计算机）定义对象类别或相关对象类别</li></ul><blockquote><p>潜在类 Potential Classes</p></blockquote><p>保留的信息。潜在类别在分析过程中将很有用只有必须记住有关它的信息，以便系统可以起作用。∎所需的服务。潜在类别必须具有一组可识别的可以通过某种方式更改其属性值的操作。∎多个属性。在需求分析期间，重点应放在“主要”信息；实际上，具有单个属性的类可能是在设计过程中很有用，但可能更好地表示为属性在分析活动中的另一类。∎共同属性。可以为潜在定义一组属性类，并且这些属性适用于该类的所有实例。∎常用操作。可以为潜在定义一组操作类，并且这些操作适用于该类的所有实例。∎基本要求。问题中出现的外部实体间隔并产生或消耗操作必不可少的信息系统的任何解决方案几乎都将被定义为类在需求模型中。</p><blockquote><p>定义属性 Defining Attributes</p></blockquote><p>属性描述一个已经存在的类选择要包含在分析模型中。∎ 为职业棒球建立两个不同的班级玩家们• 对于Playing Statistics软件：名称，位置，击球平均，外出百分比，出战年数和比赛玩可能是相关的• 对于养老基金软件：平均工资，信贷全面归属，选择退休金计划选项，邮寄地址等。</p><blockquote><p>定义操作 Defining Operations</p></blockquote><p>对处理进行语法分析叙述并看动词∎ 运营可分为四大类类别：∎ （1）以某种方式操纵数据的操作（例如，添加，删除，重新格式化，选择）∎ （2）执行计算的运算∎ （3）查询对象状态的操作，和∎ （4）监视对象的操作控制事件的发生。</p><blockquote><p>CRC模型   CRC Models</p></blockquote><p>类责任协作者（CRC）建模[Wir90]提供了一种简单的方法识别和组织课程与系统或产品要求有关。Ambler [Amb95]描述了CRC建模以下方式：∎ 一个CRC模型是真正的标准指标的集合代表类的卡片。卡分为分为三个部分 沿着卡的顶部，您写出班级的名字。在卡体内您在左侧列出了班级职责，右边的合作者。</p><p><img alt="image-20191204110125955" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kice7716j312g0iuq4v.jpg" class="lazyload"></p><blockquote><p>类的类型 Class Types</p></blockquote><p>实体类，也称为模型或业务类，是直接从问题陈述中提取（例如，平面图和传感器）。∎ 边界类用于创建接口（例如，交互式屏幕或打印的报告）与使用该软件时进行交互。∎ 控制器类从头到尾管理“工作单元” [UML03]完。也就是说，可以将控制器类设计为管理∎实体对象的创建或更新；∎边界对象从中获取信息时的实例化实体对象；∎对象集之间的复杂通信；∎验证对象之间或对象之间传递的数据用户和应用程序</p><blockquote><p>职责范围 Responsibilities</p></blockquote><p>系统智能应在各个班级之间分配最好地解决问题的需求∎ 每个责任应概括地表述为可能∎ 信息及其相关行为应存在在同一个班级内∎ 有关一件事的信息应本地化为单个类，而不分布在多个类中。∎ 责任应在相关类别之间分担，在适当的时候。</p><blockquote><p>类的协作 Collaborations</p></blockquote><p>班级通过以下两种方式之一履行职责：∎一个类可以使用自己的操作来操纵自己的属性，从而履行特定的责任，或者∎一个班级可以与其他班级进行协作。∎ 协作确定班级之间的关系∎ 通过确定一个班级来确定合作可以自己履行每个责任∎ 类之间的三种不同的通用关系[WIR90]：∎的是-部分-的关系∎在拥有知识-的关系∎的依赖，在关系</p><blockquote><p>复合聚合类 Composite Aggregate Class</p></blockquote><p><img alt="image-20191204110538849" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kigon5mcj31260k8wfb.jpg" class="lazyload"></p><blockquote><p>审查CRC模型 Reviewing the CRC Model</p></blockquote><p>（CRC模型的）审查中的所有参与者都获得了CRC的子集型号索引卡。∎协作的卡片应分开放置（即，审稿人不得两张合作的卡片）。∎所有用例场景（和相应的用例图）应为分为几类。∎审核负责人特意阅读用例。∎当审核负责人来到一个命名对象时，她将令牌传递给持有相应类别索引卡的人。∎令牌通过后，要求类别卡的持有者描述卡上注明的职责。∎该小组确定一个（或多个）职责是否满足用例需求。∎如果索引卡上注明的职责和合作不能为适应用例，对卡进行了修改。∎这可能包括新类的定义（以及相应的CRC索引卡）或新职责或修订职责的规范，或现有卡上的协作。</p><blockquote><p>关联与依赖关系 Associations and Dependencies</p></blockquote><ul><li>两种分析类通常与一种有关另一种时尚在UML中，这些关系称为关联∎ 可以通过指示多重性来完善关联（基数一词用于数据建模</li><li>在许多情况下，客户-服务器关系存在于两个分析类之间。<ul><li>在这种情况下，客户端类取决于服务器类以某种方式，并且依赖关系是已建立</li></ul></li></ul><blockquote><p>多重性？ Multiplicity</p></blockquote><p><img alt="image-20191204110936004" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kikrf9yaj312q0j4t9o.jpg" class="lazyload"></p><blockquote><p>依赖 Dependencies</p></blockquote><p><img alt="image-20191204111002441" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kil7rpv8j312q08et99.jpg" class="lazyload"></p><blockquote><p>分析包 Analysis Packages</p></blockquote><p>分析模型的各个要素（例如，用例，分析类）的分类方式将它们打包为一个分组∎ 每个分析类名称之前的加号包表示该类具有公共可见性因此可以从其他软件包中访问。∎ 其他符号可以位于包中的元素之前。减号表示元素对所有元素都隐藏其他包装和＃符号表示元素仅可用于包含在其中的包给定的程序包。</p><p><img alt="image-20191204111056485" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kim7npv5j312q0l2tao.jpg" class="lazyload"></p><blockquote><p>总结 Summary</p></blockquote><p>摘要∎ 基于类的建模使用源自使用的信息案例和其他书面申请说明以识别分析类。可以使用语法分析来从中提取候选类，属性和操作基于文本的叙述。类定义的标准被定义。∎ 一组类责任协作者索引卡可以是用于定义类之间的关系。此外，可以使用各种UML建模符号来定义层次结构，关系，关联，聚合和类之间的依赖关系。使用分析包以某种方式对类进行分类和分组对于大型系统，它们更易于管理</p><blockquote><p>第一次作业</p></blockquote><p>10.1 建立以下系统需求模型：适用于小型企业的简单发票系统。</p><ul><li><p>为上述系统编写一个基于模板的用例</p></li><li><p>开发在类中使用的一组操作。</p></li><li><p>在系统上开发一套完整的CRC模型索引卡</p></li></ul><p>基于类的模型的元素包括类和对象，属性，操作，类责任协作者（CRC）模型，协作图和包。</p><p>10.1识别分析类</p><p>我们可以通过检查作为需求模型的一部分开发的使用场景<strong>usage scenarios</strong>（第9章），并对要构建的系统开发的用例执行“语法分析”，从而开始识别类。</p><p>要点：</p><ul><li>检查之前的每个use case</li><li>进行语法扫描根据名词生成潜在分析类</li></ul><p>类由每个<strong>名词或名词短语</strong>确定，并将其输入到简单表中。应注意同义词。如果需要类（名词）来实现解决方案，则它是解决方案空间的一部分；否则，如果只需要一个类来描述一个解决方案，则它是问题空间的一部分。（例如，将项目添加到购物车中）</p><p>分析类以下列方式之一显示自己：</p><ul><li>External entities外部实体（例如，其他系统，设备，人员）：产生或使用要由基于计算机的系统使用的信息的。<br>问题信息领域中的内容（例如报告，显示，字母，信号）。<br>在系统操作范围内发生的事件或事件（例如，属性转移或一系列机器人运动的完成）。</li></ul><p>类图：包含了ER模型和各类的关系(继承关系、一对多)</p><p>这一张就是要构建分析类图(有具体属性，没有数据类型，注重类之间的聚合等)</p><p>类之间的协作CRC</p><p>蓝色是名词词组哦，可能是潜在的累，黑色斜体字，可能是后面要将的方法</p><p>类对应的属性和属性对应的数据</p><p>得到了潜在的类，结合六个特性，最终决定潜在类</p><p>三种class:</p><p><code>boundary class，用接口类来调用子系统来实现类之间的协作</code>,很重要</p><p><img alt="image-20191204111407396" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kiphhb0nj310q0aqai0.jpg" class="lazyload"></p><p><img alt="image-20191204111416218" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9kips9ycmj3112094qa0.jpg" class="lazyload"></p><p>类之间的<code>协作</code>,重点讲</p><ol><li><p><strong>Collaborations**</strong>：<strong><strong>Classes fulfill their responsibilities in one of two ways:</strong></strong>(1)** <strong>A class can use its own operations to manipulate its own attributes, thereby fulfilling a particular responsibility, or</strong> <strong>(2)</strong> <strong>a class can collaborate with other classes.</strong></p><p><img alt="image-20191204111518958" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9kiqtfjljj31200baajd.jpg" class="lazyload"></p></li></ol><p>三种业务之间的调用关系：is part of relationship，has knowledge of relationship,the depends-upon relationship 属于其中一部分的关系，具有知识的关系，依赖关系</p><p>定义潜在类，类的属性、操作等、类之间的关系，构建初步分析类(3种)，最后建立关联(一对多、依赖)，review，之后完成</p><p>答辩：你们有没有考虑到包或子系统的概念</p><h1 id="ch11-需求建模：行为、模式和网络-移动应用"><a href="#ch11-需求建模：行为、模式和网络-移动应用" class="headerlink" title="ch11 需求建模：行为、模式和网络/移动应用"></a>ch11 需求建模：行为、模式和网络/移动应用</h1><blockquote><p>生成行为建模</p></blockquote><p>行为模型表明软件将如何响应外部事件或刺激。要创建模型，分析人员必须执行以下步骤：</p><ul><li>评估所有用例，以充分了解操作顺序系统内的交互。</li><li>确定驱动交互sequence的事件，并了解这些事件与特定对象之间的关系。</li><li>为每个用例创建一个sequence。</li><li>构建系统的状态图。</li><li>审查行为模型以验证准确性和一致性</li></ul><p><img alt="image-20191206102729596" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mslk85maj315i04mjuv.jpg" class="lazyload"></p><p><img alt="image-20191206102642036" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mskzs5agj30xu07otee.jpg" class="lazyload"></p><blockquote><p>系统的状态</p></blockquote><p>状态：</p><p>状态控制：</p><p>事件</p><p>动作：</p><blockquote><p>状态表示</p></blockquote><blockquote><p>行为建模</p></blockquote><p>列出系统的不同状态（系统如何运行？）</p><ul><li>指示系统如何进行过渡从一个状态到另一个状态（系统更改状态？）<ul><li>指示event</li><li>指示action</li></ul></li><li>绘制状态图或顺序图</li></ul><blockquote><p>控制面板类的状态图</p></blockquote><p>下面这个图一定考：类似于BPMN</p><p><code>考题</code>:选择一两个业务类，划出状态图，并定义属性或方法，3分左右的应用题</p><p><img alt="image-20191206104233918" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mt1bg7jaj319a04eadi.jpg" class="lazyload"></p><p><img alt="image-20191206104259510" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mt1sckghj31880my45z.jpg" class="lazyload"></p><blockquote><p>控制面板类的顺序图</p></blockquote><p>这是一个use case对应的激活系统的状态图，输入密码&lt;=6次继续，正确则开，错误则锁定，启动某些传感器。</p><p><img alt="image-20191206104544226" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mt4kh2voj31980pwtln.jpg" class="lazyload"></p><p><img alt="image-20191206104357338" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mt2ormhwj319q0ncwmw.jpg" class="lazyload"></p><p><code>考题</code>：sequece图也是行为建模的一部分，完成某个功能需要哪些类、use case进行交互.有一些边界类体现接口就行。完成use case需要哪些类相互调用才能完成，活动图是展示流程，功能逻辑的抽象，顺序图是具体哪些类进行交互，类的交互</p><blockquote><p>编写软件specification</p></blockquote><blockquote><p>需求建模的Patterns</p></blockquote><p><code>考题</code>行为建模的对象：用例，根据状态图确立方法，状态图有两种一种是基于系统的状态图、一种是基于类的状态图</p><p>需求建模的模式：输入的依旧是用例</p><blockquote><p>…</p></blockquote><blockquote><p>WebApps的需求建模</p></blockquote><p><img alt="image-20191206111207620" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mtvzq3zvj30n80d8wik.jpg" class="lazyload"></p><blockquote><p>内容建模</p></blockquote><p> 内容对象是从用例中提取的∎ 检查场景描述中的直接和间接引用内容∎ 识别每个内容对象的属性∎ 内容对象之间的关系和/或内容维护的层次结构网络应用∎ 关系—实体关系图或UML∎ 层次结构-数据树或UML</p><blockquote><p>Data Tree</p></blockquote><p><img alt="image-20191206111414219" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mty88eckj30mc0cg3zv.jpg" class="lazyload"></p><p>注意<code>输入和输出</code>,</p><p>输出：5种类型的模型，看杜庆峰PPT，书本什么的没有</p><ul><li><p>内容建模，明确内容对象(文本、图像、图片、多媒体)，建模时很多内容对象是树状嵌套的关系，例如智能门铃其中一个控件的建模，复杂的需要用data tree来体现层次</p><p><img alt="image-20191206111105517" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mtuxqnabj30lg0fetag.jpg" class="lazyload"></p></li><li><p>交互建模</p></li><li><p>功能建模</p></li><li><p>导航建模</p></li><li><p>配置建模[5个]</p></li></ul><p><code>用微服务的配置建模</code>：主机、虚拟机、容齐、微服务的配置需要用配置文档或者UML的配置图，<code>微服务的配置要求画出来配置建模</code></p><blockquote><p>交互建模</p></blockquote><ul><li>由四个元素组成：<ul><li>==用例==</li><li>==顺序图==</li><li>==状态图==</li><li>==用户界面原型==：找到内容对象，通过交互来完成功能。首先借助顺序图的生命线来确定有几个界面和界面层划分，然后将50个业务的分层次，哪些放在第一层、第二层…的界面，再交给产品经理来设计原型，最后再review。</li></ul></li><li>每个都是重要的UML notation</li></ul><blockquote><p>Sequence Diagram</p></blockquote><p><img alt="image-20191206111617541" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mu0bh04tj30m60cogn6.jpg" class="lazyload"></p><blockquote><p>State Diagram</p></blockquote><p><img alt="image-20191206111650034" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mu0w6dwdj30mk0duwh4.jpg" class="lazyload"></p><blockquote><p>功能建模</p></blockquote><ul><li>功能模型涉及两个WebApp的处理元素<ul><li>==用户可观察的功能==通过WebApp交付给用户端</li><li>==分析类中包含的操作==用于实现与类相关的行为。</li></ul></li><li><code>活动图</code>可以被用来表示处理流程</li></ul><p>很多交互需要调用后台很多类的方法</p><p><code>考题</code>现在很多原型设计跑到需求建模前面去了，产品经理</p><blockquote><p>配置建模</p></blockquote><p><img alt="image-20191206112341252" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mu82am3lj30ts0i21dh.jpg" class="lazyload"></p><blockquote><p>导航建模</p></blockquote><p>除了基本功能的导航建模之外，最好还要有使用手册和浏览指南，导览图</p><p><img alt="image-20191206112540405" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mua2fhhgj30ve05k0tr.jpg" class="lazyload"></p><p><code>考题</code></p><p>如果是移动app，描述一下你的内容建模、交互建模、导航建模、配置建模，基于题干，举一两个功能来进行描述，详细描述一下</p><p>10.2 识别用例事件</p><p>event和状态相关联，</p><p>下面这个图一定考：类似于BPMN</p><h1 id="复习需求建模"><a href="#复习需求建模" class="headerlink" title="复习需求建模"></a>复习需求建模</h1><p><strong>需求建模的7个步骤</strong>:[少了第一个]项目驱动、建模、negotiation、两个规约、评审validation看需求是否一致和省略模糊处、management敏捷开发对需求变更进行管理</p><p>主要的模型：</p><ul><li><p>需求规约(文字，功能和非功能特性)和</p></li><li><p>需求分析规约</p><ul><li>数据建模的分析类图ch11[还没有界面类，没有边界类，没有控制类，主要是实体类，聚合关联等3个关系]</li><li>行为建模的状态图[两个层次，事件驱动需要系统级别的状态图，main类，面向对象开发每个实体类的<strong>状态图</strong>，是封装后进行协作的基础，<strong>时序图</strong>表示哪些类相互交互]、</li><li>功能建模的活动图[用活动图描述方法、类、系统])</li></ul></li></ul><h1 id="ch12-Design-Concepts"><a href="#ch12-Design-Concepts" class="headerlink" title="ch12 Design Concepts"></a>ch12 Design Concepts</h1><blockquote><p>软件设计</p></blockquote><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p><code>分为系统架构和数据结构(包括数据库、设计类图[主要是后端业务类之间的调用关系])、接口和组件</code></p><ul><li><p>==设计类图==，可以包含<strong>实体类、界面类、控制类、边界类</strong>，而需求分析建模的==分析类图==不需要这个</p></li><li><p><code>考题</code>：数据库设计包含数据库设计和数据结构设计，数据库设计以实体类为基础进行，数据结构设计每个方法的接口设计(连接到用户接口、前端界面接口、内部类之间的接口、系统外部的接口，外部接口可能是其他系统的也可能是硬件的)</p></li></ul><p>软件设计输入：需求规约和需求分析规约</p><p>下面这张图<code>考题</code>：</p><p><img alt="image-20191211102730943" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9skpcityij310e0juti3.jpg" class="lazyload">分析包：界面包等把一些东西类似的类放在一个包里，功能相同的类放在一个子系统，不同子系统通过接口访问，叫做packet</p><p>CRC：类之间协作的抽象一下，类的方法</p><p>以需求工程为基础进行设计，最底层是<strong>数据/类的设计</strong></p><p>数据库设计以类图为依据，冗余</p><p>设计类图以分析类图为基础，</p><ul><li>B/S<strong>架构</strong>，前端浏览器，后端服务器，后端主要是类之间的架构，状态图和时序图</li></ul><p><strong>接口</strong>：内部、外部等接口都用时序图</p><p>组件：调用时许图</p><p>书本对上面那张图的讲解</p><p><img alt="image-20191211104104159" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sl3c9fo5j30nu0f0thq.jpg" class="lazyload"></p><blockquote><p>Design and Quality</p></blockquote><p><strong>知道良好设计的三个思想</strong></p><ul><li>必须以需求工程为基础</li><li>可读性、可理解，尤其是需求规约</li><li>从整体上易于理解，提供完整的俯瞰图</li></ul><p><img alt="image-20191211104348421" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sl667y74j30nm08mae1.jpg" class="lazyload"></p><blockquote><p>Quality Guidelines</p></blockquote><p><strong>质量指导原则：</strong></p><p>体系结构</p><p>组件化和功能的独立性</p><p>接口的调用，形参和实参的数据结构，全局变量和局部变量</p><p>解偶和复用</p><p>用UML描述</p><p><img alt="image-20191211104555669" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sl8by4v4j30v00h0gvy.jpg" class="lazyload"></p><blockquote><p>Quality Attributes</p></blockquote><p>在设计中进行把握</p><p><img alt="image-20191211105929744" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9slmkb6wlj30us0hmqdy.jpg" class="lazyload"></p><blockquote><p>软件设计的演化</p></blockquote><blockquote><p>设计概念</p></blockquote><p><img alt="image-20191211110233165" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9slpo773bj30qc0gsgqe.jpg" class="lazyload"></p><p>抽象：数据、过程】控制</p><p>架构：系统架构和内部的架构(界面类、接口类、实体类)，任何系统都有这两种架构，很重要</p><p>模式：已成功的经验模版</p><p>关注点分离：分而治之，类的分解等，结果：模块化、某一方面的、功能独立、细化</p><p>模块化：怎么做</p><p>如图： 集成的成本增加</p><p><img alt="image-20191211111106035" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9slygyzi5j30uk0bgdnb.jpg" class="lazyload"></p><p>信息隐藏：</p><p>功能独立：低耦合高内聚</p><p>细化：自上而下的设计策略。抽象和细化是互补的概念</p><p>方面：子系统之间通过接口进行访问，也是模块化似的</p><p>重构：优化、标准化我们的类、编程规则等，通过不改变代码的外部行为改进其内部结构</p><p>设计类图：最主要的是界面类、业务类实体类(主要来自分析类图)、控制类</p><p><img alt="image-20191211111810519" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sm5yzwhqj30su08gwkz.jpg" class="lazyload"></p><p> <strong>类设计后要评审：</strong></p><p>是不是完整的，能否得到完整信息</p><p>原创性，不能重复出现类，功能一样等</p><p>高内聚和低耦合</p><p><img alt="image-20191211111842161" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sm6f2ku7j30u60j0qgt.jpg" class="lazyload"></p><blockquote><p>依赖倒置 </p></blockquote><p>附件：loC模式（依赖、依赖倒置、依赖注入、控制反转）-12.3.13节</p><p>一定要好好看</p><p>分析细一点，设计就比较快</p><p>这张图主要是说分析模型和设计模型有时很难分开</p><p><img alt="image-20191211112436128" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9smcjjuc1j30u40i2tet.jpg" class="lazyload"></p><blockquote><p>数据设计元素</p></blockquote><blockquote><p>体系结构设计元素</p></blockquote><blockquote><p>接口设计元素</p></blockquote><p><img alt="image-20191211112743866" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9smfsafsnj30oa04a76s.jpg" class="lazyload"></p><p>控制面板的接口表示，控制面板不是实体类，但还是给它定义成一个用户接口类。</p><p><strong>分析类图里没有，设计类图才有控制面板类</strong>，用户接口类</p><p><img alt="image-20191211112830319" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9smglnxzhj30t80fwgpu.jpg" class="lazyload"></p><blockquote><p>组件级别的设计元素</p></blockquote><p>组件设计的时候要划出相关类，除了内部类的状态图、时许图等不要忘了类之间的协作，<strong>所有相关的类和方法都要画出来</strong></p><p><img alt="image-20191211113028392" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9smimv88mj30xc0hiwhr.jpg" class="lazyload"></p><p>用组件图展示边缘的关系、包含关系，参考一下，最重要的是</p><p><img alt="image-20191211113241526" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9smky89laj30tk0asgsj.jpg" class="lazyload"></p><blockquote><p>部署级的设计元素</p></blockquote><p><code>微服务</code>：要抽象出配置图</p><p>除了系统架构还要有配置图，一定要注意⚠️</p><p><img alt="image-20191211113324171" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9smlopsnmj30u20eigr7.jpg" class="lazyload"></p><h1 id="ch13-架构设计"><a href="#ch13-架构设计" class="headerlink" title="ch13 架构设计"></a>ch13 架构设计</h1><p>架构设计=high level</p><p>上下：父系统(比如安保系统可能是整个智能家居的子系统之一)、附属子系统、依赖子系统(如校验保安系统的安检器、依赖其他系统的数据)，都有接口</p><p>用户接口、平级的系统(互相之间都有数据交互)</p><p><code>重点考题</code></p><p><img alt="image-20191218101955703" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0ntfrz9vj30vc0jgds4.jpg" class="lazyload"></p><p>所以说架构设计：需要三大部分、各部分内部接口、与<code>外部系统的接口</code>，这个可能还有父系统</p><p>要用到很多中间件，</p><p>参考MCV，数据库相当于底层的一层，看作一个独立的组件/特殊的“类”</p><blockquote><p>什么是体系结构以及为何用</p></blockquote><p>![image-20191218102217541](<a href="https://tva1.sinaimg.cn/large/006tNbRwly1ga0nvwsty4j30p608s43g.jpg" target="_blank" rel="noopener">https://tva1.sinaimg.cn/large/006tNbRwly1ga0nvwsty4j30p608s43g.jpg</a></p><blockquote><p>体系结构为何重要</p></blockquote><p><img alt="image-20191218102431720" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0ny5wxibj30pe0e8gsl.jpg" class="lazyload"></p><blockquote><p>体系结构的描述</p></blockquote><p><img alt="image-20191218102642517" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0o0f5m2dj30rs0fmq8n.jpg" class="lazyload"></p><blockquote><p>体系结构决策</p></blockquote><p><img alt="image-20191218102741816" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0o1g8lk2j30so0e8jv4.jpg" class="lazyload"></p><p>到底选的哪一种模版，用来评审方便的，填完后再去写详细设计文档</p><p><img alt="image-20191218102832380" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0o2bwcfzj30ra0iugxb.jpg" class="lazyload"></p><blockquote><p>体系结构类型</p></blockquote><p>(业务不同)</p><blockquote><p>体系结构风格</p></blockquote><p>1.以数据为中心的软件体系架构(比如github，只有数据的拿和放)</p><p><img alt="image-20191218103209800" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0o639hudj30es09a76w.jpg" class="lazyload"></p><p>2.数据流体系结构(银行系统)</p><p><img alt="image-20191218103259220" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0o6y8nfcj30sm07mmzc.jpg" class="lazyload"></p><p>举例银行：</p><ul><li><p>数据流风格：批处理子系统(晚上不交易、各种汇总分析数据后产生报表在第二天之前生成，前面模块的数据输出作为后面模块的输入)、从移动端查看余额(分层)</p></li><li><p>交易，贷款、存储款</p></li></ul><p>3.调用和返回体系结构(比如c语言写的发工资，找模块、汇总、返回、是否有新员工、调模块开户)</p><p><img alt="image-20191218103915457" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0odhihevj30t4098adf.jpg" class="lazyload"></p><p>4.面向对象架构</p><p>后端各个类之间的调用关系</p><p>5.层次体系架构(如MVC，是前面几种结构的复合体，模块内部可以是面向对象结构等)</p><p><img alt="image-20191218104259367" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0ohdkn28j30uo0cq48s.jpg" class="lazyload"></p><blockquote><p>体系结构模式</p></blockquote><p><img alt="image-20191218104348651" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0oi92da0j30si0h6dkv.jpg" class="lazyload"></p><blockquote><p>组织和细化</p></blockquote><p><img alt="image-20191218104706047" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0olq4exij30uy0bmgqq.jpg" class="lazyload"></p><p>精细、类之间调用、模块设计都要精华，类的设计，分而治之，高内聚低耦合、可扩展性、事件驱动型的话不断进行调用处理</p><blockquote><p>体系结构考虑要素</p></blockquote><p><img alt="image-20191218104538826" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0okpildsj30u00v3dkw.jpg" class="lazyload"></p><blockquote><p>体系结构设计</p></blockquote><p><img alt="image-20191218105430461" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0otch8g5j30hc010aag.jpg" class="lazyload"></p><p>1.系统环境的表示</p><p><img alt="image-20191218105557510" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0ouvp7nlj30v20ieqed.jpg" class="lazyload"></p><p>举例：家庭保安系统，里面有各种接口，<code>概要设计第一步</code></p><p><img alt="image-20191218105652600" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0ovt6faoj30us0e4qdd.jpg" class="lazyload"></p><p>2.定义原型Archtype，包括类等基本元素，哪些能成为元素呢？业务分析类、外部设备、外部事件、控制类、接口类、服务类、传感器balabala</p><p><img alt="image-20191218110107365" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0p0bwrf7j30u60u0dvu.jpg" class="lazyload"></p><p>3.体系结构细化为构件</p><p>根据分析类能否设计成一个类、要不要子系统、界面类，<code>确定类和类的调用</code></p><p>当设计完<code>架构系统图后</code>，对架构内部进行概要设计，设计层次设计MVC -&gt; 以<code>需求规约的分析类</code>为基础设计类和调用（要对分析类可能增加或合并，访问数据库的类）</p><ul><li><p>需求分析类</p></li><li><p>通讯中间类</p></li><li><p>内存管理</p></li><li><p>组件管理</p></li><li><p>功能管理</p></li><li><p>数据库类(数据库看作一个组件，写成数据类)</p></li></ul><blockquote><p>WebApp与移动App</p></blockquote><p>移动App：能够轻移动端(不保存数据)、重移动端；最大特点：对硬件设备的操作</p><p>WebApp：</p><blockquote><p>体系结构评审</p></blockquote><p><img alt="image-20191218111858704" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0piwf233j30vk0awth2.jpg" class="lazyload"></p><p>架构师：主要考虑非功能性</p><p>项目经理：交互成本</p><p>高级工程师：需求</p><p>普通工程师：技术</p><blockquote><p>基于模式的体系结构评审</p></blockquote><p>不是很正式，了解就行(随便看看)</p><blockquote><p>体系结构的一致性检查</p></blockquote><blockquote><p>补充</p></blockquote><p>第一次设计就要考虑到架构</p><p>系统内部的集成架构(比如师Web还是移动，各种中间件)</p><p>不断放子功能进来的时候要不断评估</p><p>这两章</p><p>目标系统的外部接口</p><ul><li>体系结构设计(外部接口、3个层次、模块内部)</li><li>接口设计(父系统、平级系统、依赖系统、用户系统的各种接口)</li><li>数据库设计(接口很重要，访问的方法归类，形成各种接口，)</li><li>后端一定要有子系统(功能相近的类)，子系统之间的接口，定义访问数据库的类，每个子系统都要定义一个<code>内部接口类</code>，用来访问其他子系统、数据库等+<strong>被</strong>前端和其他子系统访问</li></ul><h1 id="ch14-详细设计"><a href="#ch14-详细设计" class="headerlink" title="ch14 详细设计"></a>ch14 详细设计</h1><p>组件设计</p><p>组件的数据结构、算法、接口、通信机制</p><p>通信机制：何时调用接口，如有一个专门轮询每10s读取传感器数据的类，达到某一浓度则调用其他方法报警，这就是一个通信机制</p><blockquote><p>什么是组件</p></blockquote><ol><li><p>面向对象的观点</p><p>不仅包含自己这个组件，还要考虑其他设计类相互通信等，这才是一个完整的组件设计。<code>注意考点，何时调用的机制设计，即接口设计</code></p><p><img alt="image-20191220101232494" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga2yucjuqnj316c07qjyj.jpg" class="lazyload"></p><p>需求工程中的分析类图，只是简单定义了属性和方法，要进行细化</p><p>两个接口。并且把方法拓展开，属性也拓展了很多</p><p><img alt="image-20191220101542386" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga2yxlg1pej30os0ps7e9.jpg" class="lazyload"></p></li><li><p>传统的观点</p><p>很多非叶节点不干实事，基本都推给叶节点</p><p><img alt="image-20191220102235391" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga2z4rdv2rj30qe0ciq6n.jpg" class="lazyload"></p><p>里面方法要先用一个方法，方法再调用其他方法</p><p><img alt="image-20191220102600214" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga2z8c47v5j30r40fsn4g.jpg" class="lazyload"></p></li><li><p>基于过程的观点(没讲)</p></li></ol><blockquote><p>设计基于类的组件</p></blockquote><ol><li><p>基本设计原则</p><ul><li>开闭原则。如果传感器不写成一个sensor接口类，每加一个传感器其他调用传感器的类都要改动，复用性很差。<code>重点考题</code>遵循OCP原则</li></ul><p><img alt="image-20191220102924578" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga2zbuprnpj30q808876u.jpg" class="lazyload"></p><ul><li><p>Liskov替换原则==(参见附件文档)==——DSP</p></li><li><p>依赖倒置原则==(参见附件文档)==——DIP</p></li><li><p>接口分离原则——ISP<code>重点考题</code></p><p>比如，安全功能和监控功能。安全功能调后台时设计一个接口中间管理，然后这个接口再去调a(),b(),c()；然后第二个监控功能调后台的a(),b(),c()时，要再写一个接口中间管理，不能通过同一个接口，即使两个功能都是调用同样的方法，还是要通过不同的中间接口进行管理！概要设计里就要提到，然后详细设计细化。比如数据库通用接口…等</p><p><img alt="image-20191220103628468" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga2zj7fsezj30rc04cq5w.jpg" class="lazyload"></p></li><li><p>发布复用等价性原则(REP)</p></li><li><p>共同封装原则(CCP)</p><p>后台要把功能类似或相关的类划分成子系统</p></li><li><p>共同复用原则</p></li></ul></li><li><p>组件设计指导方针</p><ul><li>组件</li><li>接口</li><li>依赖与集成</li></ul></li><li><p>内聚性</p><ul><li>功能内聚</li><li>分层内聚：包、组件、类</li><li>通信内聚：接口通信</li></ul></li><li><p>耦合性</p><p><img alt="image-20191220105921989" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga3070itc9j30ts08stf1.jpg" class="lazyload"></p><p>内容耦合、控制耦合(某个超标则触发调用另一个方法)、外部耦合</p><p><img alt="image-20191220110128083" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga3097jf0ej30tu04agoj.jpg" class="lazyload"></p></li><li><p>实施组件级步骤</p><p>步骤3细化分点，<code>必考考点</code>，每个步骤在干什么都要知道，老师讲完又理了一遍 </p><p><img alt="image-20191220110337791" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga30bgti7dj30na0bw0vx.jpg" class="lazyload"></p><p><img alt="image-20191220110643427" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga30eod3f2j30nc0c4787.jpg" class="lazyload"></p><p>第5步，互相检验</p><p>比如有一堆订单方法，在下单过程中，有一个取消订单的出口，计算总额的时候，状态图就是定义方法的方式。</p><p><img alt="image-20191220110925963" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga30hi0o0wj30wa0m610h.jpg" class="lazyload"></p><p>第7步：检查和优化</p></li><li><p>Web的组件级设计</p><p>把内容对象看作组件</p><p>把功能看作组件</p><p>业务逻辑从前端到后端各种调用都很清晰，内容和数据等交互都能够实现</p></li><li></li><li></li><li></li></ol><h1 id="晚课笔记"><a href="#晚课笔记" class="headerlink" title="晚课笔记"></a>晚课笔记</h1><h2 id="11-23"><a href="#11-23" class="headerlink" title="11.23"></a>11.23</h2><ol><li><p>用例图中划分子系统</p><p><code>(重点考题)</code>子系统1与子系统中2中的方法相互调用与返回，过多方法间的访问，维护成本大，所以更改为：在子系统1和子系统中2各定义一个接口类，两个子系统之间的方法互相通过接口进行访问。如果项目使用了这个则加分。</p></li><li><p>架构是在<strong>概要设计</strong>中进行设计。</p></li><li><p>工具：spring cloud contract</p></li></ol><h1 id="Exexcise"><a href="#Exexcise" class="headerlink" title="Exexcise"></a>Exexcise</h1><blockquote><p>一、web 1.0 至 web 4.0 发展历程</p></blockquote><p><a href="https://www.teambition.com/project/5cc325db29ef4c0019136fe3/works/5cc325db29ef4c0019136fe6/work/5dcbcf7ab951ed0018e4e2bc" target="_blank" rel="noopener">参考资料：Web4.0时代的创新探究</a></p><ul><li><p>Web 1.0：信息共享</p></li><li><p>Web 2.0：信息共建</p></li><li><p>Web 3.0：知识传承</p></li><li><p>Web 4.0：知识分配</p></li></ul><h4 id="web-4-0-与其他-web-对比"><a href="#web-4-0-与其他-web-对比" class="headerlink" title="web 4.0 与其他 web 对比"></a>web 4.0 与其他 web 对比</h4><p><img alt data-src="https://wx3.sinaimg.cn/mw690/007CtYmwly1g8wk3dbs4vj30xc0s010h.jpg" class="lazyload"></p><h4 id="web-4-0-发展历程"><a href="#web-4-0-发展历程" class="headerlink" title="web 4.0 发展历程"></a>web 4.0 发展历程</h4><p><img alt data-src="https://wx4.sinaimg.cn/mw690/007CtYmwly1g8wk62tjwwj30ws0bmq6m.jpg" class="lazyload"></p><blockquote><p>二、云平台架构</p></blockquote><h4 id="对比于传统的服务器"><a href="#对比于传统的服务器" class="headerlink" title="对比于传统的服务器"></a>对比于传统的服务器</h4><ul><li>云平台可以将物理资源虚拟化为<strong>虚拟机资源池</strong>，灵活调用软硬件资源，实现对用户的按需访问。</li><li>在运行过程中根据用户并发量不同，<strong>实时迁移虚拟机资源</strong>，一方面保证提供高质量服务，另一方面最小化资源成本，提高CPU、内存等利用率。</li><li>4层架构，从底层到上层分别是资源层、虚拟层、中间件层、应用层。</li></ul><h4 id="资源层或基础设施层（IaaS）"><a href="#资源层或基础设施层（IaaS）" class="headerlink" title="资源层或基础设施层（IaaS）"></a>资源层或基础设施层（IaaS）</h4><ul><li><p>由<strong>服务器集群</strong>组成。传统服务器要想提供高质量服务，需要性能特别好的服务器（内存高，CPU快，磁盘空间大等），价格昂贵。而服务器集群可以使用以前性能不太好的服务器，利用<strong>分布式处理技术</strong>，依然可以提供可靠服务，节省费用。</p></li><li><p>有了物理机集群后，我们需要在物理机上建立虚拟机。建立虚拟机的目的是为了最小化资源成本（最大化资源利用率）。试想一下某台物理机有64G内存，当某段时间连续有小任务量的应用需要处理时，物理机的内存利用率会很低，所以为最大化资源利用率，可以在物理机上独立开辟几个虚拟机，每台虚拟机相当于一个小型服务器，依然可以处理应用请求。我们采用KVM（Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，同样还有XEN和OVM）来给每一台虚拟机分配适量的内存、CPU、网络带宽和磁盘，形成虚拟机池。</p></li></ul><h4 id="中间件层或平台层（PaaS）"><a href="#中间件层或平台层（PaaS）" class="headerlink" title="中间件层或平台层（PaaS）"></a>中间件层或平台层（PaaS）</h4><ul><li><strong>云平台的核心层</strong>，主要功能为：对虚拟机池资源状态进行监测、预警、优化决策。</li><li>①资源监测：实时监测当前各台虚拟机CPU、内存等使用情况，当然也监测用户应用请求，以便根据应用规模大小进行决策。</li><li>②预警：防患于未然，根据当前虚拟机资源使用情况预测下一秒用户请求量，以便做出相应资源调整，防止宕机。比如CPU使用率上限为70%，所以当预测下一秒达到该触发点时，应有相应响应。当然，触发阈值应该有更科学的设定。</li><li>③优化决策：预警之后，虚拟机要进行资源调度(迁移或伸缩)，采用何种调度策略，才能保证服务和资源利用率是研究重点。由于该层需要对应用进行响应处理，所以需要在虚拟机上搭建操作系统，文件存储系统，以及服务器，当然还有负载均衡系统，如，Nginx，其实现中间件层功能，相当于网络中的路由器不处理数据，只进行数据转发，数据处理交有虚拟机上的tomcat服务器执行。（也相当于hadoop中的Namenode，其他虚拟机相当于datanode）。</li></ul><h4 id="应用层或软件服务层（SaaS）"><a href="#应用层或软件服务层（SaaS）" class="headerlink" title="应用层或软件服务层（SaaS）"></a>应用层或软件服务层（SaaS）</h4><ul><li>给用户提供可视化界面，应用若为存储：比如百度云会给用户提供交互界面，建立文件夹，进行数据存储，在线播放视频等界面，供用户选择操作。应用若为租用服务器：界面应该有租用的服务器资源状态。</li><li>另外，该平台是面向服务的体系架构(SOA)，给用户的应用提供的是服务。这里面有个概念为组件服务。组件是已经编译好，并且可以使用的二进制代码，组件之间的组合可以组成一个应用程序。比如用户的应用为在线播放视频，那么云平台提供的组件应有在线播放组件及相关联组件，给用户提供的服务就是在线播放视频。而不同的组件组合，需要不同大小的虚拟机资源，所以为使资源利用率最大，需要合理进行组合。</li></ul><h4 id="通用的官方表述"><a href="#通用的官方表述" class="headerlink" title="通用的官方表述"></a>通用的官方表述</h4><ul><li><p>一般来说，目前大家比较公认的云架构是划分为基础设施层、平台层和软件服务层三个层次的。对应名称为IaaS，PaaS和SaaS。如下图所示。<br><img alt="IMG_256" data-src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=bc9d96f0a00f4bfb98dd960662261395/f9198618367adab47472e22c8fd4b31c8701e43b.jpg" class="lazyload">  </p></li><li><p>IaaS, Infrastructure as a Service，IaaS主要包括计算机服务器、通信设备、存储设备等，能够按需向用户提供的计算能力、存储能力或网络能力等IT基础设施类服务，也就是能在基础设施层面提供的服务。今天IaaS能够得到成熟应用的核心在于虚拟化技术，通过虚拟化技术可以将形形色色计算设备统一虚拟化为虚拟资源池中的计算资源，将存储设备统一虚拟化为虚拟资源池中的存储资源，将网络设备统一虚拟化为虚拟资源池中的网络资源。当用户订购这些资源时，数据中心管理者直接将订购的份额打包提供给用户，从而实现了IaaS。</p></li><li><p>PaaS, Platform as a Service，中文名为平台即服务。如果以传统计算机架构中“硬件+操作系统/开发工具+应用软件”的观点来看待，那么云计算的平台层应该提供类似操作系统和开发工具的功能。实际上也的确如此，PaaS定位于通过互联网为用户提供一整套开发、运行和运营应用软件的支撑平台。就像在个人计算机软件开发模式下，程序员可能会在一台装有Windows或Linux操作系统的计算机上使用开发工具开发并部署应用软件一样。微软公司的Windows Azure和谷歌公司的GAE，可以算是目前PaaS平台中最为知名的两个产品了。</p></li><li><p>SaaS，软件即服务。简单地说，就是一种通过互联网提供软件服务的软件应用模式。在这种模式下，用户不需要再花费大量投资用于硬件、软件和开发团队的建设，只需要支付一定的租赁费用，就可以通过互联网享受到相应的服务，而且整个系统的维护也由厂商负责。</p></li></ul><blockquote><p>三、过程管理工具</p></blockquote><p>Teambition：<a href="https://www.teambition.com/" target="_blank" rel="noopener">Teambition官方网站</a></p><blockquote><p>(4) find a project that developed by XP or Scrum, and discuss it.</p></blockquote><p>在国外硅谷等地，敏捷式开发也早已经被Google、Facebook、LinkedIn等企业应用。</p><h1 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h1><ol><li>除了基本功能的导航建模之外，最好还要有使用手册和浏览指南，导览图</li><li><code>用微服务的配置建模</code>：主机、虚拟机、容齐、微服务的配置需要用配置文档或者UML的配置图，<code>微服务的配置要求画出来配置建模</code></li><li>需求规约、高层架构、后台调用关系图、微服务的部署图、数据库设计、接口设计，一定要加到项目里</li><li><code>概要设计第一步</code>:</li></ol><p><img alt="image-20191218105827635" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0oxgnrgaj30g00b041s.jpg" class="lazyload"></p><p><img alt="image-20191218105846267" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0oxs62fqj30fm08eju6.jpg" class="lazyload"></p><ol start="5"><li><p>抽象原型设计</p><p><img alt="image-20191218110325453" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga0p2mb0r8j30960dktat.jpg" class="lazyload"></p></li><li><p>将体系结构细化为组件</p></li><li><p>概要设计思路：当设计完<code>架构系统图后</code>，对架构内部进行概要设计，设计<code>层次设计MVC</code> -&gt; 以<code>需求规约的分析类</code>为基础设计各个 层次的类和调用（要对分析类可能增加或合并，访问数据库的类）</p></li><li><p>最后一题：用例设计、类的设计、各种设计，复习的时候多看ch13的笔记，是他讲过的例子</p></li><li><p>PPT：项目背景、需求工程、概要设计、详细设计、开发过程和工具、亮点</p></li><li><p>性能需求，基于…开发环境</p></li></ol><h1 id="考试复习"><a href="#考试复习" class="headerlink" title="考试复习"></a>考试复习</h1><p>看书没什么用，还是多做题目吧</p><p>考试有状态图。</p><p><code>以前都做不完，要抓紧时间写！</code></p><p>题型：</p><ul><li><p>第一大题：选择题 9小题，全是多选题，基本上都是书上的概念和内容，错了扣分</p></li><li><p>2-5大题：看图举例，简答分析 </p><ul><li>2.看图分析举例解释</li><li>3.分析举例解释，不看图</li><li>4.看图分析举例解释</li><li>5.分析举例解释，不看图</li></ul></li><li><p>最后一道综合题：5个小题，32分，</p></li></ul><p>画 user case，分析类图，某一个类状态图，详细设计一个类的方法和属性</p><p>==Use case、状态图、分析类图、挑选业务类完成业务类组件设计、非功能分析。==</p><p>第一章：软件基本特性，定义、so 1.1 1.2      1.2.4</p><p>第二章：2.1 <code>2.2</code> 2.3 2.4 [要真正的理解！大题]</p><p>第三章：3.1. 3.2 3.3 3.4 </p><p>第四章：可以不看书，瀑布模型、increase模型、螺旋模型和原型模型、其他不看</p><p>第五章：5.1 5.2 5.3 <code>重点要理解老师加的文档</code> 5.4（<code>要理解</code>，重点掌握，极限编程） </p><p>第六章：6.1-6.4  6.6 [简单看]</p><p>第七章：全部要掌握 需求工程</p><p>第八章：8.1 8.2 8.3 [最好看PPT，书本没必要看太细，7个阶段步骤！！！理解！每个步骤干嘛的，两个文档产品分别包括什么，功能建模可能是个别可能是整个系统的，两个文档与7个步骤<strong>是什么关系</strong>，从什么时候开始得到什么，搞懂后书上可以不看，书上有点乱。。。]</p><p>第九章：跟第8章、第10章融合在一起看，8、9、10一样都是需求工程，简单看书本，重点看自己的笔记！！！</p><p>第十章：</p><p>第十一章：行为建模——需求工程，也跟8、9、10一样都是需求工程，CRC模型。8是总的概念，后面都是详细讲</p><p>第十二章：整个都要看！！</p><p>第十三章：都要看！！ 13.7后面也有考</p><p>第十四章：都要看 以PPT为准</p><p>最后几章都要看，但是以PPT为准</p><p>牵线：</p><ul><li>软件的基本定义、特性、和硬件的不同</li><li>软件工程的定义、为何要工程化、工程化首先要过程化，所以要基于过程一步步来</li><li>过程模型：瀑布、迭代、敏捷模型等</li><li>做项目先讲需求工程、<code>7个步骤</code>，谈判（形成需求规约）、进入细化阶段的功能建模用ativity等抽象出来、数据建模（分析类图）、行为建模（画初步状态图，时序图）、细化完后有了需求分析规约，接着开始验证和评审，需求管理（配置管理工具）</li><li>以需求工程的两个产品进行概要设计，目标系统层次结构，前端和中间、后端调用关系，概要设计规约</li><li>详细设计规约</li><li>开始coding、进入测试阶段</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bug Daily</title>
      <link href="/2019/11/26/Bug%20Daily/"/>
      <url>/2019/11/26/Bug%20Daily/</url>
      
        <content type="html"><![CDATA[<h1 id="12-5"><a href="#12-5" class="headerlink" title="12.5"></a>12.5</h1><h2 id="VisualBox安装CentOS-6-10"><a href="#VisualBox安装CentOS-6-10" class="headerlink" title="VisualBox安装CentOS-6.10"></a>VisualBox安装CentOS-6.10</h2><p>参考链接一：<a href="http://dblab.xmu.edu.cn/blog/164/" target="_blank" rel="noopener">在Windows使用VirtualBox安装CentOS教程</a></p><p>参考链接二：<a href="https://www.centos.org/download/mirrors/" target="_blank" rel="noopener">CentOS镜像列表</a></p><h2 id="Hadoop伪分布式配置"><a href="#Hadoop伪分布式配置" class="headerlink" title="Hadoop伪分布式配置"></a>Hadoop伪分布式配置</h2><h3 id="CentOS环境配置和Hadoop-2安装"><a href="#CentOS环境配置和Hadoop-2安装" class="headerlink" title="CentOS环境配置和Hadoop 2安装"></a>CentOS环境配置和Hadoop 2安装</h3><p>参考链接一：<a href=".xmu.edu.cn/blog/install-hadoop-in-centos/">Hadoop安装教程_伪分布式配置_CentOS6.4/Hadoop2.6.0</a></p><p>参考链接一里面的java配置环境不能使用，所以又参考了参考链接二</p><p>参考链接二：<a href="https://jingyan.baidu.com/article/4853e1e51d0c101909f72607.html" target="_blank" rel="noopener">在CentOS上安装Java环境 – yum</a></p><p>参考链接二里面的java没有设置环境变量，所以又参考了参考链接三</p><p>在没有设置环境变量之前，先执行下java -version命令，提示找不到，现在只能在java的bin目录下执行，在设置完环境变量之后，就可以在任意目录下执行了。这也是<code>环境变量的用途</code></p><p>参考链接三：<a href="https://jingyan.baidu.com/article/0f5fb099370f146d8234ea43.html" target="_blank" rel="noopener">centos设置环境变量教程</a></p><p>然后根据参考链接三配置完后发现还是不行，于是重新跑了一下参考链接二中的使用yum安装Java环境，接着使用java -version 就可查看Java版本、javac 可查看Java的编译器命令用法了。。。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用yum安装Java环境</span></span><br><span class="line">yum -y install java-1.7.0-openjdk*  </span><br><span class="line"><span class="comment"># 查看刚安装的Java版本信息</span></span><br><span class="line">java -version <span class="comment"># 查看Java版本</span></span><br><span class="line">javac <span class="comment"># 查看Java的编译器命令用法</span></span><br></pre></td></tr></table></figure><p>安装的Hadoop版本是：Hadoop-2.10.0</p><p>解压.tar.gz到/opt/hadoop/文件夹下而非/usr/local</p>]]></content>
      
      
      <categories>
          
          <category> 开发日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DB2</title>
      <link href="/2019/11/26/DB2/"/>
      <url>/2019/11/26/DB2/</url>
      
        <content type="html"><![CDATA[<h2 id="Unit-3"><a href="#Unit-3" class="headerlink" title="Unit 3"></a>Unit 3</h2><blockquote><p>实验原理介绍</p></blockquote><h3 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h3><h3 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h3><p>参考链接：<a href="https://www.tutorialspoint.com/db2/index.htm" target="_blank" rel="noopener">DB2英文教程</a></p><h1 id="DB2应用开发"><a href="#DB2应用开发" class="headerlink" title="DB2应用开发"></a>DB2应用开发</h1><h1 id="期末小论文"><a href="#期末小论文" class="headerlink" title="期末小论文"></a>期末小论文</h1><p><img alt="image-20191224085316461" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga7j13dv7dj30hk0n8q94.jpg" class="lazyload"></p><p>约束有几种：</p><p>空值、检查、主键、唯一</p><blockquote><p>循环日志和归档日志</p></blockquote><p>两者区别</p><p>循环日志会被覆盖，空间可重复利用，但是不能实现日志尾前面的复原</p><p>归档日志，生产环境中常用</p><p>primarylog 主日志和辅助日志</p><p>主日志不够了才用辅助日志，两个优先级不一样</p><blockquote><p>recover命令 备份与复原</p></blockquote><blockquote><p>运行了三次访问计划</p></blockquote><p>1.没有索引，没有菱形，只有箭头+矩形框，return小的 -&gt; </p><p>2.加索引，用design advisor推荐索引，访问计划变成了有index的，数值从6000变成了600 -&gt; </p><p>3.重组了空洞，磁盘整理了一下，更新获得最优访问计划，数值从600多降低到几十</p><p>要求演示其最终访问计划</p><blockquote><p>锁和并发</p></blockquote><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGSIM数据集</title>
      <link href="/2019/11/26/NGSIM%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
      <url>/2019/11/26/NGSIM%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="NGSIM数据集"><a href="#NGSIM数据集" class="headerlink" title="NGSIM数据集"></a>NGSIM数据集</h1><p>NGSIM: <a href="http://ngsim-community.org/" target="_blank" rel="noopener">http://ngsim-community.org/</a></p><h2 id="数据一："><a href="#数据一：" class="headerlink" title="数据一："></a>数据一：</h2><p>US 101 - <a href="http://gateway.path.berkeley.edu/ngsimdocs/US-101" target="_blank" rel="noopener">http://gateway.path.berkeley.edu/ngsimdocs/US-101</a></p><p>早上45分钟的数据，每15分钟记录, vehicle trajectory data provide precise location of each vehicle 10HZ</p><h2 id="数据二："><a href="#数据二：" class="headerlink" title="数据二："></a>数据二：</h2><p>I-80 -<a href="http://gateway.path.berkeley.edu/ngsimdocs/I-80" target="_blank" rel="noopener">http://gateway.path.berkeley.edu/ngsimdocs/I-80</a><br>下午45分钟的数据，每15分钟记录, vehicle trajectory data provide precise location of each vehicle 10HZ</p><p>数据特征:</p><p><img alt="image-20191129212227207" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9f86zfednj315s09kgp6.jpg" class="lazyload"></p><h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><p>以上两个数据的网址都502了，我自己官网下载的是1.5G的csv文件</p><p>官网数据描述：</p><p>Researchers for the Next Generation Simulation (NGSIM) program collected detailed vehicle trajectory data on southbound <strong>US 101</strong> and Lankershim Boulevard in Los Angeles, CA, eastbound <strong>I-80</strong> in Emeryville, CA and Peachtree Street in Atlanta, Georgia. Data was collected through a network of synchronized digital video cameras.NGVIDEO, a customized software application developed for the NGSIM program, transcribed the vehicle trajectory data from the video. This vehicle trajectory data provided the precise location of each vehicle within the study area every one-tenth of a second, resulting in detailed lane positions and locations relative to other vehicles. Click the “Show More” button below to find additional contextual data and metadata for this dataset.</p><p>翻译：</p><p>（NGSIM）计划的研究人员收集了详细的车辆轨迹数据，这些数据分别位于加利福尼亚州洛杉矶的美国101南行和Lankershim大道，加利福尼亚州埃默里维尔的I-80东行以及佐治亚州亚特兰大的桃树街。数据是通过同步数码摄像机网络收集的。为NGSIM程序开发的定制软件应用程序NGVIDEO从视频中记录了车辆的轨迹数据。该车辆轨迹数据每十分之一秒便提供了每辆车在研究区域内的精确位置，从而得出详细的车道位置和相对于其他车辆的位置。单击下面的“Show more”按钮以查找此数据集的其他上下文数据和元数据：</p><p><img alt="image-20191129221249138" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9f9nayooxj30zu0kygp4.jpg" class="lazyload"></p><h2 id="NGSIM读取"><a href="#NGSIM读取" class="headerlink" title="NGSIM读取"></a>NGSIM读取</h2><p><a href="https://blog.csdn.net/davidwillsnow/article/details/91126007" target="_blank" rel="noopener">ngsim读取与ros可视化</a></p><p>数据 <a href="https://data.transportation.gov/Automobiles/Next-Generation-Simulation-NGSIM-Vehicle-Trajector/8ect-6jqj" target="_blank" rel="noopener">下载地址</a> ,如图,选择export,然后下载csv格式,大概1.5G左右</p><p><img alt="image-20191129220822616" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9f9iof28ej315e0gotdi.jpg" class="lazyload"></p><h3 id="pandas读取与使用"><a href="#pandas读取与使用" class="headerlink" title="pandas读取与使用"></a>pandas读取与使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#csv_fname = '../Next_Generation_Simulation__NGSIM__Vehicle_Trajectories_and_Supporting_Data.csv'</span></span><br><span class="line">csv_fname = <span class="string">'../data.txt'</span></span><br><span class="line">data = pd.read_csv(csv_fname)</span><br><span class="line"><span class="comment">#根据frame_id进行升序排序</span></span><br><span class="line">data.sort_values(<span class="string">"Frame_ID"</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#筛选id=354的数据</span></span><br><span class="line">obd_data = data[data[<span class="string">"Vehicle_ID"</span>]==<span class="number">354</span>]</span><br><span class="line"><span class="comment">#获取行数,列数</span></span><br><span class="line">rows = obd_data.shape[<span class="number">0</span>]</span><br><span class="line">cols = obd_data.shape[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#根据Frame_ID进行统计,各个Frame_ID的item数目</span></span><br><span class="line">print(data[<span class="string">'Frame_ID'</span>].value_counts())</span><br><span class="line"><span class="comment">#遍历每一行数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> data.iterrows():</span><br><span class="line">        <span class="comment"># feature extraction</span></span><br><span class="line">        row = row[<span class="number">1</span>]</span><br><span class="line">        frame_id, obs_id, timestamp = row[<span class="string">"Frame_ID"</span>], row[<span class="string">'Vehicle_ID'</span>], row[<span class="string">"Global_Time"</span>]*<span class="number">1e-6</span></span><br></pre></td></tr></table></figure><h1 id="论文一"><a href="#论文一" class="headerlink" title="论文一"></a>论文一</h1><p>论文1：Lane-Change Social Behavior Generator for Autonomous Driving Car<br>by Non-parametric Regression in Reproducing Kernel Hilbert Space， by Chiyu Dong, Yihuan Zhangy and John M. Dolanz</p><h2 id="换道场景："><a href="#换道场景：" class="headerlink" title="换道场景："></a>换道场景：</h2><p>输入：本车轨迹，周围车(本车道前后车，目标车道并行车及其前后车)的轨迹</p><p>输出：换道行为（换道起点和终点） 连续的值。 </p><p>起点和终点定义如下：</p><p><img alt="image-20191129212440553" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9f898qn84j315q06ktca.jpg" class="lazyload"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文和VIN都是利用监督训练的思路</p><ol><li><p>VIN中是网格化全局输入，动作为离散的8个动作，监督信息为利用优化方法生成的最优轨迹，环境是静态环境，但是可以迁移至新环境中；</p></li><li><p>本文的输入是==多车的轨迹数据==，输出的是==本车换道起点和终点==，环境对于本车可看成动态场景，但其实是把所有vehicle的轨迹看作一个整体作为输入，这里选择输出为两个点的信息而非轨迹信息或者waypoint信息，可能是因为输出的维度直接影响到核函数矩阵的维度，维度太高或者连续信息的是不是有问题？</p></li><li><p>有没有什么可以结合的点呢？<br>完全抛开本文的方法，利用NGSIM的真实数据 整合成VIN需要的数据，训练和测试一次 利用全卷积网络尝试对于变输入维度下的VIN</p></li></ol><h1 id="LC-NGSIM"><a href="#LC-NGSIM" class="headerlink" title="LC_NGSIM"></a>LC_NGSIM</h1><p>从NGSIM中提取的变道轨迹</p><p>数据集附在此文章下：</p><blockquote><p>Lane-change social behavior generator for autonomous driving car by non-parametric regression in Reproducing Kernel Hilbert Space</p></blockquote><p>另外附了一篇相关论文：Ramp Merging，不用看</p><h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><h3 id="playaround-m"><a href="#playaround-m" class="headerlink" title="playaround.m"></a>playaround.m</h3><p>作用：加载变道数据和变道点并进行可视化</p><p>展示结果：</p><p><img alt="image-20191129213601436" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9f8l569mej31a20skgom.jpg" class="lazyload"></p><p>playaround.m源码：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">load ../data/lc_data_20s_withpoints</span><br><span class="line"></span><br><span class="line">lc_len = <span class="built_in">length</span>(lc_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: lc_len</span><br><span class="line">    temp = lc_data&#123;<span class="built_in">i</span>&#125;;</span><br><span class="line">    pp   = points(<span class="built_in">i</span>,:);</span><br><span class="line">    lat  = temp.veh_s.x;</span><br><span class="line">    lon  = temp.veh_s.y;</span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">1</span>);<span class="built_in">hold</span> off;<span class="built_in">plot</span>(lon,lat,<span class="string">'b.'</span>);<span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot</span>(lon(pp(<span class="number">1</span>)),lat(pp(<span class="number">1</span>)),<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'g'</span>);</span><br><span class="line">    <span class="built_in">plot</span>(lon(pp(<span class="number">2</span>)),lat(pp(<span class="number">2</span>)),<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="TrajPreprocess-m"><a href="#TrajPreprocess-m" class="headerlink" title="TrajPreprocess.m"></a>TrajPreprocess.m</h3><p>作用：处理丢失的数据，例如，其中一个周围车辆不存在</p><p>然后输出处理过的processed_relative.mat作为已处理数据集</p><p> TrajPreprocess.m源码：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line"></span><br><span class="line">load(<span class="string">'..\data\nlc_data_5zones.mat'</span>)</span><br><span class="line">load(<span class="string">'..\data\lc_data_20s_withpoints.mat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% transfer to related coordinate, in terms of the host</span></span><br><span class="line"><span class="comment">%%% for the lc_data</span></span><br><span class="line">r_lc_data = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Label = [points; <span class="number">600</span>*<span class="built_in">ones</span>(<span class="built_in">length</span>(nlc_data),<span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">length</span>(lc_data)</span><br><span class="line">    trajs = lc_data&#123;<span class="built_in">i</span>&#125;;</span><br><span class="line">    origin_x = trajs.veh_s.x(<span class="number">1</span>);</span><br><span class="line">    origin_y = trajs.veh_s.y(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    R_trajs.veh_s_x = trajs.veh_s.x(<span class="number">1</span>:<span class="number">100</span>) - origin_x;</span><br><span class="line">    R_trajs.veh_s_y = trajs.veh_s.y(<span class="number">1</span>:<span class="number">100</span>) - origin_y;</span><br><span class="line">    Label(<span class="built_in">i</span>,<span class="number">1</span>) = trajs.veh_s.y(points(<span class="built_in">i</span>,<span class="number">1</span>)) - origin_y;</span><br><span class="line">    Label(<span class="built_in">i</span>,<span class="number">2</span>) = trajs.veh_s.y(points(<span class="built_in">i</span>,<span class="number">2</span>)) - origin_y;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    da = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trajs.veh_r.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_r_x = trajs.veh_r.x(<span class="number">1</span>:<span class="number">100</span>) - origin_x;</span><br><span class="line">        R_trajs.veh_r_y = trajs.veh_r.y(<span class="number">1</span>:<span class="number">100</span>) - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_r_x = <span class="number">0</span>*trajs.veh_r.x(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">        R_trajs.veh_r_y = <span class="number">0</span>*trajs.veh_r.y(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (trajs.veh_f.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_f_x = trajs.veh_f.x(<span class="number">1</span>:<span class="number">100</span>) - origin_x;</span><br><span class="line">        R_trajs.veh_f_y = trajs.veh_f.y(<span class="number">1</span>:<span class="number">100</span>) - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_f_x = <span class="number">0</span>*trajs.veh_f.x(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">        R_trajs.veh_f_y = <span class="number">0</span>*trajs.veh_f.y(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (trajs.veh_rt.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_rt_x = trajs.veh_rt.x(<span class="number">1</span>:<span class="number">100</span>) - origin_x;</span><br><span class="line">        R_trajs.veh_rt_y = trajs.veh_rt.y(<span class="number">1</span>:<span class="number">100</span>) - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_rt_x = <span class="number">0</span>*trajs.veh_rt.x(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">        R_trajs.veh_rt_y = <span class="number">0</span>*trajs.veh_rt.y(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (trajs.veh_ft.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_ft_x = trajs.veh_ft.x(<span class="number">1</span>:<span class="number">100</span>) - origin_x;</span><br><span class="line">        R_trajs.veh_ft_y = trajs.veh_ft.y(<span class="number">1</span>:<span class="number">100</span>) - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_ft_x = <span class="number">0</span>*trajs.veh_ft.x(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">        R_trajs.veh_ft_y = <span class="number">0</span>*trajs.veh_ft.y(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isfield(trajs, <span class="string">'veh_st'</span>) &amp;&amp; (trajs.veh_st.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_st_x = trajs.veh_st.x(<span class="number">1</span>:<span class="number">100</span>) - origin_x;</span><br><span class="line">        R_trajs.veh_st_y = trajs.veh_st.y(<span class="number">1</span>:<span class="number">100</span>) - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_st_x = <span class="number">0</span>*trajs.veh_ft.x(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">        R_trajs.veh_st_y = <span class="number">0</span>*trajs.veh_ft.y(<span class="number">1</span>:<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    da = [da;R_trajs.veh_s_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];</span><br><span class="line">    da = [da;R_trajs.veh_f_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];    </span><br><span class="line">    da = [da;R_trajs.veh_rt_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];    </span><br><span class="line">    da = [da;R_trajs.veh_ft_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];</span><br><span class="line">    da = [da;R_trajs.veh_st_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    r_lc_data&#123;<span class="built_in">i</span>&#125;=R_trajs;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">r_nlc_data = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: <span class="built_in">length</span>(nlc_data)</span><br><span class="line">    da = [];</span><br><span class="line">    trajs = nlc_data&#123;<span class="built_in">i</span>&#125;;</span><br><span class="line">    origin_x = trajs.veh_s.x(<span class="number">1</span>);</span><br><span class="line">    origin_y = trajs.veh_s.y(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    R_trajs.veh_s_x = trajs.veh_s.x - origin_x;</span><br><span class="line">    R_trajs.veh_s_y = trajs.veh_s.y - origin_y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (trajs.veh_r.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_r_x = trajs.veh_r.x - origin_x;</span><br><span class="line">        R_trajs.veh_r_y = trajs.veh_r.y - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_r_x = <span class="number">0</span>*trajs.veh_r.x;</span><br><span class="line">        R_trajs.veh_r_y = <span class="number">0</span>*trajs.veh_r.y;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (trajs.veh_f.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_f_x = trajs.veh_f.x - origin_x;</span><br><span class="line">        R_trajs.veh_f_y = trajs.veh_f.y - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_f_x = <span class="number">0</span>*trajs.veh_f.x;</span><br><span class="line">        R_trajs.veh_f_y = <span class="number">0</span>*trajs.veh_f.y;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (trajs.veh_rt.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_rt_x = trajs.veh_rt.x - origin_x;</span><br><span class="line">        R_trajs.veh_rt_y = trajs.veh_rt.y - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_rt_x = <span class="number">0</span>*trajs.veh_rt.x;</span><br><span class="line">        R_trajs.veh_rt_y = <span class="number">0</span>*trajs.veh_rt.y;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (trajs.veh_ft.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_ft_x = trajs.veh_ft.x - origin_x;</span><br><span class="line">        R_trajs.veh_ft_y = trajs.veh_ft.y - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_ft_x = <span class="number">0</span>*trajs.veh_ft.x;</span><br><span class="line">        R_trajs.veh_ft_y = <span class="number">0</span>*trajs.veh_ft.y;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> isfield(trajs, <span class="string">'veh_st'</span>) &amp;&amp; (trajs.veh_st.x(<span class="number">1</span>) ~= <span class="number">10000</span>)</span><br><span class="line">        R_trajs.veh_st_x = trajs.veh_st.x - origin_x;</span><br><span class="line">        R_trajs.veh_st_y = trajs.veh_st.y - origin_y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        R_trajs.veh_st_x = <span class="number">0</span>*trajs.veh_ft.x;</span><br><span class="line">        R_trajs.veh_st_y = <span class="number">0</span>*trajs.veh_ft.y;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    da = [da;R_trajs.veh_s_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];</span><br><span class="line">    da = [da;R_trajs.veh_f_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];    </span><br><span class="line">    da = [da;R_trajs.veh_rt_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];    </span><br><span class="line">    da = [da;R_trajs.veh_ft_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];</span><br><span class="line">    da = [da;R_trajs.veh_st_x(<span class="keyword">end</span><span class="number">-19</span>:<span class="keyword">end</span><span class="number">-10</span>) ];</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    r_nlc_data&#123;<span class="built_in">i</span>&#125;=R_trajs;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">save(<span class="string">'../data/processed_relative.mat'</span>,<span class="string">'Label'</span>,<span class="string">'r_lc_data'</span>,<span class="string">'r_nlc_data'</span>)</span><br></pre></td></tr></table></figure><h2 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h2><h3 id="mat文件"><a href="#mat文件" class="headerlink" title="mat文件"></a>mat文件</h3><p>注：mat文件是matlab的<strong>数据存储的标准格式</strong>。mat文件是标准的二进制文件,还可以ASCII码形式保存和加载，在MATLAB中打开显示类似于<strong>单行EXCEL表格</strong>。</p><blockquote><p>调用</p></blockquote><p>用户可以调用matlab的子程序库，用c或fortran调用mat格式的数据。</p><p>几个相关函数名：</p><p>load 打开mat文件</p><p>save 关闭\保存mat文件</p><p>load(‘filename’,’X’,’Y’,’Z’) 加载filename文件中的X Y Z变量到工作区间中</p><p>save(‘filename’,’-struct’,’s’) 保存结构体s到filename中</p><h3 id="nlc-data-5zones-mat"><a href="#nlc-data-5zones-mat" class="headerlink" title="nlc_data_5zones.mat"></a>nlc_data_5zones.mat</h3><ul><li>nlc_data: cell, 包含870个无变道场景的sequences</li></ul><ul><li>veh_s：主车<ul><li><strong>x</strong>: 横向位置 (m)</li><li><strong>y</strong>: 纵向位置(m)</li><li><strong>len</strong>:车辆长度(m)</li><li><strong>wid</strong>: 车辆宽度(m)*</li><li><strong>v</strong>: 车辆速度*Vehicle speed (m/s)</li><li><strong>a</strong>: 车辆加速度 (m/s^2)</li></ul></li><li>veh_f: 当前车道中的前车</li><li>veh_r: 当前车道中的后车</li><li>veh_ft:目标车道中的前车</li><li>veh_rt: 目标车道中的后车</li><li>veh_st:目标车道上的车辆重叠overlap vehicle in target lane？？？</li></ul><h3 id="lc-data-20s-withpoints-mat"><a href="#lc-data-20s-withpoints-mat" class="headerlink" title="lc_data_20s_withpoints.mat"></a>lc_data_20s_withpoints.mat</h3><ul><li>lc_data: <em>Same structure as nlc_data</em></li><li>points: <em>array, n row, 2 column, [start, end]</em></li></ul><h1 id="其他相关论文"><a href="#其他相关论文" class="headerlink" title="其他相关论文"></a>其他相关论文</h1><p>北京交通大学</p><p><a href="http://www.cnki.com.cn/Article/CJFDTotal-JTJS201506003.htm" target="_blank" rel="noopener">基于NGSIM轨迹数据的换道行为微观特性分析</a></p><h1 id="High-D数据"><a href="#High-D数据" class="headerlink" title="High D数据"></a>High D数据</h1><p>参考链接：<a href="http://www.yidianzixun.com/article/0KP0TlKp" target="_blank" rel="noopener">高速公路自然车辆轨迹的新数据集</a></p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGSIM 数据集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长短句</title>
      <link href="/2019/11/26/iWork%E9%9C%80%E6%B1%82%E8%A7%84%E7%BA%A6/"/>
      <url>/2019/11/26/iWork%E9%9C%80%E6%B1%82%E8%A7%84%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-11"><a href="#2019-11" class="headerlink" title="2019-11"></a>2019-11</h1><ol><li>精卫衔微木，将以填沧海。   ———— 陶渊明《读〈山海经〉·精卫衔微木》</li><li>敏而好学，不耻下问。      ———— 《论语·公冶长》</li><li>过而不改，是谓过矣。    ————《论语·卫灵公》</li><li>德荡乎名，知出乎争。<br>— ———《庄子·人间世》</li></ol><h1 id="2019-12"><a href="#2019-12" class="headerlink" title="2019-12"></a>2019-12</h1><ol><li>非淡泊无以明志，非宁静无以致远  一一一一诸葛亮《诫子书》</li><li>Both the conversations and the questions will be spoken only once.  一一一一英语六级考试</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文哲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长短句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iBook开发笔记</title>
      <link href="/2019/11/26/iBook%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/26/iBook%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><p>都是下载6.4.0版本</p><p>Ip地址：100.66.12.128</p><p>服务器：101.132.236.62</p><p>root用户密码：###123456#</p><p><strong>mac上传文件到远程服务器</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -p 22 文件名 ibook@101.132.236.62:/home/ibook</span><br></pre></td></tr></table></figure><p>将本地文件上传到ssh端口为22的ip为106.54.231.68上的服务器的/home/ibook目录下</p><p>输入密码：###13579#</p><p><strong>查看端口</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo lsof -i:8080</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND PID USER   FD   TYPE  DEVICESIZE/OFF NODE NAME </span><br><span class="line">  java  7748 Dang   58u  IPv6 0x613f359336d889a3 0t0  TCP *:8095 (LISTEN)</span><br></pre></td></tr></table></figure><p><strong>杀死进程</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo kill -9 7748</span><br></pre></td></tr></table></figure><p><strong>移动文件夹</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv [-fiv] source destination</span><br></pre></td></tr></table></figure><p>参数说明：<br>-f:force，强制直接移动而不询问</p><p>-i:若目标文件(destination)已经存在，就会询问是否覆盖</p><p>-u:若目标文件已经存在，且源文件比较新，才会更新</p>]]></content>
      
      
      <categories>
          
          <category> 开发笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据</title>
      <link href="/2019/11/26/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/11/26/%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>参考链接：<a href="http://c.biancheng.net/view/3604.html" target="_blank" rel="noopener">大数据</a></p><h1 id="Hadoop-MapReduce"><a href="#Hadoop-MapReduce" class="headerlink" title="Hadoop MapReduce"></a>Hadoop MapReduce</h1><p>本节首先简单介绍<code>大数据批处理</code>概念，然后介绍典型的批处理模式 MapReduce，最后对 Map 函数和 Reduce 函数进行描述。</p><p>##Hadoop MapReduce 架构 </p><h3 id="批处理模式"><a href="#批处理模式" class="headerlink" title="批处理模式"></a>批处理模式</h3><p>批处理模式是一种最早进行<strong>大规模数据处理</strong>的模式。批处理主要操作大规模静态数据集，并在整体数据处理完毕后返回结果。批处理非常适合<strong>需要访问整个数据集合</strong>才能完成的计算工作。</p><p>例如，在计算总数和平均数时，必须将数据集作为一个整体加以处理，而不能将其视作多条记录的集合。这些操作要求在计算进行过程中数据维持自己的状态。</p><p>需要处理大量数据的任务通常最适合用批处理模式进行处理，批处理系统在设计过程中就充分考虑了数据的量，可提供充足的处理资源。</p><p>由于批处理在应对大量持久数据方面的表现极为出色，因此经常被用于对历史数据进行分析。</p><p>为了提高处理效率，对大规模数据集进行批处理需要借助<strong>分布式并行程序</strong>。</p><p>传统的程序基本是以单指令、单数据流的方式按顺序执行的。这种程序开发起来比较简单，符合人们的思维习惯，但是性能会受到单台计算机的性能的限制，很难在给定的时间内完成任务。</p><p>而分布式并行程序运行在大量计算机组成的集群上，可以同时利用多台计算机并发完成同一个数据处理任务，提高了处理效率，同时，可以通过增加新的计算机扩充集群的计算能力。</p><p>Google 最先实现了分布式并行处理模式 MapReduce，并于 2004 年以论文的方式对外公布了其工作原理，Hadoop MapReduce 是它的开源实现。Hadoop MapReduce 运行在 HDFS 上。</p><h3 id="MapReduce-介绍"><a href="#MapReduce-介绍" class="headerlink" title="MapReduce 介绍"></a>MapReduce 介绍</h3><h2 id="Hadoop-MapReduce工作流程"><a href="#Hadoop-MapReduce工作流程" class="headerlink" title="Hadoop MapReduce工作流程"></a>Hadoop MapReduce工作流程</h2><h2 id="MapReduce-案例分析：单词计数"><a href="#MapReduce-案例分析：单词计数" class="headerlink" title="MapReduce 案例分析：单词计数"></a>MapReduce 案例分析：单词计数</h2><h2 id="Hadoop-MapReduce工作机制"><a href="#Hadoop-MapReduce工作机制" class="headerlink" title="Hadoop MapReduce工作机制"></a>Hadoop MapReduce工作机制</h2><h2 id="MapReduce-编程实例"><a href="#MapReduce-编程实例" class="headerlink" title="MapReduce 编程实例"></a>MapReduce 编程实例</h2>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南三阁</title>
      <link href="/2019/11/26/%E5%8D%97%E4%B8%89%E9%98%81/"/>
      <url>/2019/11/26/%E5%8D%97%E4%B8%89%E9%98%81/</url>
      
        <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><blockquote><p>PicGo</p></blockquote><p>基于 electron-vue 实现的桌面图床工具。该工具可以帮助你高效、非常方便地上传图片到网络图床，包括了微博图床、七牛图床、腾讯云 COS、又拍云、GitHub、SM.MS、阿里云OSS、Imgur 等。只要使用快捷键或拖动就可以上传，而且上传成功的图片链接会自动复制到你的剪贴板里，支持 <strong>macOS、Windows、Linux</strong> 三大系统(Mac用户使用iPic就行)</p><blockquote><p><a href="https://hellogithub.com/periodical/statistics/click/?target=https://github.com/2016rshah/githubchart-api">githubchart-api</a></p></blockquote><p>根据 GitHub 账号的贡献记录生成对应图像。一行代码，可以在任何网站展示自己在 GitHub 上的贡献活跃图标。示例代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://ghchart.rshah.org/用户名&quot; alt=&quot;Github commit chart&quot; /&gt;</span><br></pre></td></tr></table></figure><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><blockquote><p>vscode-leetcode</p></blockquote><p><a href="https://hellogithub.com/periodical/statistics/click/?target=https://github.com/jdneo/vscode-leetcode">vscode-leetcode</a>：这是一个可以让用户在 VS Code 编辑器中，练习 LeetCode 习题的插件。支持：查看高票解答、提交答案、测试答案等。提高了刷题效率，助你在校招、社招中杀出重围。上班摸鱼刷题利器</p><h1 id="优秀网站"><a href="#优秀网站" class="headerlink" title="优秀网站"></a>优秀网站</h1><blockquote><p>学习向：HelloGitHub</p></blockquote><p>分享 GitHub 上有趣、入门级的开源项目：<a href="https://github.com/521xueweihan/HelloGitHub" target="_blank" rel="noopener">HelloGitHub</a></p><p>这是一个面向编程新手、热爱编程、对开源社区感兴趣人群的项目，内容<strong>每月 28 号</strong>以月刊的形式更新发布。内容包括：<strong>流行项目</strong>、<strong>入门级项目</strong>、<strong>让生活变得更美好的工具</strong>、<strong>书籍</strong>、<strong>学习心得笔记</strong>、<strong>企业级项目</strong>等，这些开源项目大多都是非常容易上手、很 Cool，能够让你用很短时间感受到编程的魅力和便捷。从而让大家感受到编程的乐趣，动手开始编程。</p><blockquote><p>阅读向：科技爱好者周刊</p></blockquote><p>记录每周值得分享的科技内容，周五发布：<a href="https://github.com/ruanyf/weekly" target="_blank" rel="noopener">科技爱好者周刊</a></p><p>这里还有一些免费的电子书、音乐、照片和软件(其中的视频编辑器还不错)。</p><blockquote><p><a href="https://github.com/easychen/howto-make-more-money" target="_blank" rel="noopener">程序员如何优雅的挣零花钱</a></p></blockquote><p>程序员如何优雅的挣零花钱</p><blockquote><p><a href="https://github.com/binhnguyennus/awesome-scalability" target="_blank" rel="noopener">大型系统的模式</a></p></blockquote><p>可扩展，可靠和高性能的大型系统的模式</p><h1 id="前辈"><a href="#前辈" class="headerlink" title="前辈"></a>前辈</h1><h2 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h2><blockquote><p><a href="https://blog.csdn.net/Jurbo" target="_blank" rel="noopener">Jorbo</a></p></blockquote><p>编译原理的时候看着其笔记、对照MOOC视频进行学习的，挺详细的。专栏里还有一些不错的资源，如数据结构、游戏开发相关(20篇+)、C++、计算机图形学、OC刷题笔记、Python、数据库之类的，有空可以看看。</p><blockquote><p><a href="https://blog.csdn.net/qq_33414271/category_9292415.html" target="_blank" rel="noopener">土豆洋芋山药蛋</a></p></blockquote><p>编译原理也是看着他的笔记进行学习的，也挺详细的。优秀的专栏资源还有机器学习相关(30篇+)，计算机网络(13+18篇)，数据结构与算法(17篇)、Leecode刷题(18篇)、Python相关(10篇+)、论文阅读方法(5篇)</p><h1 id="优秀资源"><a href="#优秀资源" class="headerlink" title="优秀资源"></a>优秀资源</h1><blockquote><p>百度Apollo的自动驾驶数据集</p></blockquote><p>里面有点云图，说不定创新创业大赛能用到</p><p>参考网址：<a href="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247494022&idx=2&sn=d4a7b653c864817e9f91da7e7dd9f8a3&chksm=e99eda7fdee95369ec6cf5e2ae823af3cb8708b0e1128e6c18b397370363e51482b63b692998&scene=21#wechat_redirect" target="_blank" rel="noopener">百度Apollo的自动驾驶数据集</a></p><p><strong>数据概括</strong>：</p><p>预计「场景解析」数据集将提供 20 万张附有对应的语义标注与深度信息的图像数据（截止到2018 年 3 月 8 日，提供了 80000+ 张图像），将分为训练集，验证集和测试集三部分，并提供文件列表。训练集和验证集用于设计算法和训练模型，包括图像和相对应的语义标注与深度信息。测试集的语义标注图像将用于内部测试，不提供下载。</p><p>RGB 图像总数：200000</p><p>深度图像总数: 200000</p><p>类别标注总数: 25</p><p>车道线标注总数: 28</p><p>图像分辨率: 3384 x 2710</p><p>GPS 轨迹: 有</p><p>相机内部和外部参数: 有</p><p>两帧图像之间的距离: 1 米</p><p>数据集示例：</p><p><img alt="image-20191130113813293" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9fwxasi0aj31520ikau1.jpg" class="lazyload"></p><p><img alt="image-20191130113835669" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9fwxogacij314i0t047w.jpg" class="lazyload"></p><h1 id="HelloWorld项目"><a href="#HelloWorld项目" class="headerlink" title="HelloWorld项目"></a>HelloWorld项目</h1><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><blockquote><p>PDF Export</p></blockquote><h1 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h1>]]></content>
      
      
      <categories>
          
          <category> 南三阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 南三阁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式计算</title>
      <link href="/2019/11/26/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/11/26/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="0-intro"><a href="#0-intro" class="headerlink" title="0 intro"></a>0 intro</h1><h1 id="1-1-网络编程"><a href="#1-1-网络编程" class="headerlink" title="1.1 网络编程"></a>1.1 网络编程</h1><p><img alt="image-20191128130344994" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9do5npmmuj313004maav.jpg" class="lazyload"></p><h1 id="1-2-fileIO流和文件处理"><a href="#1-2-fileIO流和文件处理" class="headerlink" title="1.2 fileIO流和文件处理"></a>1.2 fileIO流和文件处理</h1><p><img alt="image-20191128130232338" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9do4heivhj319i0p6gpe.jpg" class="lazyload"></p><h1 id="1-3-云计算"><a href="#1-3-云计算" class="headerlink" title="1.3 云计算"></a>1.3 云计算</h1><p><img alt="image-20191128130407732" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9do621xfyj312w0kwwjb.jpg" class="lazyload"></p><h1 id="2-并发处理concurrency"><a href="#2-并发处理concurrency" class="headerlink" title="2 并发处理concurrency"></a>2 并发处理concurrency</h1><p><img alt="image-20191128131207434" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9doeejwi8j313e082ju1.jpg" class="lazyload"></p><h1 id="3-容错处理"><a href="#3-容错处理" class="headerlink" title="3 容错处理"></a>3 容错处理</h1><p><img alt="image-20191128131139369" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dodzd9tjj31300d20we.jpg" class="lazyload"></p><h1 id="4-hdfs"><a href="#4-hdfs" class="headerlink" title="4 hdfs"></a>4 hdfs</h1><p><img alt="image-20191128132411006" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9doqyjqh4j31iu0o8tc7.jpg" class="lazyload"></p><h1 id="5-hdfs-usage-api"><a href="#5-hdfs-usage-api" class="headerlink" title="5 hdfs usage api"></a>5 hdfs usage api</h1><h1 id="6-0-存储"><a href="#6-0-存储" class="headerlink" title="6.0 存储"></a>6.0 存储</h1><h1 id="6-1-dynamo"><a href="#6-1-dynamo" class="headerlink" title="6.1 dynamo"></a>6.1 dynamo</h1><h1 id="6-2-bigtable"><a href="#6-2-bigtable" class="headerlink" title="6.2 bigtable"></a>6.2 bigtable</h1><h1 id="6-3-cassandra"><a href="#6-3-cassandra" class="headerlink" title="6.3 cassandra"></a>6.3 cassandra</h1><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>略</p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><h3 id="选择多线程还是多进程"><a href="#选择多线程还是多进程" class="headerlink" title="选择多线程还是多进程"></a>选择多线程还是多进程</h3><p>在这个问题上，首先要看下你的程序是属于哪种类型的。一般分为两种 CPU 密集型 和 I/O 密集型。</p><ul><li>CPU 密集型：程序比较偏重于计算，需要经常使用 CPU 来运算。例如科学计算的程序，机器学习的程序等。</li><li>I/O 密集型：顾名思义就是程序需要频繁进行输入输出操作。爬虫程序就是典型的 I/O 密集型程序。</li></ul><p>如果程序是属于 CPU 密集型，建议使用多进程。而多线程就更适合应用于 I/O 密集型程序。</p><h3 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h3><p><strong>（1）</strong></p><p>不使用spark所说的哈夫曼编码压缩，原因是：</p><p>采用哈夫曼编码的方式进行文件的压缩和解压缩主要原理是通过huffman编码来表示字符，出现次数多的编码短，出现次数少的编码长，这样整体而言，所需的总的bit位是减少的。但是当大部分字符出现的频率都差不多时，huffman压缩的压缩率就会很低。</p><p>老师要求的频率都是256，不合适。</p><p>最后采用暴力的双重循环生成数据。。。</p><blockquote><p>改用Python，结果生成数据的时间为：</p></blockquote><p><img alt="182CF34F1F0783C511A4F4CBC7821776" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9hc9x8xoij31da03o751.jpg" class="lazyload"></p><h3 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a><strong>（2）</strong></h3><p>多线程读取同一个文件，要求不能重复，不能遗漏。</p><h3 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a><strong>（3）</strong></h3><p>Python多线程<strong>写</strong>同一个文件</p><p>1 通过队列Queue来实现。</p><blockquote><p><a href="https://www.runoob.com/python/python-multithreading.html" target="_blank" rel="noopener">菜鸟教程-Python多线程</a></p><p>采用线程优先级队列（ Queue）进行写入</p></blockquote><p>主线程启动一个线程来读文件，把文件的内容放到队列里。</p><p>然后启动若干线程，全部从队列取数据。python中的Queue是线程安全的。</p><p><a href="http://stackoverflow.com/questions/18781354/is-iterating-over-a-python-file-object-thread-safe" target="_blank" rel="noopener">http://stackoverflow.com/questions/18781354/is-iterating-over-a-python-file-object-thread-safe</a></p><p>Is iterating over a Python file object thread safe?</p><p>在这里Queue作为资源池，线程去从资源池中取数据进行处理，可是为什么需要用到Queue呢， 因为可能资源池很大，而开的线程数有限，所以等一个线程处理完它的任务之后，它可以继续去取资源处理！这就可以让先执行完一个任务的线程不立即停下来，而是去取另一个资源处理，直到没有数据的时候它才会停下来。简单理解：q.task_done是表明当前的资源处理完了，q.join()会等到所有的资源都被处理了才会向下继续执行，这就是一种同步。</p><p>参考原文链接：<a href="https://blog.csdn.net/xiao_huocai/article/details/74781820" target="_blank" rel="noopener">https://blog.csdn.net/xiao_huocai/article/details/74781820</a></p><p>队列线程的思想： 首先创建一个<strong>全局共享的队列</strong>，队列中只存在有限个元素，并将所有的数据逐条加入到队列中，并调用队列的join函数进行等待。之后便可以开启若干线程，线程的任务就是不断的从队列中取数据进行处理就可以了。</p><p>2.线程同步</p><blockquote><p><a href="https://www.runoob.com/python/python-multithreading.html" target="_blank" rel="noopener">菜鸟教程-Python多线程</a></p><p>使用Thread对象的Lock和Rlock可以实现简单的线程同步.这两个对象都有acquire方法和release方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间</p></blockquote><p>2 通过linecache来实现。linecache可以指定行号来读取一个文件的任意一行。主线程先分配给每个读线程各自读取的行号，然后各线程根据行号用linecache来读取。</p><p>此种方法依赖于linecache读取任意一行的速度，如果是大文件，则比较慢。</p><p>比如线程1需要读取10-20行。假设线程1有自己的文件指针的话，读了地10行，可以直接很快定位到第11行。但是用linecache读取的话，每一次读取一行就没有什么关系了。当然，对于linecache怎么定位到任意一行，其中的原理我也没探究过。</p><p>3分文件读取。python先调用linux命令head和tail，将一个文件分成若干个文件。然后每个读线程负责读取一个文件即可。</p><h2 id="python-多线程"><a href="#python-多线程" class="headerlink" title="python 多线程"></a>python 多线程</h2><h3 id="多线程-队列"><a href="#多线程-队列" class="headerlink" title="多线程 + 队列"></a>多线程 + 队列</h3><p>Queue用于建立和操作队列，常和threading类一起用来建立一个简单的线程队列。<br>Queue.Queue(maxsize)　　FIFO（先进先出队列）<br>Queue.LifoQueue(maxsize)　　LIFO（先进后出队列）<br>Queue.PriorityQueue(maxsize)　　为优先级越高的越先出来,对于一个队列中的所有元素组成的entries，优先队列优先返回的一个元素是sorted(list(entries))[0]。至于对于一般的数据，优先队列取什么东西作为优先度要素进行判断，官方文档给出的建议是一个tuple如(priority, data)，取priority作为优先度。</p><p>如果设置的maxsize<strong>小于1</strong>，则表示队列的长度无限长</p><p><strong>FIFO队列</strong></p><p>FIFO是常用的队列，常用的方法有：</p><p>Queue.qsize()　　 返回队列大小</p><p>Queue.empty()　　判断队列是否为空</p><p>Queue.full()　　 判断队列是否满了</p><p>Queue.get([block[,timeout]])　　从队列头删除并返回一个item，block默认为True，表示当队列为空却去get的时候会阻塞线程，等待直到有有item出现为止来get出这个item。如果是False的话表明当队列为空你却去get的时候，会引发异常。<br>在block为True的情况下可以再设置timeout参数。表示当队列为空，get阻塞timeout指定的秒数之后还没有get到的话就引发Full异常。</p><p>Queue.put(…[,block[,timeout]])　　向队尾插入一个item，同样若block=True的话队列满时就阻塞等待有空位出来再put，block=False时引发异常。<br>同get的timeout，put的timeout是在block为True的时候进行超时设置的参数。</p><p>Queue.task_done()　　从场景上来说，处理完一个get出来的item之后，调用task_done将向队列发出一个信号，表示本任务已经完成。</p><p>Queue.join()　　监视所有item并阻塞主线程，直到所有item都调用了task_done之后主线程才继续向下执行。这么做的好处在于，假如一个线程开始处理最后一个任务，它从任务队列中拿走最后一个任务，此时任务队列就空了但最后那个线程还没处理完。当调用了join之后，主线程就不会因为队列空了而擅自结束，而是等待最后那个线程处理完成了。</p><h1 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h1><p><img alt data-src="https://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png" class="lazyload"></p><h3 id="producer-java写完了"><a href="#producer-java写完了" class="headerlink" title="producer.java写完了"></a>producer.java写完了</h3><h3 id="多线程的写入的三种方法"><a href="#多线程的写入的三种方法" class="headerlink" title="多线程的写入的三种方法"></a>多线程的写入的三种方法</h3><blockquote><p>1.线程同步</p></blockquote><p>为了处理这种共享资源竞争，可以使用同步机制。所谓同步机制，指的是两个线程同时作用在一个对象上，应该保持对象数据的统一性和整体性。<a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> 提供 synchronized 关键字，为防止资源冲突提供了内置支持。共享资源一般是文件、输入/输出端口或打印机</p><p><a href="https://www.cnblogs.com/ll409546297/p/7197911.html" target="_blank" rel="noopener">IO写入方法</a></p><h2 id="第一题-法一"><a href="#第一题-法一" class="headerlink" title="第一题 法一"></a>第一题 法一</h2><p>IO写入方法：Reader、PrintWriter（PrintWriter这个很好用，在写数据的同事可以格式化）</p><p>线程数：时间</p><p>1 : 103040</p><p><img alt="image-20191202224101949" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9irbjvmnmj311e060t9e.jpg" class="lazyload"></p><p>2 : 98338</p><p><img alt="image-20191202223829261" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ir8xwimcj30xc06uaau.jpg" class="lazyload"></p><p>4 : 115989</p><p><img alt="image-20191202224341149" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ireb71u2j30vs0740tt.jpg" class="lazyload"></p><p>8 : 129334</p><p><img alt="image-20191202231718388" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9isdb0o9mj30vm09wabf.jpg" class="lazyload"></p><p>16 : 128296</p><p><img alt="image-20191202232209975" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9isicr0cfj30vq0i2tb5.jpg" class="lazyload"></p><p>32 : 128153</p><p><img alt="image-20191202232851169" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9isphkvzpj30u00w7wiz.jpg" class="lazyload"></p><h2 id="第一题-法二"><a href="#第一题-法二" class="headerlink" title="第一题 法二"></a>第一题 法二</h2><p>IO写入方法：BufferedOutputStream</p><p>线程数：时间</p><p>1 : 110837</p><p><img alt="image-20191203005847185" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ivaw73vzj30vi03474r.jpg" class="lazyload"></p><p>2 : 99897</p><p><img alt="image-20191203010939697" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ivm7ex6ej30wk040jry.jpg" class="lazyload"></p><p>4 :  105910</p><p><img alt="image-20191203011224780" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ivp243kij30w4060q3r.jpg" class="lazyload"></p><p>8 : 94820</p><p><img alt="image-20191203120859871" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jeo7ycxzj30va0a80u4.jpg" class="lazyload"></p><p>16 : 90362</p><p><img alt="image-20191203120141450" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jegmmka2j30vm0i4aci.jpg" class="lazyload"></p><p>32 : 102011</p><h3 id="第一题-法三"><a href="#第一题-法三" class="headerlink" title="第一题 法三"></a>第一题 法三</h3><p>OutputStream</p><p>奇慢无比，劝退</p><p>这是32线程的</p><p><img alt="image-20191203122544556" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jf5ndgemj30ay05e74m.jpg" class="lazyload"></p><p>改用dataOutputStream，速度正常多了,这是32线程的</p><p><img alt="image-20191203123414937" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jfeiemaxj30vw082759.jpg" class="lazyload"></p><p>如果第一题写入byte[]而不是int的话，速度慢而且输出不正常,所以还是用int!</p><p>32线程的时间：两倍长，大小还更大。。。2.8G左右</p><p><img alt="image-20191203123705337" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jfhgnrrsj308405mtas.jpg" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重新开了一下电脑所用时间不一样，时间差了1w左右。。。</span><br><span class="line">同一次跑时间差了几百左右</span><br><span class="line">最终重新跑一遍吧。。。不然不同时间跑没有可比性</span><br><span class="line">Java的IO写入的第三种方法，有问题，8线程有问题</span><br><span class="line">完全没必要用csv啊。。。。而且现在是读入的是Zip。。</span><br><span class="line">多线程+NIO有空去试试吧</span><br></pre></td></tr></table></figure><h2 id="第二题-Hadoop"><a href="#第二题-Hadoop" class="headerlink" title="第二题 Hadoop"></a>第二题 Hadoop</h2>]]></content>
      
      
      <categories>
          
          <category> 分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本编辑器使用手册</title>
      <link href="/2019/11/26/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2019/11/26/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-Markdown"><a href="#Typora-Markdown" class="headerlink" title="Typora - Markdown"></a>Typora - Markdown</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>opt_cmd+m：最小化</li><li>opt+cmd+t：表格</li><li>crtl+m：内敛公式</li></ul><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>参考链接：<a href="https://blog.csdn.net/mingzhuo_126/article/details/82722455" target="_blank" rel="noopener">使用Typora添加数学公式</a></p><h3 id="打开Typora选择数学模块"><a href="#打开Typora选择数学模块" class="headerlink" title="打开Typora选择数学模块"></a>打开Typora选择数学模块</h3><ul><li>快捷键：crtl+m</li><li>“$$”+回车</li></ul><ul><li>点击“段落”—&gt;“公式块”</li></ul><p>以上三种方式都能打开数学公式的编辑如下，所输入的公式居中。</p><p><img alt="image-20191127184323885" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cscr9jecj313a064ab2.jpg" class="lazyload"></p><h3 id="常见公式的代码"><a href="#常见公式的代码" class="headerlink" title="常见公式的代码"></a>常见公式的代码</h3><h4 id="上-下标"><a href="#上-下标" class="headerlink" title="上/下标"></a><strong>上/下标</strong></h4><table><thead><tr><th align="center"><strong>算式</strong></th><th align="center"><strong>Markdown</strong></th></tr></thead><tbody><tr><td align="center">$x^2 $</td><td align="center">$x^2 $</td></tr><tr><td align="center">$y_1 $</td><td align="center">$y_1 $</td></tr></tbody></table><h4 id="分式"><a href="#分式" class="headerlink" title="分式"></a><strong>分式</strong></h4>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本编辑器使用手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长短句</title>
      <link href="/2019/11/26/%E6%8C%96%E4%B8%AA%E5%9D%91%E5%9F%8B%E7%82%B9%E5%9C%9F/"/>
      <url>/2019/11/26/%E6%8C%96%E4%B8%AA%E5%9D%91%E5%9F%8B%E7%82%B9%E5%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-12"><a href="#2019-12" class="headerlink" title="2019-12"></a>2019-12</h1><ol><li>Hadoop和Cassandra</li><li>Spark </li><li><a href="https://github.com/microsoft/ai-edu" target="_blank" rel="noopener">微软AI课程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 文哲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长短句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫</title>
      <link href="/2019/11/26/%E7%88%AC%E8%99%AB/"/>
      <url>/2019/11/26/%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫框架WebMagic"><a href="#爬虫框架WebMagic" class="headerlink" title="爬虫框架WebMagic"></a><strong>爬虫框架WebMagic</strong></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">十次方前端：</span><br><span class="line">链接：https://pan.baidu.com/s/1hSwWbVaYX7-SIXcTcSl2_Q </span><br><span class="line">提取码：jq4t </span><br><span class="line">复制这段内容后打开百度网盘手机App，操作更方便哦</span><br><span class="line"></span><br><span class="line">十次方后端：</span><br><span class="line">链接：https://pan.baidu.com/s/1TMuShDenXf43HyUql6hbQQ </span><br><span class="line">提取码：kz8j </span><br><span class="line">复制这段内容后打开百度网盘手机App，操作更方便哦</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://blog.csdn.net/qq1031893936/article/details/100931293" target="_blank" rel="noopener">十次方人工智能笔记一：网络爬虫</a></p><h2 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h2><p>WebMagic的设计目标是尽量的<strong>模块化</strong>，并体现爬虫的功能特点。这部分提供非常简单、灵活的API，在基本不改变开发模式的情况下，编写一个爬虫。</p><p><strong>WebMagic</strong>的结构分为<strong>Downloader</strong>、<strong>PageProcessor</strong>、<strong>Scheduler</strong>、<strong>Pipeline</strong>四大组件，并由Spider将它们彼此组织起来。这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。而Spider则将这几个组件组织起来，让它们可以互相交互，流程化的执行，可以认为<strong>Spider</strong>是一个大的容器，它也是<strong>WebMagic逻辑的核心</strong>。</p><p><img alt="image-20191202091453144" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9i40sl7wnj315w0t6nhi.jpg" class="lazyload"></p><h2 id="WenMagic组件"><a href="#WenMagic组件" class="headerlink" title="WenMagic组件"></a>WenMagic组件</h2><ul><li><strong>Downloader</strong></li></ul><p>Downloader负责从互联网上下载页面，以便后续处理。WebMagic默认使用了ApacheHttpClient作为下载工具。</p><ul><li><strong>PageProcesser</strong></li></ul><p>PageProcessor负责解析页面，抽取有用信息，以及发现新的链接。WebMagic使用Jsoup作为HTML解析工具，并基于其开发了解析XPath的工具Xsoup。</p><p>在这四个组件中，PageProcessor对于每个站点每个页面都不一样，是需要<strong>使用者定制的部分</strong>。</p><ul><li><strong>Scheduler</strong></li></ul><p>Scheduler负责<strong>管理待抓取的URL</strong>，以及一些<strong>去重</strong>的工作。WebMagic默认提供了JDK的内存队列来管理URL，并用集合来进行去重。也支持使用Redis进行分布式管理。</p><ul><li><strong>Pipeline</strong></li></ul><p>Pipeline负责抽取结果的处理，包括<strong>计算、持久化到文件、数据库</strong>等。WebMagic默认提供了<strong>“输出到控制台”和“保存到文件”</strong>两种结果处理方案。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Spider-API"><a href="#Spider-API" class="headerlink" title="Spider API"></a>Spider API</h3><p>同时Spider的其他组件（Downloader、Scheduler、Pipeline）都可以通过set方法来进行设置。</p><p><img alt="image-20191202091744290" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9i43qou3fj31100u0wkv.jpg" class="lazyload"></p><h3 id="Site-API"><a href="#Site-API" class="headerlink" title="Site API"></a>Site API</h3><p><img alt="image-20191202091840244" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9i44povyuj31600tc0xx.jpg" class="lazyload"></p><h2 id="PageProcessor"><a href="#PageProcessor" class="headerlink" title="PageProcessor"></a>PageProcessor</h2><h3 id="爬取页面全部内容"><a href="#爬取页面全部内容" class="headerlink" title="爬取页面全部内容"></a>爬取页面全部内容</h3><p>需求：编写爬虫程序，爬取<code>csdn</code>中博客的内容 <a href="https://blog.csdn.net/" target="_blank" rel="noopener">https://blog.csdn.net/</a></p><ol><li><p>创建工程，引入依赖</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">  &lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">  xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">      &lt;groupId&gt;com.xushuai&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;webmagic_demo&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;us.codecraft&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.7.3&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;us.codecraft&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.7.3&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;/dependencies&gt;</span><br><span class="line">      &lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>实现页面爬取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xushuai.magic.spider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Page;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Site;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Spider;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.pipeline.ConsolePipeline;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.processor.PageProcessor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spider Class Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageProcessorDemo1</span> <span class="keyword">implements</span> <span class="title">PageProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Page page)</span> </span>&#123;</span><br><span class="line">    System.out.println(page.getHtml().toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Site <span class="title">getSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Site.me().setSleepTime(<span class="number">100</span>).setRetryTimes(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Spider.create(<span class="keyword">new</span> PageProcessorDemo1())</span><br><span class="line">      <span class="comment">// 添加爬取的主网站</span></span><br><span class="line">      .addUrl(<span class="string">"https://www.csdn.net/"</span>)</span><br><span class="line">      .run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Page代表了从Downloader下载到的一个页面——可能是HTML，也可能是JSON或者 其他文本格式的内容。Page是WebMagic抽取过程的核心对象，它提供一些方法可供抽取、结果保存等。</p><p>Site用于定义站点本身的一些配置信息，例如编码、HTTP头、超时时间、重试策略等、代理等，都可以通过设置Site对象来进行配置。</p><h3 id="爬取指定内容"><a href="#爬取指定内容" class="headerlink" title="爬取指定内容"></a>爬取指定内容</h3><p>使用<code>xpath</code>来抓去网页指定部分内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">page.getHtml().xpath(<span class="string">"//*[@id=\"nav\"]/div/div/ul/li[5]/a"</span>);</span><br></pre></td></tr></table></figure><h3 id="添加目标地址"><a href="#添加目标地址" class="headerlink" title="添加目标地址"></a>添加目标地址</h3><p>添加目标地址，将目标地址中所有的链接添加到待爬取列表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">page.addTargetRequests(page.getHtml().links().all());</span><br></pre></td></tr></table></figure><h3 id="目标地址正则匹配"><a href="#目标地址正则匹配" class="headerlink" title="目标地址正则匹配"></a>目标地址正则匹配</h3><p>需求：只提取博客的文章详细页内容，并提取标题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">page.addTargetRequests(page.getHtml()</span><br><span class="line">.links().regex(<span class="string">"https://blog.csdn.net/[a-z 0-9-]+/article/de</span></span><br></pre></td></tr></table></figure><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><h3 id="ConsolePipeline-控制台输出（省略）"><a href="#ConsolePipeline-控制台输出（省略）" class="headerlink" title="ConsolePipeline 控制台输出（省略）"></a>ConsolePipeline 控制台输出（省略）</h3><h3 id="FilePipeline-文件输出"><a href="#FilePipeline-文件输出" class="headerlink" title="FilePipeline 文件输出"></a>FilePipeline 文件输出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Spider.create(<span class="keyword">new</span> PageProcessorDemo1())</span><br><span class="line">    <span class="comment">// 添加爬取的主网站</span></span><br><span class="line">    .addUrl(<span class="string">"https://www.csdn.net/"</span>)</span><br><span class="line">    <span class="comment">// 添加控制台输出管道</span></span><br><span class="line">    .addPipeline(<span class="keyword">new</span> ConsolePipeline())</span><br><span class="line">    <span class="comment">// 添加文件输出管道</span></span><br><span class="line">    .addPipeline(<span class="keyword">new</span> FilePipeline(<span class="string">"F:/data"</span>))</span><br><span class="line">    .run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JsonFilePipeline-Json输出"><a href="#JsonFilePipeline-Json输出" class="headerlink" title="JsonFilePipeline Json输出"></a>JsonFilePipeline Json输出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Spider.create(<span class="keyword">new</span> PageProcessorDemo1())</span><br><span class="line">                <span class="comment">// 添加爬取的主网站</span></span><br><span class="line">                .addUrl(<span class="string">"https://www.csdn.net/"</span>)</span><br><span class="line">                <span class="comment">// 添加控制台输出管道</span></span><br><span class="line">                .addPipeline(<span class="keyword">new</span> ConsolePipeline())</span><br><span class="line">                <span class="comment">// 添加文件输出管道</span></span><br><span class="line">                .addPipeline(<span class="keyword">new</span> FilePipeline(<span class="string">"F:/data"</span>))</span><br><span class="line">                <span class="comment">// 添加Json输出管道</span></span><br><span class="line">                .addPipeline(<span class="keyword">new</span> JsonFilePipeline(<span class="string">"F:/json"</span>))</span><br><span class="line">                .run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Custom-Pipeline-自定义输出"><a href="#Custom-Pipeline-自定义输出" class="headerlink" title="Custom Pipeline 自定义输出"></a>Custom Pipeline 自定义输出</h3><ul><li>编写自定义管道类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xushuai.magic.pipeline;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.ResultItems;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Task;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.pipeline.Pipeline;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义输出管道</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPipeline</span> <span class="keyword">implements</span> <span class="title">Pipeline</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ResultItems resultItems, Task task)</span> </span>&#123;</span><br><span class="line">    System.out.println(resultItems.get(<span class="string">"title"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加自定义管道</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Spider.create(<span class="keyword">new</span> PageProcessorDemo1())</span><br><span class="line">    <span class="comment">// 添加爬取的主网站</span></span><br><span class="line">    .addUrl(<span class="string">"https://www.csdn.net/"</span>)</span><br><span class="line">    <span class="comment">// 添加控制台输出管道</span></span><br><span class="line">    .addPipeline(<span class="keyword">new</span> ConsolePipeline())</span><br><span class="line">    <span class="comment">// 添加文件输出管道</span></span><br><span class="line">    .addPipeline(<span class="keyword">new</span> FilePipeline(<span class="string">"F:/data"</span>))</span><br><span class="line">    <span class="comment">// 添加Json输出管道</span></span><br><span class="line">    .addPipeline(<span class="keyword">new</span> JsonFilePipeline(<span class="string">"F:/json"</span>))</span><br><span class="line">    <span class="comment">// 添加自定义管道</span></span><br><span class="line">    .addPipeline(<span class="keyword">new</span> CustomPipeline())</span><br><span class="line">    .run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p><code>Scheduler(URL管理)</code>最基本的功能是实现对已经爬取的URL进行标示。可以实现URL的<strong>增量去重</strong>。</p><p>目前Scheduler主要有三种实现方式：</p><ul><li>内存队列：QueueScheduler</li><li>文件队列：FileCacheQueueScheduler</li><li>Redis队列：RedisScheduler</li></ul><h3 id="内存队列"><a href="#内存队列" class="headerlink" title="内存队列"></a>内存队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Spider.create(<span class="keyword">new</span> PageProcessorDemo1())</span><br><span class="line">    <span class="comment">// 添加爬取的主网站</span></span><br><span class="line">    .addUrl(<span class="string">"https://www.csdn.net/"</span>)</span><br><span class="line">    <span class="comment">// 添加内存队列</span></span><br><span class="line">    .setScheduler(<span class="keyword">new</span> QueueScheduler())</span><br><span class="line">    .run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件队列"><a href="#文件队列" class="headerlink" title="文件队列"></a>文件队列</h3><p>使用文件保存抓取URL，可以在关闭程序并下次启动时，从之前抓取到的URL继续抓取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Spider.create(<span class="keyword">new</span> PageProcessorDemo1())</span><br><span class="line">                <span class="comment">// 添加爬取的主网站</span></span><br><span class="line">                .addUrl(<span class="string">"https://www.csdn.net/"</span>)</span><br><span class="line">                <span class="comment">// 添加文件队列</span></span><br><span class="line">                .setScheduler(<span class="keyword">new</span> FileCacheQueueScheduler(<span class="string">"F:/scheduler"</span>))</span><br><span class="line">                .run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Redis队列"><a href="#Redis队列" class="headerlink" title="Redis队列"></a>Redis队列</h3><p>使用Redis保存抓取队列，可进行多台机器同时合作抓取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Spider.create(<span class="keyword">new</span> PageProcessorDemo1())</span><br><span class="line">    <span class="comment">// 添加爬取的主网站</span></span><br><span class="line">    .addUrl(<span class="string">"https://www.csdn.net/"</span>)</span><br><span class="line">    <span class="comment">// 添加Redis队列</span></span><br><span class="line">    .setScheduler(<span class="keyword">new</span> RedisScheduler(<span class="string">"192.168.136.104"</span>))</span><br><span class="line">    .run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十次方文章数据爬取"><a href="#十次方文章数据爬取" class="headerlink" title="十次方文章数据爬取"></a>十次方文章数据爬取</h1><p>需求：每日某时间段从CSDN播客中爬取文档，存入文章数据库中。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>CSDN中各个频道的地址</li></ol><p><img alt="image-20191202093206235" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9i4ioglf0j31600fuq4w.jpg" class="lazyload"></p><ol start="2"><li>向数据库<code>tensquare_article</code>中的<code>tb_channel</code>表中添加记录</li></ol><p><code>应该加好了</code></p><h2 id="创建Module"><a href="#创建Module" class="headerlink" title="创建Module"></a>创建Module</h2><ol><li>pom.xml</li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;i_parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.i&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;i_article_crawler&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;us.codecraft&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.7.3&lt;/version&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;us.codecraft&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.7.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.i&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;i_common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>application.yml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9014</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: i-article-crawler #指定服务名</span><br><span class="line">  datasource:</span><br><span class="line">    driverClassName: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//**********:3306/article?characterEncoding=UTF8</span></span><br><span class="line">    username: ****** </span><br><span class="line">    password: ******</span><br><span class="line">  jpa:</span><br><span class="line">    database: MySQL</span><br><span class="line">    show-sql: <span class="keyword">true</span></span><br><span class="line">  redis:</span><br><span class="line">    host: *************</span><br></pre></td></tr></table></figure></li><li><p>启动类</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.i.articlecrawler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.scheduler.RedisScheduler;</span><br><span class="line"><span class="keyword">import</span> util.IdWorker;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleCrawlerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(ArticleCrawlerApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String redis_host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IdWorker <span class="title">idWorker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> IdWorker(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用的是Redis Scheduler</span></span><br><span class="line">    <span class="comment">// 使用Redis保存抓取队列，可进行多台机器同时合作抓取</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisScheduler <span class="title">redisScheduler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisScheduler(redis_host);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>文章实体类以及数据访问接口</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>第三次作业：<a href="mailto:1732965@tongji.edu.cn" target="_blank" rel="noopener">1732965@tongji.edu.cn</a></p><p>下面开始章节复习</p><ul><li><input disabled type="checkbox"> Part 1</li><li><input disabled type="checkbox"> Part 2</li><li><input disabled type="checkbox"> Part 3</li><li><input disabled type="checkbox"> Part 4</li></ul><p>重点是第3、4章</p><h1 id="第二次作业复习"><a href="#第二次作业复习" class="headerlink" title="第二次作业复习"></a>第二次作业复习</h1><h2 id="Lec1"><a href="#Lec1" class="headerlink" title="Lec1"></a>Lec1</h2><p><strong>课程概览</strong></p><p><img alt="image-20191213174811828" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9v8o8mp3kj30me0dk40a.jpg" class="lazyload"></p><p><strong>What is Computer Network</strong></p><ul><li><p><strong>计算机⽹络</strong>是由通信线路互连⽽组成的⽹络系统</p></li><li><p>Communication between a pair of processes</p></li><li><p>Hardware Management Application</p></li></ul><p><strong>硬件：</strong></p><p>Cable</p><p>Network Interface Card</p><p>Switch</p><p>Router</p><p><strong>联网显得复杂：</strong> ch1.2 </p><p>许多不同的技术共存</p><p>缺乏单一的基础理论</p><p>没有简单统一的术语</p><p>术语太多</p><p><strong>网络的五个关键方面</strong> 课本P3  ch1.3</p><p><strong>数据通信</strong>  ch1.3.2</p><p><img alt="image-20191213180317663" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9v93yovz2j30vu0isadw.jpg" class="lazyload"></p><p>用TCP/IP实现网络互联  ch1.3.2</p><p>TCP/IP网络</p><h2 id="11-29"><a href="#11-29" class="headerlink" title="11.29"></a>11.29</h2><p><code>考点</code>：帧里面都是IP吗？</p><p>错误，IP放在帧里，但帧里不一定都是IP</p><h1 id="12-04"><a href="#12-04" class="headerlink" title="12.04"></a>12.04</h1><p>两个实验：RIP、OSPF（最优路径的协议）</p><p>两个路由器之间用了两根线，静态路由验证是否联通，动态还要求验证是否最优，用两根线可以设置不同的带宽</p><p>这两个路由写的是哪个路径</p><p>RIP、OSPF都是最优路径的协议，但是标准不一样</p><ul><li><p>RIP：根据hop数量，两个点之间hop最少。两根线的带宽怎么设置都没用，都是一样的带宽，现在有线已经不用了，无线还在用</p></li><li><p>OSPF：有线的情况下这个最好用，根据带宽来定义。现走的是带宽高的线，从实验角度来看，虚拟实验。。。</p></li></ul><p>主机上还在配网关，路由器之间不一样了,现在为了模拟多…环境，路由器上有两个，一个1.0一个2.0，指定邻居网络(3个)。配置完就结束了，然后作实验。</p><p><img alt="image-20191204134006970" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kmxevjpfj30lc074gp7.jpg" class="lazyload"></p><p>配置OSPF动态路由  </p><p><strong>0.0.0.255</strong>   控制列表</p><h1 id="16周实验答辩，比例30"><a href="#16周实验答辩，比例30" class="headerlink" title="16周实验答辩，比例30%"></a>16周实验答辩，比例30%</h1><p>了解网络实验、设备等的自选项目，独立，4个人，写一个报告[结构一样的]</p><p><strong>实验设备清单</strong>：见附录1</p><p>IIP：蓝色盒子，中排中间</p><p>防火墙比较简单，控制端口</p><p>我们可以用NS3,模拟器，可以生成数据包</p><p>会当场问问题</p><p>创新，解决实际问题</p><p>分组名单，组号队后发助教邮箱 </p><h1 id="12-6"><a href="#12-6" class="headerlink" title="12.6"></a>12.6</h1><p>DHCP：路由器上自带的，实验室要做也很简单，PPT37页，看一下就行</p><p>第23章</p><p>第24章，IPv4-&gt;IPv6,奇数为测试版 </p><p>IPv6数据包格式，课本241，散落在各个章节，IPv6没有特殊的广播地址</p><p>产生一簇地址</p><p>以后网络都是DHCP的，IP慢慢消亡，域名地址</p><p>介绍UDP，25章</p><p>Ch26,TCP</p><h1 id="12-11"><a href="#12-11" class="headerlink" title="12.11"></a>12.11</h1><p>第26章很重要，可靠传输，完全跟上了课程，也听懂了，也看了PPT</p><p>2节课进行复习</p><p>数据连通层也在用的算法，跟TCP同理</p><p><img alt="image-20191213081310606" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9us1y5sukj318p0u0qgx.jpg" class="lazyload"></p><p>TCP 通讯系统 最新PPT为主</p><p>PPT第22页的累积确认，大概懂了，可以找找例题，很重要</p><p><img alt="image-20191213081239931" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9us1fpjc0j31870u0nlz.jpg" class="lazyload"></p><p>==包丢失== -&gt; 肯定要补，但补之前一定一定要流量控制！！！！先<strong>流量控制</strong>后<strong>补包</strong></p><p>重传，有延迟</p><h1 id="12-13"><a href="#12-13" class="headerlink" title="12.13"></a>12.13</h1><p>25.11 缓冲、流控与窗口 </p><p>课本P285的图25.7，窗口大小</p><p>25.12 TCP的<strong>三次</strong>握手，不会！考怎么解释，但一定是三次</p><p>25.13 以<strong>包丢失</strong>代表<strong>阻塞</strong>，先控制流量减小窗口再补包</p><p>25.16 TCP段格式，重点！！！</p><p>例题没听懂！！！orz</p><p><img alt="image-20191213091250803" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9uts3kt19j30nw0w0n6a.jpg" class="lazyload"></p><p>讲27章</p><p>动态路由和静态路由</p><p>IGP，一类协议，不是具体的一个协议</p><p>EGP</p><p>BGP是静态路由，双方都要配</p><p>动态路由的本质</p><p>实验：课本296页的BGP</p><h1 id="12-20"><a href="#12-20" class="headerlink" title="12.20"></a>12.20</h1><p><code>必考</code>要写题，距离矢量算法，产生一个新的hop该怎么更改新节点和本节点的路由表</p><p>![image-20191220075604596](/Users/hamster/Library/Application Support/typora-user-images/image-20191220075604596.png)</p><p>RIP和OSFP</p><p>具体用什么协议/算法，考概念大概</p><p>内部网关协议(路由表生成方式：动态路由)（算法：Link-state算法）</p><p>注意题目问的是什么</p><p>![image-20191220075929924](/Users/hamster/Library/Application Support/typora-user-images/image-20191220075929924.png)</p><p>算法只有两种，协议有很多种</p><p>组播有两个协议，主机与路由器(IGMP)、路由与路由之间</p><p>多播。IGMP协议，网际组播协议，定义主机成员，要加入一个主机IP和告诉路由器是多播，跟它说怎么发。</p><p>IGMP协议(Internet Group Management Protocol) 用于路由器查询与它直连的网络上是否存在组成员。</p><p>下图是IGMPv1的工作原理图。 IGMPv1协议只能对某个接口查询所有组，如果三次查询在十秒内都没有收到响应报告，则认为该接口没有任何组成员。</p><p>IGMP协议(Internet Group Management Protocol) 用于路由器查询与它直连的网络上是否存在组成员。</p><p><img alt="image-20191220082859650" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga2vulizhyj31640dejwa.jpg" class="lazyload"></p><p>下图是IGMPv1的工作原理图。 IGMPv1协议只能对某个接口查询所有组，如果三次查询在十秒内都没有收到响应报告，则认为该接口没有任何组成员。</p><p>用于路由器查询与它<strong>直连</strong>的网络上是否存在组成员。</p><p>IGMPv1：只能对某个接口查询所有组，若三次查询在10秒内都没有收到响应报告，则认为该接口没有任何组成员；</p><p>IGMPv2：可以直接针对某个组进行查询，而且主机加入组和离开组都要发通告；</p><p><code>退出不用报告，通过查询完成。报告是组播发给路由器，查询是组播问组成员你还在吗？如果超时没有应答，则组播把该成员给删除</code></p><p>路由与路由之间：3种算法，并没有对应到协议(简单看一下就行)</p><ul><li>Flood-And-Prune：看到一个就放它过去</li><li>Configuration-And-Tunneling：配置，有意识，效率高些</li><li>Core-Based Discovery：发现</li></ul><p>很多种协议</p><p><img alt="image-20191220084205740" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga2w8722nsj30qi0figny.jpg" class="lazyload"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>两个重点</p><p>应用层之间的交互、socket编程做了什么</p><p>应用层标志：端口，有两类TCP和UDP，ch3</p><p>应用层交互模式：</p><ul><li>客户-服务器交互模式</li></ul><p>服务器首先运行起来后，被动等待；客户端然后运行再主动发送连接请求。</p><p>服务器要同时处理并发的访问。是共享计算机，被动，接收并发，并发时处理资源是相同的。</p><p>服务器是当作一个软件用的</p><p>数据流，client和server</p><p>数据库最好独立出来，保护一下</p><p>服务器identification:IP地址/host name，端口号有TCP port和UDP port</p><p>PPT第18页，图片</p><p>本来服务器只能单程序，需要软件改成并发机制</p><p>一个进程只能跟一个进程聊天，不能同时跟2个进程聊天。</p><p>服务器编程的时候，首先服务器有一个主线程（接收所有请求，然后new一个service thread分发任务给该线程），发个窗口给另一个服务器上的进程处理。80端口只是main,处理可能是另一个端口</p><p>网络有瓶颈</p><ul><li>P2P架构</li></ul><p>两个客户机直接访问</p><p>应用层编程</p><p>Socket API，嵌入操作系统中</p><p>在操作系统中socket运行空间不一样，在系统外面：socket lib</p><p>下周，330，演示抓包软件等，330上课</p><p>实验报告17周之前完成，发给助教，单人单份，然后整成一份PDF，包括单人+自选实验</p><p>PPT的例子一定要掌握，比如算编号什么的</p><blockquote><p>12.25</p></blockquote><p>FTP：不同操作系统可以传文件</p><p>TFTP：两边都要知道</p><p>SMTP协议要记住，（POP3、<em>SMTP</em>及IMAP）</p><h1 id="12-27"><a href="#12-27" class="headerlink" title="12.27"></a>12.27</h1><p>重点：SNMP和SMTP</p><p>SNMP:客户机-服务器模式</p><p>软件从行为上讲是客户机，被管理的是服务器</p><p><strong>网络安全</strong></p><p>密码学两种方法：</p><ul><li>替换法：移位、换义法</li></ul><p>一个密钥，同时加密和解密，优点：对数据长度没有影响；缺点：很难查找泄密人员</p><p>密钥不能传大文件</p><p>对称密钥和非对称密钥</p><p>第5版</p><p>第3章安全的考试没有</p><p>作业再写几道题，考试题目相关题目</p><p>题型：</p><p>5个填空（信号、分几类、名字概念）</p><p>单选</p><p>判断题</p><p>简答题（主要是概念，星号比较多的要记住！机制、原理等会分点描述）</p><p>综合题（给个场景分析结果）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理PPT复习笔记</title>
      <link href="/2019/11/26/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/11/26/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="12-30复习"><a href="#12-30复习" class="headerlink" title="12.30复习"></a>12.30复习</h1><p>!! 难点</p><p>@ 考题</p><p>!!! 重点</p><p>!? 疑惑</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><ol><li><p>解释、翻译</p></li><li><p>解释（执行结果）、编译（产生目标代码）</p></li><li><p>发展：自然语言结构、有穷自动机和形式语言</p></li><li><p>编译过程的五个基本阶段：词法分析、语法分析、语义分析中间代码生成、优化、目标代码生成</p></li><li><p>词法分析（扫描程序）：</p><ul><li><p>源程序中的字符流-&gt;内部形式属性字Token（识别出标识符、关键字、常量、界限符）</p></li><li><p>工具：<code>正规式</code>和有限自动机</p></li><li><p>方法：状态图、DFA、NFA</p></li><li><p>词法分析示例；</p></li></ul></li></ol><ol start="6"><li><p>语法分析（识别程序）：</p><ul><li>词法分析程序识别出并转换的符号-&gt;语法分析树或其它中间表示（识别出短语、子句、语句、程序段、程序）</li><li>语法规则通常用<code>上下文无关文法</code>描述</li><li>方法：递归子程序法、分析法、算符优先分析法</li><li>语法分析示例</li></ul></li><li><p>语义分析和中间代码生成</p><ul><li><p>语义分析：对语法分析树或其他内部中间表示进行静态语义检查，主要任务是进行==类型审查==</p></li><li><p>语义分析示例</p></li><li><p>中间代码生成：输入句子-&gt;输出中间代码序列（四元式、三元式和逆波兰式等）</p></li><li><p>中间代码生成的方法：语义子程序、DAG图（有向无环图）、语法制导翻译</p></li><li><p>四元式的结构：（算符，运算对象1，运算对象2，结果）</p></li><li><p>例题：执行完103后没有跳出 </p><img style="zoom:30" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaelp57y4qj30zy0d40vm.jpg" class="lazyload"></li></ul></li><li><p>优化</p><ul><li>加工中间代码-&gt;高效（时间和空间）代码</li><li>依循的原则是程序的等价变换规则</li><li>方法：公共子表达式的提取、循环优化、删除无用代码等。</li><li>优化示例</li></ul></li><li><p>目标代码生成</p><ul><li>中间代码-&gt;特定机器上的低级语言代码</li></ul></li><li><p>编译程序的结构</p><img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaelyskbh1j311y0pqjwm.jpg" class="lazyload"></li><li><p>表格与表格管理：各种表格，其中符号表最重要，记录标识符的名字、类型、作用域、分配存储等信息</p></li><li><p>出错处理：</p><ul><li>语法错误：词法分析和语法分析检测出，如保留字拼写错误、括号不配对</li><li>语义错误：编译或运行时检测出，如<img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaem4gumfxj30x40bewkb.jpg" class="lazyload"></li><li>出错处理最好：全、准、局部化</li></ul></li><li><p>编译阶段的组合：前端（源语言，词分到优化）和后端（目标代码）</p></li><li><p>遍：每遍记录于外存，多遍编译</p><img style="zoom:60" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaembml5ghj30lm0q6wi4.jpg" class="lazyload"></li><li><p>编译程序的生成</p><ul><li>编译程序实现语言:机器、汇编、高级</li><li>生成技术：自编译、交叉编译、自动编译</li></ul></li><li><p><code>T形图!!</code></p><ul><li><p>T形图</p><img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaemez30r4j30xe0ga40s.jpg" class="lazyload"></li><li><p>示例1：用 L1语言编写另一种高级语言L2的==编译程序==</p><img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaetz3o4msj30zs0q0dmc.jpg" class="lazyload"></li><li><p>示例2：<code>@</code>编译程序的移植，先用L语言写一个A机器上的B机器语言编译程序，然后用这个编译程序编译原来那个源程序，这样就能得到在B机器上运行的产生B机器语言的编译程序。</p><img style="zoom:20" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaeu4ris9bj30rg0fmgma.jpg" class="lazyload"></li><li><p>自编译：某种高级语言书写==自己==的编译程序称为自编译。</p></li><li><p>交叉编译：用x机器上的编译程序产生可在y机器上运行的目标代码</p><p>称为交叉编译。</p></li><li><p>自动编译：自动生成编译程序的软件工具，如和LEX和YACC</p></li></ul></li><li><p>编译系统是一系统软件</p></li></ol><h1 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h1><h2 id="一、程序设计语言的定义"><a href="#一、程序设计语言的定义" class="headerlink" title="一、程序设计语言的定义"></a>一、程序设计语言的定义</h2><ol><li>是否可直接执行：不可，需汇编，连接 高级：需编译/解释，连接</li></ol><h2 id="二、程序设计语言的内涵-语法、语义、语用"><a href="#二、程序设计语言的内涵-语法、语义、语用" class="headerlink" title="二、程序设计语言的内涵[语法、语义、语用]"></a>二、程序设计语言的内涵[语法、语义、语用]</h2><ol><li><p>语法</p><ul><li><p>语言的语法是指可以形成和产生程序的一组规则。包括==词法规则和语法规则==</p></li><li><p>词法规则和语法规则的语法描述方式都可以用：自然语言、语法图、BNF(巴科斯范式)范式、或文法等描述。</p><img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaeuxwdxk7j30x60j8gtc.jpg" class="lazyload"></li></ul></li><li><p>语义：定义它的单词符号和语法单位的意义</p><ul><li>语义是指这样的一组规则，使用它可以定义一个程序的意义。</li><li>采用的方法为：==基于属性文法的语法制导翻译==方法。</li></ul></li></ol><h2 id="三、程序语言的功能"><a href="#三、程序语言的功能" class="headerlink" title="三、程序语言的功能"></a>三、程序语言的功能</h2><ol><li>一个程序语言的基本功能是描述数据和对数据的运算，数据的处理过程</li></ol><h2 id="四、高级语言的一般特性"><a href="#四、高级语言的一般特性" class="headerlink" title="四、高级语言的一般特性"></a>四、高级语言的一般特性</h2><ol><li><p>类型：强制式(过程式语言)、应用式(函数式语言)、基于规则(条件→动作)、面向对象(封装/继承/多态)</p></li><li><p>程序结构：单层、多层结构</p></li><li><p>数据类型与操作：初等类型（整型、浮点型、字符型）、复合类型（结构、数组）到抽象数据类型（类，信息隐蔽和数据封装，使用与实现相分离）</p></li><li><p>语句与控制结构：表达式、语句[简单语句（说明语句、赋值语句、控制语句、输入输出语句、过程调用语句），复合语句]</p></li><li><p>表达式的形成规则</p><img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaevj7zrtoj30wu0920wp.jpg" class="lazyload"></li><li><p>语句</p><ul><li>赋值语句：对赋值号右边的B我们需要的是它的值；对于左边的A我们 需要的是它们的所代表的存储单元（的地址）；一个名字所代表 的那个存储单元（地址）称为该名字的左值；把一个名字的值称为该名字的右值。</li><li>控制语句：无条件转移语句、条件语句、循环语句、过程调用语句、返回语句</li><li>输入输出语句</li></ul></li></ol><h1 id="语法描述"><a href="#语法描述" class="headerlink" title="语法描述"></a>语法描述</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ol><li>编译原理=形式语言理论+编译技术，语言的语法定义是非常重要的</li><li><code>形式语言</code>是某个字母表上的字符串的集合，有一定的描述范围。</li><li>由文法产生的符号串构成语言 = 由自动机识别的符号串构成语言</li></ol><h2 id="二、形式语言与自动机理论"><a href="#二、形式语言与自动机理论" class="headerlink" title="二、形式语言与自动机理论"></a>二、形式语言与自动机理论</h2><ol><li>文法和自动机分别从==生成和识别==的角度去表达语言， 而且证明了文法与自动机的等价性，形式语言真正诞生</li></ol><h2 id="三、文法的形式定义"><a href="#三、文法的形式定义" class="headerlink" title="三、文法的形式定义 !!!"></a>三、文法的形式定义 <code>!!!</code></h2><p>$$<br>G = (V_T , V_N , P , S )<br>$$</p><ul><li><p>G：表示文法，文法由==四元组==定义</p></li><li><p><strong>终结符集合和非终结符集合都是字母表</strong></p></li><li><p><strong>终结符集合与非终结符集合是不相交的</strong> -&gt; $V_T∩V_N=Φ$ </p></li><li><p><strong>终结符集合与非终结符集合的并集是文法符号集</strong> -&gt; $V_T∪V_N$：文法符号集</p></li><li><p>$V_T$：</p><img style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwiac7sij30y807amzp.jpg" class="lazyload"></li><li><p>$V_N$：<strong>因为从它们可以推出其他的语法成分，所以被称为非终结符</strong></p><img style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwjbrw6nj30wi08kmzw.jpg" class="lazyload"></li><li><p>P：产生式集合，注意左部和右部的取值，左部是正闭包，右部是克林闭包</p><p>例： P = &lt;句子&gt; → &lt;名词短语&gt;&lt;动词短语&gt;, &lt;名词短语&gt; → &lt;形容词&gt;&lt;名词短语&gt;</p><img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwq1999lj30x60aqwie.jpg" class="lazyload"></li><li><p>S：开始符号</p><p>$S∈V_N$，开始符号(start symbol)表示的是==该文法中最大的语法成分==。属于==非终结符号==，至少在某个产生式的左部出现一次。例：S = &lt;句子&gt;</p><img style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwvvddqrj30yg050gn9.jpg" class="lazyload"><p>例：</p><img style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwwi6n07j30y408kgok.jpg" class="lazyload"></li></ul><h2 id="四、符号的约定"><a href="#四、符号的约定" class="headerlink" title="四、符号的约定 !!!"></a>四、符号的约定 <code>!!!</code></h2><ul><li><p>终结符，非终结符和其他</p><center class="half">  <img style="zoom:20%" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx6fd6qwj30xg0cuwkb.jpg" class="lazyload"><img style="zoom:20%" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx7ceu2nj30yw0ck0zh.jpg" class="lazyload"><img style="zoom:20%" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxbpc4g8j30ny0aqdqa.jpg" class="lazyload"></center>  </li><li><p>子符号串</p></li><li><p>符号串的前缀与后缀</p><img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaew79iaa9j315e0cy42z.jpg" class="lazyload"></li><li><p>符号串集合</p><img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaew8m0v1pj316c05o40t.jpg" class="lazyload"></li><li><p>空符号串ε，{ε}</p></li><li><p>（连接）积，n次（连接）积，闭包，正闭包</p><center class="half">  <img style="zoom:20%" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaewml7va5j30ws0jqjw1.jpg" class="lazyload"><img style="zoom:20%" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaewg720y4j317m0f4ae6.jpg" class="lazyload"></center>  </li><li><p>候选式</p><img style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaewcdflkpj3154066dhn.jpg" class="lazyload"></li><li><p>文法简化的约定</p><img style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaewxqmy6nj30xu0ieq72.jpg" class="lazyload"></li></ul><h2 id="五、如何由文法产生句子"><a href="#五、如何由文法产生句子" class="headerlink" title="五、如何由文法产生句子"></a>五、如何由文法产生句子</h2><ol><li><p>基本思想：从识别符号开始，把当前产生的符号串中的<strong>非终结符号</strong>替换为相应产生式右部的<strong>符号串</strong>，直到最终全由终结符号组成。 这种替换过程称为推导或产生句子的过程， 每一步称为<strong>直接推导</strong>或直接产生。</p></li><li><p>归约是推导的逆过程</p></li><li><p>若在推导关系中，每次最先替换最左（右） 的非终结符，则称为最左（右）推导；</p></li><li><p>若在归约过程中，每次最先归约最左（右） 的非终结符，则称为最左（右）归约。</p><p>例题<code>@</code>：</p><img style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaey7y2ov8j31740ok0xc.jpg" class="lazyload"></li><li><p>句型、句子和语言</p><ul><li><p>句型：假定G是一个文法，E是它的开始符号，如果E -&gt; α，则称α是文法G的一个句型。</p></li><li><p>句子：仅由==终结符==组成的句型称为句子</p></li><li><p>语言：文法G所产生句子的全体</p></li><li><p>写出某文法描述的语言</p><img alt="image-20191231084450680" style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gafm4ggw2vj317i0metdl.jpg" class="lazyload"></li><li><p>写出某语言对应的文法</p><img alt="image-20191231084705150" style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gafm6vlwitj317m0o610l.jpg" class="lazyload"><ul><li>同一句型可以有不同的推导序列</li></ul></li></ul></li></ol><h2 id="六、Chomsky文法体系"><a href="#六、Chomsky文法体系" class="headerlink" title="六、Chomsky文法体系"></a>六、Chomsky文法体系</h2><ol><li><p>文法的==核心==是产生式的集合，它决定了语言中句子的产生。</p></li><li><p><code>Chomsky文法体系分类</code>：</p><p><strong>0型文法，无限制文法，短语结构文法</strong></p><ul><li>α中至少包含1个非终结符</li></ul><img alt="image-20191127221027086" style="zoom:30" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyc6uglwj31600fe78m.jpg" class="lazyload"><p><strong>1型文法，上下文有关文法(CSG)</strong></p><ul><li><p>产生式左部符号的个数不能多于右部</p></li><li><p>不包含 $\varepsilon$ 产生式，即产生式<strong>右部是空串的产生式</strong>，因为左部至少包含一个非终结符，左部长度至少为1，如果右部是 $\varepsilon$ ，右部长度为1，与CGS定义不符合。</p></li></ul><img alt="image-20191127221328301" style="zoom:30" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyfbx748j315y0i2afd.jpg" class="lazyload"><p><strong>2型文法，上下文无关文法(CFG)</strong></p><ul><li>左边是<strong>一个非终结符</strong>，将其替换不需要考虑其上下文</li><li>所举的例子即2型文法</li></ul><img alt="image-20191127221344869" style="zoom:30" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyfm18zwj315w0ig786.jpg" class="lazyload"><p><strong>3型文法，正规文法，正则文法(RG)</strong></p><ul><li>3型文法分为2种文法</li><li>产生式右部<strong>最多只有一个非终结符</strong>，且只能在一侧</li><li>例子中的两个文法都是指标识符，即一个字母或以字母开头的字母数字串</li><li>程序语言中的多数单词都能用正则文法表示</li></ul><img alt="image-20191127222052426" style="zoom:30" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyn3744ej315u0ian4k.jpg" class="lazyload"><p><strong>四种文法之间的关系</strong></p><img alt="image-20191127222635614" style="zoom:30" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyszv3q5j31620fi43y.jpg" class="lazyload"></li><li><p>文法、形式语言和自动机的对应关系</p><img alt="image-20191231090637721" style="zoom:10" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gafmr7n7dpj31620msada.jpg" class="lazyload"></li><li><p>自然语言是上下文有关的，<code>上下文无关文法</code>可以描述多数程序设计语言的语法结构（如算术表达式、语句）</p></li><li><p>基于<code>正规文法</code>讨论词法分析问题，基于<code>上下文无关文法</code>讨论语法分析问题，而其中上下文有关的问题，可通过==表格处理==解决</p></li><li><p>程序语言中,有些语言结构并不是总能用上下文无关文法描述的。</p></li></ol><h2 id="七、语法分析树和文法二义性"><a href="#七、语法分析树和文法二义性" class="headerlink" title="七、语法分析树和文法二义性"></a>七、语法分析树和文法二义性</h2><ol><li><p><strong>上下文无关文法的分析树</strong></p><p>程序语言中的多数单词都能用正则文法表示，但正则文法生成能力有限，句子构造则需要用上下文无关文法进行描述。</p></li><li><p><strong>上下文无关文法分析树定义</strong></p><p>例：图中跟节点表示的是对第三个式子的应用</p><p>树的叶结点符号所组成的符号串W就是<strong>所给句型</strong>；若w中仅含 终结符号，则w为文法G所产生的<strong>句子</strong></p><img alt="image-20191127222833264" style="zoom:39" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyv3e5bpj315y0hwq9o.jpg" class="lazyload"></li><li><p><strong>分析树是推导的图形化表示</strong></p><p>推导过程中产生许多<code>句型</code>,最终推导出分析树的边缘</p><img alt="image-20191127223759244" style="zoom:30" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cz4u6zi1j315q0fktds.jpg" class="lazyload"></li><li><p><strong>句型的短语</strong></p><p>给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个<code>短语</code>。</p><p>如果子树只有父子两代节点，那么这课子树的边缘称为该句型的一个<code>直接短语</code>。</p><p><strong>==直接短语==一定是==产生式的右部==，但产生式的右部不一定是给定句型的直接短语，但可能是其他句型的直接短语</strong></p><p><img alt="image-20191127224229562" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cz9jcs2rj316609077h.jpg" class="lazyload"></p><p>例：人民、生活、水平是该句子的直接短语，而高人、民生、活水虽然也是第5个产生式的右部，但是在这棵分析树中，它们不是直接短语。</p><img alt="image-20191127225119891" style="zoom:50%;" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cziqh449j30o40bigub.jpg" class="lazyload"></li><li><p>一个句型是否只有唯一的一个最左(最右)推导呢?</p><p>否！</p><p>一个句型是否只对应唯一的一棵语法树呢?</p><p>否！ ，因为不同的最右（左）推导对应不同的语法树。</p><p>一个句型可以有不同的最左(最右)推导，对应的语法树也不同</p></li><li><p>二义性文法</p><p>如果<strong>一个文法可以为某个句子生成多棵分析树</strong>，则称这个文法是二义性的。</p><p>下面这个例子产生二义的原因是else可以跟第一个if条件语句和第二个if条件语句相配。</p><p><code>消歧规则</code>：每个else和最近的尚未匹配的if进行匹配，所以只有第一个分析树，可通过某些规定将二义文法改造为无二义文法</p><img alt="image-20191127225609332" style="zoom:20" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cznqxtqrj315y0fcadz.jpg" class="lazyload"></li><li><p>二义性文法的判定</p><p>对于任意一个上下文无关文法，不存在一个算法，判断它是无二义性的，但能给出一组充分条件，满足这组充分条件的文法是无二义性的。</p></li></ol><ul><li>满足，肯定无二义性</li><li>不满足，也未必就是有二义性的</li></ul><ol start="8"><li><p>证明句子是二义性，找个句子然后画出多条语法分析树</p><img alt="image-20191231114350430" style="zoom:30" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gafrapr9pzj30g806et95.jpg" class="lazyload"></li></ol><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="一、对于词法分析器的要求"><a href="#一、对于词法分析器的要求" class="headerlink" title="一、对于词法分析器的要求"></a>一、对于词法分析器的要求</h2><ol><li><p>字符串的源程序改造成为单词符号串</p></li><li><p>词法分析是编译的==基础==。执⾏词法分析的程序称为词法分析器。</p></li><li><p>词法分析顾名思义就是通过扫描源程序，识别出每一个单词，确定单词类型，然后转化为统一的机内表示——<code>词法单元（token）</code>形式</p><p>token：&lt; 种别码，属性值&gt;</p><p>例如if、else对应唯一的表示形式。具体的表示形式如下表所示：</p><img alt="image-20191127170722792" style="zoom:33" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpkudcwfj30yc0dkte0.jpg" class="lazyload"><p>例如有一句代码为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(value!=<span class="number">100</span>)&#123;num++;&#125;</span><br></pre></td></tr></table></figure><p>则经过词法分析后如下所示，其中每句后的&lt;-,-&gt;表示每个单词的含义。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>      &lt; WHILE ,    -  &gt;  <span class="comment">// 关键词，一词一码</span></span><br><span class="line">(          &lt;SLP    ,    -  &gt;  <span class="comment">// 界限符，一词一码</span></span><br><span class="line">value      &lt;IDN    ,  value&gt;  <span class="comment">// 标识符，多词一码，&lt; 种别码，属性值value&gt;</span></span><br><span class="line">!=         &lt;NE     ,    -  &gt;  <span class="comment">// 运算符，一词一码</span></span><br><span class="line"><span class="number">100</span>        &lt;CONST,<span class="number">100</span>&gt;   <span class="comment">// 常 量，一型一码</span></span><br><span class="line">)          &lt;SRP,-&gt;            <span class="comment">// 界限符，一词一码</span></span><br><span class="line">&#123;          &lt;LP,-&gt;             <span class="comment">// 界限符，一词一码</span></span><br><span class="line">num        &lt;IDN,num&gt;          <span class="comment">// 标识符，多词一码，&lt; 种别码，属性值value&gt;</span></span><br><span class="line">++         &lt;INC,-&gt;            <span class="comment">// 运算符，一词一码</span></span><br><span class="line">;          &lt;SEMI,-&gt;           <span class="comment">// 界限符，一词一码</span></span><br><span class="line">&#125;          &lt;RP,-&gt;             <span class="comment">// 界限符，一词一码</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>单词符号的属性值，标识符、常数：指针、内部字符串或⼆进制形式；关键字、运算符和界符是⼀符⼀种，不需给出其⾃身的值。</p></li><li><p>词法分析程序的实现⽅式：</p><ul><li><p>完全独⽴⽅式</p><p>词法分析程序作为<strong>单独⼀遍</strong>来实现。 词法分析程序读⼊整个源程序，它的输出作为语法分析程序的输⼊。编译程序结构简洁、清晰和条理化</p></li><li><p>相对独⽴⽅式</p><p>把词法分析程序作为语法分析程序的 ⼀个独⽴⼦程序。语法分析程序需要新符号时调⽤这个⼦程序。优点：避免了中间⽂件⽣成，可以提⾼效率</p></li></ul></li></ol><h2 id="二、词法分析器的设计"><a href="#二、词法分析器的设计" class="headerlink" title="二、词法分析器的设计"></a>二、词法分析器的设计</h2><ol><li><p>词法分析器的结构</p><img alt="image-20191231120446214" style="zoom:40" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gafrwguov1j310u0lsjx6.jpg" class="lazyload"></li><li><p>单词符号的识别：超前搜索。C++语⾔中的“+ +”、“- -”，这种复合成的算符， 需要超前搜索。对于某些语⾔的常数的识别也需要使⽤超前搜索。</p></li><li><p>状态转换图</p><ul><li>⼤多数程序设计语⾔中单词符号的词法规则可以⽤==正规⽂法==描述</li><li>利⽤这些规则==识别单词符号的过程==可⽤⼀张称为==状态转换图==的有限⽅向图来表示，⽽状态转换图识别单词符号的过程⼜可以⽅便地⽤程序实现。</li></ul></li><li><p>对于某⼀符号串β，在状态转换图中，若存在⼀条路产 ⽣β，则称状态转换图接受（或识别）该符号串β，否 则称符号串β不能被接受。</p></li><li><p>能被状态转换图TG接受的符号串的集合记为 L(TG)，称它为==状态转换图所能识别的语⾔==。</p></li><li><p>状态转换图</p><p>有穷自动机可以用<strong>转换图</strong>来表示。</p><p><strong>结点</strong>：有穷自动机 的<strong>状态</strong></p><ul><li>初始状态（开始状态）：只有一个，由 <strong>start 箭头指向</strong></li><li>终止状态：可以由多个，用<strong>双圈</strong>表示（下例中的 3）</li></ul><p>带标记的<strong>有向边</strong>：如果对于<strong>输入 a</strong> ，存在一个从状态 p 到状态 q 的转换，就在 p、q 之间画一条有向边，并标记上 a。</p><p><img alt="image-20191128002520110" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d28lwfx1j316205yq43.jpg" class="lazyload"></p><p>在这个图中，一共有4个状态，分别为状态0，状态1，状态2，状态3。状态0为初始状态，由start箭头指向，状态3为终止状态，用双圈表示。</p></li></ol><h2 id="三、正规表达式-正规式与正规集"><a href="#三、正规表达式-正规式与正规集" class="headerlink" title="三、正规表达式[正规式与正规集]"></a>三、正规表达式[正规式与正规集]</h2><ol><li>学习思路：词法规则 -&gt; NFA -&gt;正规式 DFA -&gt; 词法分析器（Scanner）</li><li>空串是一个正则表达式，那么它所表达的语言也只包括空串。</li><li>字母表上的任何一个符号都是一个正则表达式，那么它所表示的语言只包含它本身。</li><li>假设 r 和 s 都是正则表达式，它们表示的语言分别是 $L(r)$ 和  $L(s)$ ，则:<ul><li>$r|s$ （r 或 s）也是一个正则表达式，它表示的语言是 $L(r|s) = L(r) ∪ L(s)$</li><li>rs（r 和 s 的连接）也是一个正则表达式，它表示的语言是 $L(rs) = L(r)L(s)$</li><li>$r^<em>$（r 的克林闭包）也是一个正则表达式，它表示的语言是也 $L(r^</em>) = (L(r))^*$</li><li>$(r)$ 是一个正则表达式，它表示的语言就是 $L(r)$，即 $L((r))=L(r)$</li></ul></li></ol><img alt="image-20191127234942937" style="zoom:33" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d17haqe3j31680fs0xj.jpg" class="lazyload"><p>例：</p><p>假设符号表中有 a,b。则 a 是一个正则表达式，b 也是一个正则表达式。可以推导出以下的正则表达式：</p><img alt="image-20191127235851699" style="zoom:33" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1h3chy5j315y0gi0x5.jpg" class="lazyload"><p>例：</p><p>描述 C 语言中无符号整数的正则表达式</p><ul><li>十进制整数的正则表达式：第一个符号是1<del>9中的一个数字，接下来连接若干个 0</del>9 的数字，或者连接符号 0。</li><li>八进制整数的正则表达式：<strong>第一个符号是数字0</strong>，第二个符号是1<del>7中的一个数字，接下来连接若干个 0</del>7 中的数字。</li><li>十六进制整数的正则表达式：<strong>第一个符号是0，第二个符号是 x</strong>，第三个符号是 1～f 中的符号，接下来连接若干个 0～f 中的符号。</li></ul><img alt="image-20191128000002054" style="zoom:33" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1i7wi9kj315w0g20wu.jpg" class="lazyload"><ol start="5"><li>正则表达式的代数定律</li></ol><blockquote><p>正则语言：可以用正则表达式定义的语言叫做正则语言或正则集合。</p></blockquote><p>正则表达式也遵循一些<strong>代数定律</strong>，如下图所示：</p><img alt="image-20191128000355664" style="zoom:33" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1mdaijjj315w0g2q76.jpg" class="lazyload"><ol start="6"><li>正则文法与正则表达式等价：</li></ol><ul><li><p>对于任何一个正则文法 G，存在定义同一语言的正则表达式 r。</p></li><li><p>对任何正则表达式 r，存在生成同一语言的正则文法 G。</p></li><li><p>总之，有 G 就有 r ，有 r 就有 G 。</p></li></ul><h2 id="四、有限⾃动机-FA"><a href="#四、有限⾃动机-FA" class="headerlink" title="四、有限⾃动机 (FA)"></a>四、有限⾃动机 (FA)</h2><ol><li>有穷自动机（FA）</li></ol><p>有穷自动机（Finite Automata，FA）由两位神经物理学家Meculoch 和 Pitts 于 1948年提出，是对一类处理系统建立的数学模型。</p><ol start="2"><li>重要的理论基础</li></ol><p>这类系统具有一系列<code>离散的输入输出信息和有穷数目的内部状态</code>。</p><p>系统只需要根据当前所处的状态和当前面临的输入信息，就可以决定系统的<strong>后继行为</strong>。每当系统处理了当前的输入后，系统的<strong>内部状态也将发生改变</strong>。</p><ol start="3"><li>FA 的典型例子</li></ol><p>电梯控制装置</p><ul><li>输入：顾客的<strong>乘梯需求</strong>（所要到达的层号）</li><li>状态：电梯<strong>所处的层数+运动方向</strong></li><li>电梯控制装置<strong>并不需要记住先前全部的服务要求</strong>，只需要知道电梯<strong>当前所处的状态</strong>以及<strong>还没有满足的所有服务请求</strong>。</li></ul><ol start="4"><li>FA 模型</li></ol><p><strong>FA模型</strong>由以下三部分组成：</p><ul><li><p>输入带：用来存放输入符号串</p></li><li><p>读头：<strong>从左向右</strong>逐个读取输入符号，不能修改（只读），不能往返移动</p></li><li><p>有穷控制器：具有有穷个状态数，根据<strong>当前的状态 + 当前输入符号</strong>控制转入<strong>下一状态</strong>。</p></li></ul><p><img alt="image-20191128002151798" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d24xnuskj315w07qaat.jpg" class="lazyload"></p><ol start="5"><li>有限⾃动机=有限控制器+字符输⼊带</li><li></li></ol><h2 id="五、确定有限⾃动机-DFA"><a href="#五、确定有限⾃动机-DFA" class="headerlink" title="五、确定有限⾃动机(DFA)"></a>五、确定有限⾃动机(DFA)</h2><ol><li>DFA定义为一个五元组</li><li>假设字母表中没有 $\varepsilon$</li></ol><img alt="image-20191128003106533" style="zoom:20" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2ejg4ayj315s0cgwjf.jpg" class="lazyload"><p>例：</p><p>在这个有穷自动机DFA 中，</p><p>状态集S 包含4个状态。分别是：状态0， 状态1， 状态2， 状态3。</p><p>输入字母表Σ 中包含的元素是：符号a，符号b。</p><p>转换函数 δ ，我们用一个转换表来表示。</p><p>例：状态0 遇到符号 a 时，变成状态1，状态0 遇到 符号 b 时，依旧是状态 0。以此类推，完成<code>状态转换图-&gt;转换表/转换矩阵(重点考点!!!)</code>。</p><ul><li>3是终止态，用 * 标识。</li></ul><blockquote><p>DFA可以用状态图或转换表两种等价方式来表示。</p></blockquote><p><img alt="image-20191128003129846" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2eyc12zj31480cetbl.jpg" class="lazyload"></p><blockquote><p>DFA 的算法实现</p></blockquote><ul><li><p>输入：以文件结束符 eof 结尾的字符串 x，DFA 的开始状态为 s0，接受状态集 F，转换函数 move</p></li><li><p>输出：如果 D 接受 x，则回答“yes”，否则回答“no”</p></li><li><p>方法：将下述算法应用于输入串 x</p><p><img alt="image-20191128173024112" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dvv3vc2ej30po0eggzw.jpg" class="lazyload"></p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s=s0;</span><br><span class="line">c=nextChar();    <span class="comment">//返回输入串x的下一个符号</span></span><br><span class="line"><span class="keyword">while</span>(c!=eof)</span><br><span class="line">&#123;</span><br><span class="line">    s=<span class="built_in">move</span>(s,c); <span class="comment">//从状态s出发，沿着标记为c的边所能到达的状态</span></span><br><span class="line">    c=nextChar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s在F中)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"yes"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"no"</span>;</span><br></pre></td></tr></table></figure><h2 id="六、⾮确定有限⾃动机-NFA"><a href="#六、⾮确定有限⾃动机-NFA" class="headerlink" title="六、⾮确定有限⾃动机(NFA)"></a>六、⾮确定有限⾃动机(NFA)</h2><ol><li><p>DFA定义为一个五元组</p></li><li><p><strong>同样假设字母表中没有 $\varepsilon$</strong></p></li><li><p>NFA 与 DFA <strong><code>唯一的区别</code>是：从状态 s 出发，能到达的状态可能有多个。（并不是唯一确定的）</strong></p><p><strong>因此，转换函数在转换表里面写的是<code>集合</code>，而不是元素，没有则写空集</strong></p></li></ol><p><img alt="image-20191128011646974" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3q2x2fcj315w0cc78p.jpg" class="lazyload"></p><p>例：</p><p>在这个例子中，在初始状态0，遇到符号 a 的时候，它进入的状态包含状态0和状态1 ，两个元素。在状态0 时，遇到符号 b 时，它进入的状态只有 状态 0，因此集合中只有状态 0 一个元素。</p><p>如果转换函数 <strong>没有给出对应于状态-输入对的信息</strong>，就把<strong>空集放入到相应的表项中。</strong></p><p>例<code>!!!</code></p><p><img alt="image-20191128011817554" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3rmyp15j314c0cugpe.jpg" class="lazyload"></p><blockquote><p>带有 ε边的 NFA</p></blockquote><p>在状态 a，不需要遇到任何符号，即可进入状态 b，在状态 b，不需要任何符号，即可进入状态 c。</p><p>一旦进入状态 b，就不再接受符号 0，同理，一旦进入状态 c，就不在接受符号 1。</p><p>这个带有 空边 的NFA 接受的语言是 由若干个 0 连接 若干个 1 再连接上 若干个 2。（r=0 * 1 * 2*）</p><p><img alt="image-20191128011907201" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3shyfkpj315m0do43u.jpg" class="lazyload"></p><blockquote><p>带有 ε边 和 不带有 ε边 的 NFA的等价性</p></blockquote><ul><li>不带空边的状态 A：由若干个 0 构成</li><li>不带空边的状态 B：由若干个 0 连接若干个 1 构成</li><li>不带空边的状态 C：由若干个 0 连接 若干个 1 连接 若干个 2 构成</li></ul><p>但是状态A,B,C 都可以概括为若干个 0 连接 若干个 1 再连接上 若干个 2 构成。</p><p><img alt="image-20191128012012232" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3tn0qdzj315o0b0tcb.jpg" class="lazyload"></p><p><code>DFA和NFA的等价性(重点考点)</code></p><p>对任何非确定的有穷自动机 NFA，存在定义<strong>同一语言</strong>的确定的有穷自动机 DFA。</p><p>对任何确定的有穷自动机 DFA，存在定义同一语言的非确定的有穷自动机 NFA。</p><blockquote><p>DFA 和 NFA 可以识别相同的语言</p></blockquote><p>这两个 DFA 和 NFA 都识别的是以 abb结尾 的 a,b 串。</p><p><img alt="image-20191128163557050" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9duagii6zj31500cgdjt.jpg" class="lazyload"></p><blockquote><p>等价性<code>(重点考点)</code></p></blockquote><ol><li><p><code>(重点考点)</code>：正则文法(即3型文法，a-&gt;b形式) = 正则表达式(大概是字符串，正则表达式是正则语言更紧凑的表达方式) = 有穷自动机</p></li><li><p>给定==正则文法==，可以构造等价的==有穷自动机==，给定有穷自动机，能够构造出相应的正则文法。</p></li><li><p><code>(重点)</code>：DFA和NFA都可以识别同一种语言，但就在表现形式而言，NFA比DFA更加直观，就计算机实现而言，NFA比DFA更难实现。</p></li><li><p>从<strong>正则表达式</strong>构造<strong>NFA</strong>比较简单，然后再将NFA转换成<strong>DFA</strong></p></li><li><p>带有 ε边 和 不带有 ε边 的 NFA也具有等价性</p></li><li><p><code>NFA转化为DFA!!!</code></p><img alt="image-20200101083027023" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gagrbvoka0j30r614y7ca.jpg" class="lazyload"></li><li><p>习题</p><img alt="image-20200101083053116" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gagrc86i1ij30p60rsjtf.jpg" class="lazyload"></li></ol><h2 id="七、正规式与有限⾃动机的等价性"><a href="#七、正规式与有限⾃动机的等价性" class="headerlink" title="七、正规式与有限⾃动机的等价性"></a>七、正规式与有限⾃动机的等价性</h2><ol><li><p>从 NFA 构造等价的正规式 （状态消去法）<code>!!!</code></p></li><li><p>状态消去法例题</p><img alt="image-20200101083313821" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gagrenwe2uj30m80i4die.jpg" class="lazyload"></li><li><p>随堂练习：NFA-&gt;正规式</p><img alt="image-20200101083406250" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gagrfkclgfj30pm0dawg9.jpg" class="lazyload"></li><li><p>从正规式构造等价的NFA  <code>!!!</code></p><img alt="image-20200101083525266" style="zoom:33%;" data-src="/Users/hamster/Library/Application Support/typora-user-images/image-20200101083525266.png" class="lazyload"></li></ol><h2 id="八、确定有限⾃动机的化简"><a href="#八、确定有限⾃动机的化简" class="headerlink" title="八、确定有限⾃动机的化简"></a>八、确定有限⾃动机的化简</h2><ol><li><p>DFA的化简<code>!!!</code></p><img alt="image-20200101083630583" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gagri3a3vmj30b814qwky.jpg" class="lazyload"></li><li><p>右线性正规⽂法⽣成NFA⽅法<code>!!!</code></p> <img alt="image-20200101083739222" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gagrj9zbtgj30b80lu0vz.jpg" class="lazyload"></li><li><p>DFA产⽣右线性正规⽂法⽅法<code>!!!</code></p><img alt="image-20200101083837581" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gagrkak5aej30ao0z4jvi.jpg" class="lazyload"></li></ol><h2 id="九、词法分析器的⾃动⽣成"><a href="#九、词法分析器的⾃动⽣成" class="headerlink" title="九、词法分析器的⾃动⽣成"></a>九、词法分析器的⾃动⽣成</h2><ol><li><p>词法分析器的⾃动产⽣——LEX</p></li><li><p><strong>正则定义：</strong></p><p>为了方便起见，我们可以给某些<code>正则表达式命名</code>，像使用字母表中的符号一样，使用这些名字来构造正则表达式。（这就是正则定义提出的定义和基本思想）</p><p>正则定义就是给正则表达式命名，右侧是字母表与已定义的正则定义的并集</p><img alt="image-20191128000623988" style="zoom: 67%;" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1p2ykz0j315y0igwm9.jpg" class="lazyload"></li><li><p>对每条识别规则Pi 构造⼀个相应的 NFA 引⼊⼀个新的初态X, 连接成 NFA，⽤⼦集法将其确定化为DFA并化简，将 DFA 转换为词法分析程序</p></li><li><p>匹配最⻓长⼦串(最⻓长匹配原则) &amp;&amp; 多个最⻓长⼦串匹配Pi , 以前⾯的Pi 为准(优先匹配原则)</p><p>最长子串匹配原则：当<strong>输入串的多个前缀与一个或多个模式匹配时</strong>，我们总是<strong>选择最长的前缀</strong>进行匹配。</p><p><img alt="image-20191128003035729" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2e05g95j315y066q44.jpg" class="lazyload"></p><p>对于上图来说，当遇到 &lt; 号时，转换到状态1，当遇到 &lt; = 号时，转换到状态2。</p><p>即：在到达某个<code>终态</code>之后，只要输入带上还有符号，DFA 就<strong>继续前进</strong>，以便找到尽可能长的匹配。</p></li></ol><h1 id="语法分析-自上而下"><a href="#语法分析-自上而下" class="headerlink" title="语法分析[自上而下]"></a>语法分析[自上而下]</h1><h2 id="一、-语法分析器的功能"><a href="#一、-语法分析器的功能" class="headerlink" title="一、 语法分析器的功能"></a>一、 语法分析器的功能</h2><ol><li><p>作用：词法分析的单词符号串-&gt;能否构成语法分析树，属于该语言</p></li><li><p><strong>自上而下</strong>：从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的<strong>最左推导</strong></p><ul><li>LL（1）分析法 </li><li>递归下降分析法 </li><li>预测分析法</li></ul><p><strong>自下而上分析</strong>：从输入符号串开始，逐步进行<strong>归约</strong>（最右推导的逆过程），直至归约到文法的开始符号。</p><ul><li><p>算符优先分析法 </p></li><li><p>LR分析法</p></li></ul></li><li><p>举例：求符号串abcd的推导过程、规约过程</p></li></ol><h2 id="二、自上而下分析方法概述"><a href="#二、自上而下分析方法概述" class="headerlink" title="二、自上而下分析方法概述"></a>二、自上而下分析方法概述</h2><ol><li><p>从文法的开始符号出发，自上而下地为输入串建立一棵<strong>语法树</strong>，即为输入串寻找一个最左推导。</p></li><li><p>自顶向下的分析是指从分析树的顶部（根节点）向底部（叶节点）方向构造分析树，可以看做是从文法<strong>开始符号S</strong>推导出单词串w的过程，例如：</p><p>通过语法分析树可以最终得到id+(id+id)，即将叶子节点连接起来就可以构成id+(id+id)。</p><p>每次推导中都要作两个选择：</p><ul><li>替换哪一个非终结符</li><li>用哪个候选式来替换非终结符</li></ul></li><li><p>自上而下分析方法的问题</p><ul><li>含有左递归的文法将使自上而下的分析过程陷入无限循环</li><li>回溯会引起时间和空间的大量消耗</li></ul></li></ol><h2 id="三、LL-1-分析法"><a href="#三、LL-1-分析法" class="headerlink" title="三、LL(1)分析法"></a>三、LL(1)分析法</h2><ol><li><p>从左(Left)到右扫描输入串；构造<strong>最左(Leftmost) 推导</strong>；分析时每步向前看一个(1)字符。可以构造不带回溯的自上而下分析算法。</p></li><li><p>左递归的消除</p><ul><li>左递归文法：直接左递归、间接左递归</li><li>消除直接左递归：</li><li>消除间接左递归</li></ul></li><li><p>消除回溯，提左因子</p><ul><li>对任非终结符A，用它匹配输入串时能够根据当前输入，准确地指派一个候选式</li><li><img alt="image-20200101182853448" style="zoom:50%;" data-src="/Users/hamster/Library/Application Support/typora-user-images/image-20200101182853448.png" class="lazyload"></li><li>一般地，经过反复提取左因子可把每一个非终 结符的所有候选首符集变成两两不相交。</li></ul></li><li><p>FIRST集合，FOLLOW集合</p><ul><li>FOLLOW集合，可能跟在非终结符后的终结符</li></ul></li><li><p>LL(1)分析条件</p><ul><li><p>文法已经消除了左递归</p></li><li><p>对每个非终结符满足FIRST(αi )∩FIRST(αj ) = Φ</p></li><li><p>对某个输入符号a，及待匹配的非终结符A （A→α 1 │α 2 │… │α n ），a不属于任何候选式的</p></li><li><p>候选式不能都推导出空串</p></li><li><p>可选集互不相交</p><p>FIRST集合，即对任意α i ，a  FIRST (α i )</p></li></ul></li><li><p>LL(1)分析方法</p><p>若A的候选首符集中包含ε，则</p><p>FIRST (A)∩ FOLLOW (A) = Φ</p></li><li><img alt="image-20200102082016321" style="zoom:50%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahwni8iocj30m608gdgr.jpg" class="lazyload"></li></ol><h2 id="四、递归下降分析法"><a href="#四、递归下降分析法" class="headerlink" title="四、递归下降分析法"></a>四、递归下降分析法</h2><ol><li><p>一组递归过程  每个递归过程对应G的一个非终结符</p></li><li><p>从文法开始符号出发，在语法规则(文法产生式)的支配</p><p>下进行语法分析。逐个扫描源程序中的字符(单词符号)， 根据文法和当前输入字符分析到下一个语法成分A时， 便调用识别和分析A的子程序(或其自身)，如此继续下 去。</p></li><li><p> LL(1)分析表（预测分析表）  符号栈（后进先出）  控制程序（表驱动程序）组成。</p></li><li><img alt="image-20200102082952175" style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahwxno1oxj310k0k21gf.jpg" class="lazyload"></li></ol><h2 id="五、预测分析法"><a href="#五、预测分析法" class="headerlink" title="五、预测分析法"></a>五、预测分析法</h2><ol><li><p>递归下降分析器的局限性</p><p>   需要具有能够实现递归过程的语言和编译系统</p></li><li><p>预测分析程序</p><p>  使用一个分析表和符号栈进行联合控制，是实 现LL(1)分析的另一种有效方法。</p></li><li></li></ol><h2 id="六、LL（1）分析中的错误处理"><a href="#六、LL（1）分析中的错误处理" class="headerlink" title="六、LL（1）分析中的错误处理"></a>六、LL（1）分析中的错误处理</h2><h1 id="语法分析-自下而上"><a href="#语法分析-自下而上" class="headerlink" title="语法分析[自下而上]"></a>语法分析[自下而上]</h1><ol><li><p>自下而上分析法就是从输入串开始，逐步进行 “归约”，直至归约到文法的开始符号。</p></li><li><p>从语法树的末端，步步向上“归约”，直到根结。</p></li></ol><h2 id="一、自下而上分析基本问题"><a href="#一、自下而上分析基本问题" class="headerlink" title="一、自下而上分析基本问题"></a>一、自下而上分析基本问题</h2><ol><li><p>自顶向下的语法分析采用<strong>最左推导</strong>方式 </p><p>自底向上的语法分析采用<strong>最左归约</strong>方式（最右推导的逆过程，即<strong>规范规约</strong>）</p></li><li><p>自底向上语法分析的通用框架：移入-归约分析(Shift-Reduce Parsing)</p><p>使用一个符号栈，把输入符号逐一移进栈，当 栈顶形成某个产生式右部时，则将栈顶的这一 部分替换（归约）为该产生式的左部符号。</p></li><li><p>每次归约的符号串称为“句柄”，保证最左规约</p></li><li><p>栈内符号串 + 剩余输入 =“<strong>规范句型</strong>”</p></li><li><p><strong>句柄</strong>：句型的最左直接短语；直接短语是某个产生式的右部，但产生式的右部不一定是直接短语</p></li><li><p><strong>子树、短语、直接短语、句柄</strong></p></li><li><p>给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个<code>短语</code>。</p><p>如果子树只有父子两代节点，那么这课子树的边缘称为该句型的一个<code>直接短语</code>。</p><p><strong>直接短语一定是产生式的右部，但产生式的右部不一定是给定句型的直接短语，但可能是其他句型的直接短语</strong></p></li><li><p>每次规约的都是一个直接短语，而且是最左直接短语</p></li><li><p>二义性文法的句柄可能不唯一</p></li></ol><h2 id="二、规范规约"><a href="#二、规范规约" class="headerlink" title="二、规范规约"></a>二、规范规约</h2><ol><li><p>规范规约（最左规约）：将句柄替换成相应产生左部符号而得到的，<strong>最左归约</strong>方式（最右推导的逆过程，即<strong>规范规约</strong>），可规约串：句柄</p></li><li><p>移入-规约过程</p><img alt="image-20200101211500840" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahdfan7g8j30ks0emtb8.jpg" class="lazyload"></li></ol><h2 id="三、算符优先分析方法"><a href="#三、算符优先分析方法" class="headerlink" title="三、算符优先分析方法"></a>三、算符优先分析方法</h2><ol><li>定义<strong>终结符</strong>的优先关系，按终结符的优先关系控制自下而上语法分析过程（寻找“可归约串”和进行归约）</li><li><strong>不是规范归约</strong>，但分析速度快，适于表达式的语法分析</li><li>体现了相邻的两个终结符之间在<strong>归约</strong>上的的优先关系</li><li><strong>算符文法</strong>：一个文法，如果它的任一产生式右部都不 含两个相继（并列）的非终结符，即不含 如下形式的产生式右部</li><li>算符间的优先关系定义，后面的优先级大</li><li><strong>构造优先关系表</strong>方法：通过检查G的每个产生式的每个候选式，可找出 所有满足a = b的终结符对。确定满足关系 &lt; 和 &gt; 的所有终结符对[ FIRSTVT(P)和LASTVT(P) ]</li><li>空格子：不能进行算符优先比较</li><li><strong>最左素短语</strong>—算符优先分析中的可归约串</li></ol><h2 id="四、LR分析方法"><a href="#四、LR分析方法" class="headerlink" title="四、LR分析方法"></a>四、LR分析方法</h2><ol><li>LR文法(Knuth, 1963) 是最大的、可以构造出相应<strong>移入-归约语法分析器</strong>的文法类；k = 0 和 k = 1 这两种情况具有实践意义 当省略(k)时，表示k =1</li><li>LR分析器基于这样一些状态来构造自动机进行句柄的识别（移进状态，待约状态，归约状态）</li><li>LR分析法是<strong>严格的规范规约</strong>。</li><li>LR分析法手工构造分析程序工作量相当大。YACC是一个<strong>语法分析程序</strong>的自动生成器。</li><li>所有的LR分析器相同，<strong>分析表</strong>: 是自动生成语法分析器的关键，<strong>LR分析器的核心</strong>是一张分析表<ul><li>LR (0) 表：基础、有局限性 </li><li>SLR表：简单LR表，实用</li><li>规范LR表：能力强、代价大</li><li>LALR表：向前LR表，介于SLR和规范LR之间</li></ul></li><li>增广文法：引入这个新的开始产生式的目的是使得文法开始符号仅出现 在一个产生式的左边，从而使得分析器只有一个接受状态</li><li>初始项目、接收项目、归约项目、后继项目</li><li>可以把等价的项目组成一个项目集( I ) ，称为项目集闭包 (Closure of Item Sets)，每个项目集闭包对应着自动机的一个状态</li><li>文法-&gt;LR(0)自动机，要构造closer()函数</li><li>如果LR(0)分析表中 没有语法分析动作冲 突，那么给定的文法 就称为LR(0)文法</li><li>不是所有<strong>上下文无关文法</strong>都能用LR(0)方法进行分析，也就是说，CFG不总是LR(0)文法</li><li>活前缀: 规范句型的一个前缀，前缀的尾符号最多包含到 句型的句柄，即这种前缀不含句柄之后的任何符号（可归 前缀）；在LR分析工作过程的任何时候，栈里的文法符号（自栈 底向上）应该构成活前缀。对于一个文法G，可以构造一个识别G的所有活前缀有限 自动机，并以此构造LR分析表。</li></ol><blockquote><p>LR（0）方法</p></blockquote><ol><li><p>方法一：识别活前缀的NFA方法</p></li><li><p>方法二： LR(0)项目集规范族</p></li><li><p>拓广文法会有一个仅含项目S ¢ →S·的状态，这就 是唯一的“接受”态。</p></li><li><p>项目集I的闭包CLOSURE(I)；状态转换函数GO(I，X)</p></li><li><p>重点题目<code>!!!</code></p><p><img alt="image-20200102015731915" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahll9trd4j30m208c75p.jpg" class="lazyload"></p></li><li><p>例题：</p><img alt="image-20200102020220264" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahlq97apmj30fm08aabj.jpg" class="lazyload"></li><li><p>例题：</p><img alt="image-20200102021905163" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahm7txdbjj30m20w2dnl.jpg" class="lazyload"></li><li></li></ol><h2 id="语义分析和中间代码的生成"><a href="#语义分析和中间代码的生成" class="headerlink" title="语义分析和中间代码的生成"></a>语义分析和中间代码的生成</h2><ol><li><p>属性、语义规则、属性文法[ 每个文法符号联系于一组属性，且对每个产生式都给</p><p>出其语义规则的文法称为属性文法 ]</p></li><li><p>属性的分类：综合属性、继承属性</p></li><li><p>S -&gt; 属性文法：仅仅使用综合属性的属性文法</p></li><li><p>L属性文法，每个属性必须要么是一个综合属性要么是一个继承属性。，S属于L属性文法</p></li><li><img alt="image-20200102034119895" style="zoom:33%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaholgkj6sj30m80dyq5c.jpg" class="lazyload"></li><li><img alt="image-20200102055118642" style="zoom:50%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahsci7aktj30f0186n65.jpg" class="lazyload"></li></ol><h1 id="目标代码的生成"><a href="#目标代码的生成" class="headerlink" title="目标代码的生成"></a>目标代码的生成</h1><ol><li><p>代码⽣成是把语法分析后或优化后的中间代码 变换成⽬标代码。</p><p>代码⽣成着重考虑的问题</p><ul><li><p>如何使⽣成的⽬标代码较短；</p></li><li><p>如何充分利⽤计算机的寄存器，减少⽬标代码中 访问存贮单元的次数。</p></li><li><p>如何充分利⽤计算机的指令系统的特点排序。</p></li></ul></li><li><p>考虑问题：指令选择、寄存器分配、计算顺序选择</p></li><li><p>⽬标机器模型：具有多个通⽤寄存器，他们既可以作为累加器， 也可以作为变址器；运算必须在某个寄存器中进⾏；含有四种类型的指令形式</p></li><li><img alt="image-20200102072110982" style="zoom:50%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahuy0ep49j30ko0ds45m.jpg" class="lazyload"></li><li><p>⼀个简单代码⽣成器</p><p>四元式的中间代码变换成⽬标代码，并在⼀个基 本块的范围内考虑如何充分利⽤寄存器：</p><ul><li><p>尽可能留：在⽣成计算某变量值的⽬标代码 时，尽可能让该变量保留在寄存器中。</p></li><li><p>尽可能⽤：后续的⽬标代码尽可能引⽤变量在 寄存器中的值，⽽不访问内存。</p></li><li><p>及时腾空：在离开基本块时，把存在寄存器中 的现⾏的值放到主存中。</p></li></ul></li><li><p>寄存器描述符RVALUE[R]={A,B}、寄存器描述符AVALUE[A]={R1, R2, A}</p></li><li><img alt="image-20200102073255224" style="zoom:50" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahva81vutj30su16m11f.jpg" class="lazyload"></li><li><p>写出基本块对应的⽬标代码</p></li></ol><img alt="image-20200102073530866" style="zoom: 67" data-src="/Users/hamster/Library/Application Support/typora-user-images/image-20200102073530866.png" class="lazyload">]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理PPT复习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络MOOC</title>
      <link href="/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CMOOC/"/>
      <url>/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CMOOC/</url>
      
        <content type="html"><![CDATA[<p>[参考连接 by Github]([<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md]" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md]</a>(<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/计算机网络</a> - 目录.md))</p><h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p><div align="center"> <img width="450" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/network-of-networks.gif" class="lazyload"> </div><br>## ISP<p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><div align="center"> <img width="500" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72be01cd-41ae-45f7-99b9-a8d284e44dd4.png" class="lazyload"> </div><br>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。<div align="center"> <img width="500" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3be42601-9d33-4d29-8358-a9d16453af93.png" class="lazyload"> </div><br>## 主机之间的通信方式<ul><li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li></ul><div align="center"> <img width="240px" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" class="lazyload"> </div><br>- 对等（P2P）：不区分客户和服务器。<div align="center"> <img width="200px" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" class="lazyload"> </div><br>## 电路交换与分组交换<h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1. 电路交换"></a>1. 电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p><h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2. 分组交换"></a>2. 分组交换</h3><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，<strong>在同一个传输线路上同时传输多个分组互相不会影响</strong>，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p><p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是<strong>存储转发过程</strong>，分组交换也使用了存储转发过程。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><div align="center"> <img width="380" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg" class="lazyload"> </div><br>### 1. 排队时延<p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p><h3 id="2-处理时延"><a href="#2-处理时延" class="headerlink" title="2. 处理时延"></a>2. 处理时延</h3><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p><h3 id="3-传输时延"><a href="#3-传输时延" class="headerlink" title="3. 传输时延"></a>3. 传输时延</h3><p>主机或路由器传输数据帧所需要的时间。</p><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?delay=\frac{l(bit)}{v(bit/s)}" class="mathjax-pic"/></div> <br> --><div align="center"> <img width="150px" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dcdbb96c-9077-4121-aeb8-743e54ac02a4.png" class="lazyload"> </div><br><p>其中 l 表示数据帧的长度，v 表示传输速率。</p><h3 id="4-传播时延"><a href="#4-传播时延" class="headerlink" title="4. 传播时延"></a>4. 传播时延</h3><p>电磁波<strong>在信道中</strong>传播所需要花费的时间，电磁波传播的速度接近光速。</p><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?delay=\frac{l(m)}{v(m/s)}" class="mathjax-pic"/></div> <br> --><div align="center"> <img width="150" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a1616dac-0e12-40b2-827d-9e3f7f0b940d.png" class="lazyload"> </div><br>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><div align="center"> <img width="450" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" class="lazyload"> </div><br>### 1. 五层协议<ul><li><p><strong>应用层</strong>  ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p></li><li><p><strong>传输层</strong>  ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p></li><li><p><strong>网络层</strong>  ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报<strong>封装成分组</strong>。</p></li><li><p><strong>数据链路层</strong>  ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为<strong>同一链路的主机</strong>提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p></li><li><p><strong>物理层</strong>  ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></li></ul><h3 id="2-OSI"><a href="#2-OSI" class="headerlink" title="2. OSI"></a>2. OSI</h3><p>其中表示层和会话层用途如下：</p><ul><li><p><strong>表示层</strong>  ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p></li><li><p><strong>会话层</strong>  ：建立及管理会话。</p></li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="3-TCP-IP"><a href="#3-TCP-IP" class="headerlink" title="3. TCP/IP"></a>3. TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，<strong>应用层可能会直接使用 IP 层或者网络接口层</strong>。</p><div align="center"> <img width="250" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" class="lazyload"> </div><br>### 4. 数据在各层之间的传递过程<p>在向下的过程中，需要<strong>添加</strong>下层协议所需要的首部或者尾部，而在向上的过程中不断<strong>拆开</strong>首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要<strong>传输层和应用层</strong>。[五层]</p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h2 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h2><p>模拟信号是连续的信号，数字信号是离散的信号。<strong>带通调制</strong>把数字信号转换为模拟信号。</p><div align="center"> <img width="500" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c34f4503-f62c-4043-9dc6-3e03288657df.jpg" class="lazyload"> </div><br><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记<strong>帧的开始和结束</strong>。</p><div align="center"> <img width="300" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/29a14735-e154-4f60-9a04-c9628e5d09f4.png" class="lazyload"> </div><br>### 2. 透明传输<p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入<strong>转义字符</strong>。如果数据部分出现转义字符，那么就在<strong>转义字符前面再加个转义字符</strong>。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><div align="center"> <img width="500" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" class="lazyload"> </div><br>### 3. 差错检测<p>目前数据链路层广泛使用了<strong>循环冗余检验（CRC）</strong>来检查比特差错。</p><h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><h3 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在<strong>同一个广播信道</strong>上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用<strong>信道复用技术</strong>，一是使用 <strong>CSMA/CD 协议</strong>。</p><h3 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2. 点对点信道"></a>2. 点对点信道</h3><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 <strong>PPP 协议</strong>进行控制。</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="1-频分复用"><a href="#1-频分复用" class="headerlink" title="1. 频分复用"></a>1. 频分复用</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><div align="center"> <img width="350" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" class="lazyload"> </div><br>### 2. 时分复用<p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><div align="center"> <img width="350" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" class="lazyload"> </div><br>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。<h3 id="3-统计时分复用"><a href="#3-统计时分复用" class="headerlink" title="3. 统计时分复用"></a>3. 统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><div align="center"> <img width="350" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6283be2a-814a-4a10-84bf-9592533fe6bc.png" class="lazyload"> </div><br>### 4. 波分复用<p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="5-码分复用"><a href="#5-码分复用" class="headerlink" title="5. 码分复用"></a>5. 码分复用</h3><p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <img class="mathjax-pic lazyload" data-src="https://latex.codecogs.com/gif.latex?\vec{S}"> 和 <img class="mathjax-pic lazyload" data-src="https://latex.codecogs.com/gif.latex?\vec{T}"> 有</p><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{T}=0" class="mathjax-pic"/></div> <br> --><div align="center"> <img width="100px" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/308a02e9-3346-4251-8c41-bd5536dab491.png" class="lazyload"> </div><br>为了讨论方便，取 m=8，设码片 <img class="mathjax-pic lazyload" data-src="https://latex.codecogs.com/gif.latex?\vec{S}"> 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。<p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S}=1" class="mathjax-pic"/></div> <br> --><!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S'}=-1" class="mathjax-pic"/></div> <br> --><div align="center"> <img width="100px" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6fda1dc7-5c74-49c1-bb79-237a77e43a43.png" class="lazyload"> </div><br><div align="center"> <img width="125px" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e325a903-f0b1-4fbd-82bf-88913dc2f290.png" class="lazyload"> </div><br>其中 <img class="mathjax-pic lazyload" data-src="https://latex.codecogs.com/gif.latex?\vec{S'}"> 为 <img class="mathjax-pic lazyload" data-src="https://latex.codecogs.com/gif.latex?\vec{S}"> 的反码。<p>利用上面的式子我们知道，当接收端使用码片 <img class="mathjax-pic lazyload" data-src="https://latex.codecogs.com/gif.latex?\vec{S}"> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p><p>码分复用需要发送的数据量为原先的 m 倍。</p><div align="center"> <img width="500px" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99b6060e-099d-4201-8e86-f8ab3768a7cf.png" class="lazyload"> </div><br><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><strong>多点接入</strong>  ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li><strong>载波监听</strong>  ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong>  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong>  。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用   <strong>截断二进制指数退避算法</strong>   来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><div align="center"> <img width="400" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/19d423e9-74f7-4c2b-9b97-55890e0d5193.png" class="lazyload"> </div><br>## PPP 协议<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><div align="center"> <img width="300" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1ab9f28-cb15-4178-84b2-98aad87f9bc8.jpg" class="lazyload"> </div><br>PPP 的帧格式：<ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><div align="center"> <img width="400" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/759013d7-61d8-4509-897a-d75af598a236.png" class="lazyload"> </div><br>## MAC 地址<p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><div align="center"> <img width="800" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/807f4258-dba8-4c54-9c3c-a707c7ccffa2.jpg" class="lazyload"> </div><br>## 以太网<p>以太网是一种星型拓扑结构局域网。</p><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><p>以太网帧格式：</p><ul><li><strong>类型</strong>  ：标记上层使用的协议；</li><li><strong>数据</strong>  ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong>  ：帧检验序列，使用的是 CRC 检验方法；</li></ul><div align="center"> <img width="500" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/164944d3-bbd2-4bb2-924b-e62199c51b90.png" class="lazyload"> </div><br>## 交换机<p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p><p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><div align="center"> <img width="800" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png" class="lazyload"> </div><br>## 虚拟局域网<p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p><p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p><p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p><div align="center"> <img width="500" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98e9d20-206b-4533-bacf-3448d0096f38.png" class="lazyload"> </div><br><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p><code>Socket没有？服务器并发没有</code></p><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p><p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><div align="center"> <img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b54eeb16-0b0e-484c-be62-306f57c40d77.jpg" class="lazyload"> </div><br>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：<ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><h2 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h2><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p><ul><li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li>数据连接：用来传送一个文件数据。</li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><ul><li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li></ul><div align="center"> <img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/03f47940-3843-4b51-9e42-5dcaff44858b.jpg" class="lazyload"> </div><br>- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。<div align="center"> <img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg" class="lazyload"> </div><br>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。<h2 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h2><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><p>DHCP 工作过程如下：</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li><li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li><li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ol><div align="center"> <img data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg" class="lazyload"> </div><br>## 远程登录协议<p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p><p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><div align="center"> <img width="700" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b3efa99-d306-4982-8cfb-e7153c33aab4.png" class="lazyload"> </div><br>### 1. SMTP<p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p><div align="center"> <img width data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed5522bb-3a60-481c-8654-43e7195a48fe.png" class="lazyload"> </div><br>### 2. POP3<p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p><h3 id="3-IMAP"><a href="#3-IMAP" class="headerlink" title="3. IMAP"></a>3. IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p><h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">端口号</th><th align="center">传输层协议</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">域名解析</td><td align="center">DNS</td><td align="center">53</td><td align="center">UDP/TCP</td><td align="center">长度超过 512 字节时使用 TCP</td></tr><tr><td align="center">动态主机配置协议</td><td align="center">DHCP</td><td align="center">67/68</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">简单网络管理协议</td><td align="center">SNMP</td><td align="center">161/162</td><td align="center">UDP</td><td align="center"></td></tr><tr><td align="center">文件传送协议</td><td align="center">FTP</td><td align="center">20/21</td><td align="center">TCP</td><td align="center">控制连接 21，数据连接 20</td></tr><tr><td align="center">远程终端协议</td><td align="center">TELNET</td><td align="center">23</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">超文本传送协议</td><td align="center">HTTP</td><td align="center">80</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">简单邮件传送协议</td><td align="center">SMTP</td><td align="center">25</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">邮件读取协议</td><td align="center">POP3</td><td align="center">110</td><td align="center">TCP</td><td align="center"></td></tr><tr><td align="center">网际报文存取协议</td><td align="center">IMAP</td><td align="center">143</td><td align="center">TCP</td><td align="center"></td></tr></tbody></table><h2 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h2><h3 id="1-DHCP-配置主机信息"><a href="#1-DHCP-配置主机信息" class="headerlink" title="1. DHCP 配置主机信息"></a>1. DHCP 配置主机信息</h3><ul><li><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p></li><li><p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p></li><li><p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p></li><li><p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF，将广播到与交换机连接的所有设备。</zero-width></zero-width></zero-width></zero-width></p></li><li><p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p></li><li><p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p></li><li><p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p></li></ul><h3 id="2-ARP-解析-MAC-地址"><a href="#2-ARP-解析-MAC-地址" class="headerlink" title="2. ARP 解析 MAC 地址"></a>2. ARP 解析 MAC 地址</h3><ul><li><p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p></li><li><p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p></li><li><p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p></li><li><p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p></li><li><p>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p></li><li><p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</zero-width></zero-width></zero-width></zero-width></p></li><li><p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p></li></ul><h3 id="3-DNS-解析域名"><a href="#3-DNS-解析域名" class="headerlink" title="3. DNS 解析域名"></a>3. DNS 解析域名</h3><ul><li><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p></li><li><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p></li><li><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p></li><li><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p></li><li><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p></li></ul><h3 id="4-HTTP-请求页面"><a href="#4-HTTP-请求页面" class="headerlink" title="4. HTTP 请求页面"></a>4. HTTP 请求页面</h3><ul><li><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p></li><li><p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p></li><li><p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p></li><li><p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p></li><li><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p></li><li><p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络MOOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长短句</title>
      <link href="/2019/11/26/%E9%95%BF%E7%9F%AD%E5%8F%A5/"/>
      <url>/2019/11/26/%E9%95%BF%E7%9F%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-11"><a href="#2019-11" class="headerlink" title="2019-11"></a>2019-11</h1><ol><li>精卫衔微木，将以填沧海。   ———— 陶渊明《读〈山海经〉·精卫衔微木》</li><li>敏而好学，不耻下问。      ———— 《论语·公冶长》</li><li>过而不改，是谓过矣。    ————《论语·卫灵公》</li><li>德荡乎名，知出乎争。<br>— ———《庄子·人间世》</li></ol><h1 id="2019-12"><a href="#2019-12" class="headerlink" title="2019-12"></a>2019-12</h1><ol><li>非淡泊无以明志，非宁静无以致远  一一一一诸葛亮《诫子书》</li><li>Both the conversations and the questions will be spoken only once.  一一一一英语六级考试</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文哲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长短句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络实验报告</title>
      <link href="/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
      <url>/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="9-1-异步串行传输实验"><a href="#9-1-异步串行传输实验" class="headerlink" title="[9.1]异步串行传输实验"></a>[9.1]异步串行传输实验</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">异步串行实验</td><td align="center">2019-10-30</td></tr></tbody></table><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>本实验是有关OSI模型物理层的实验，通过串⼝的字符收发，加深对通信基本原理的理解。</p><ol><li><p>理解通信基本原理；</p></li><li><p>理解异步串⾏传输的基本概念；</p></li><li><p>了解掌握RS－232接⼝标准以及RS-232帧格式；</p></li><li><p>了解通信双⽅参数匹配是正常通信的基本保证，了解波特率等主要通信参数含义。</p></li></ol><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><ol><li>实验环境主要由两台带<strong>COM</strong>口的计算机，一根串行交叉线组成；</li><li>将单根串行交叉线中间层组成。将单根串行交叉线将两个计算机的<strong>COM</strong>串口对接起来；</li><li>两台计算机超级终端将作为路由器管理的操作平台</li></ol><h2 id="实验网络拓扑"><a href="#实验网络拓扑" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191126185241335" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bn043xicj30te05w3ym.jpg" class="lazyload"></p><p>​    异步串行通信实验拓扑结构如上图所示，实验环境主要由两台带COM口的计算机和一根串行交叉线组成。将单根串行交叉线将两个计算机的COM串口对接起来；两台计算机超级终端将作为路由器管理的操作平台。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><blockquote><p>一、异步串行通信原理</p></blockquote><ol><li><p>串行方式：任何通信用户单独只能占用一条通信线路。</p></li><li><p>串行传输：串行传输结构示意图如下图所示，每次只能传输一个数位，0或1。</p><p><img alt="img" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bnchjolaj305o041web.jpg" class="lazyload"></p></li><li><p>串行通信：在数据通信中，将传送的每个字符的二进制代码按照顺序依次发送的方式称为串行通信。串行通信方式广泛应用在远程通信中。</p></li><li><p>串行传输模式在实际运用中，又分为同步传输模式和异步传输模式。</p><ul><li><p>同步传输模式：要求通信的收发双方在时间基准上保持一致。</p></li><li><p>异步传输模式：接发两端使用不固定的时间模式，传输前也不需要协调，只要直接发送，不需要对方作为应答，但必须在传输两个数据包之间加入间隔符号，作为分隔。</p></li></ul></li><li><p>常用的串行通信接口标准包括RS-232、RS-449、V.24、V.35等。其中，RS-232是最常用的串行通信标准之一。</p></li></ol><blockquote><p>二、RS232接口</p></blockquote><ol><li>RS232接口是1970年由美国电子工业协会（EIA）联合贝尔系统、调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标准。</li><li>主要内容：定义数据终端设备DTE（data terminal equipment）和数据通信设备DCE（data circuit equipment）之间的接口标准。</li><li>RS-232传输对象是字符，每次传输一个字符，计算机内部所有的数据都使用二进制，需要规定二进制数字表示哪个符号，称编码标准，现在我们字符使用的标准是ASCII编码。</li></ol><blockquote><p>三、ASCII码表</p></blockquote><ol><li>ASCII(American Standard Code for Information Interchange)，美国信息交换标准代码,是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，使用一个字（byte）来表示英语字母，比如，字母a,十进制编码值是97，二进制是0110 0001，一般用十六进制来表示，0x61，0x是16进制的前缀，ASCII编码详见附件。</li></ol><blockquote><p>四、S232数据桢格式</p></blockquote><ol><li><p>RS232在传输一个字符时，将字符转换成ASCII码，并组织成RS232数据桢进行传输</p></li><li><p>RS232数据桢格式：</p><ul><li>起始位为0，以一位低电平开始，表示发送端开始发送一帧数据；</li><li>数据位，字符的ASCII码，一般低位在前，高位在后，数据位长度一般为8位；</li><li>校验位，用于校验数据的正确性，使用奇校验或者偶校验；</li><li>停止位为1，一帧信息已经发送完毕，长度一般为1~2位；</li><li>空闲位：空闲位也为1，用于通知接受端等待下一个数据帧的传输；一旦开始传输下一个字符，发出新的开始位。</li><li>RS232数据桢格式如下图所示：</li></ul><p><img alt="image-20191126192641093" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bnzhpqplj30qa034ta0.jpg" class="lazyload"></p></li></ol><blockquote><p>五、波特率</p></blockquote><ol><li><strong>波特率</strong>：也称调制速率，指<u>单位时间内通信信号变化的次数</u>，它同时间模式中的时间间隔长度刚好成反比关系。</li><li>波特率决定着每个数位的传输速率，显然，涉及到接发两端的两个设备配置，为保证两者在发送信号和检测信号时的时间同步，就必须设置成相同的波特率。</li><li>发送设备和接收设备采用相同波特率称之为<u>波特率匹配</u>。如果接发双方baud rate波特率不匹配就会发生错误, 称之为<u>帧错误</u>。</li></ol><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、实验概述</p></blockquote><p>使用超级终端进行两台计算机之间的串行通信，一端从键盘输入字符发送，另一端观看接收到的内容。主要实验内容：</p><ol><li><p>测试相同通信参数下的通信，进行相互间的字符接发送；</p></li><li><p>测试不同波特率条件下的通信，其他参数保持相同，进行相互间的字符接发送；通过相互传输字符，来检测通信参数的匹配。</p></li></ol><blockquote><p>二、实验步骤</p></blockquote><p>【准备过程】</p><ol><li>按照实验拓扑结构要求将两台计算机的COM口用串口反接连接线连接起来。  </li><li>Host1：运行超级终端，建⽴串⼝通信连接test1，设置缺省通信参数。  </li><li>Host2：运行超级终端，建⽴串⼝通信连接test2，设置缺省通信参数。  </li></ol><p>【实验一】：测试在相同通信参数下的字符传输</p><ol><li><p>Host2的超级终端输⼊如下内容，此时Host2超级终端无内容显示</p><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">hhh2</span><br></pre></td></tr></table></figure></li><li><p>Host1的超级终端接收到如下字符串</p><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">hhh2</span><br></pre></td></tr></table></figure></li></ol><p>【实验二】：测试采用不同波特率下的字符传输  </p><ol><li><p>Host1和Host2均断开连接，在“文件-&gt;属性-&gt;配置”中修改参数如下：</p><table><thead><tr><th align="center">连接名</th><th align="center">波特率</th><th align="center">数据位</th><th align="center">奇偶校验</th><th align="center">停止位</th></tr></thead><tbody><tr><td align="center">test1</td><td align="center">4800</td><td align="center">8</td><td align="center">奇校验</td><td align="center">1</td></tr><tr><td align="center">test2</td><td align="center">9600</td><td align="center">8</td><td align="center">奇校验</td><td align="center">1</td></tr></tbody></table></li><li><p>进行通信测试。首先在Host1终端从键盘键入以下字符串，Host1屏幕上并不会显示输入内容，Host2屏幕上显示乱码。</p><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> <span class="number">35</span> <span class="number">46</span> <span class="number">77</span></span><br></pre></td></tr></table></figure></li><li><p>在Host2终端从键盘键入以下字符串，Host2屏幕上并不会显示输入内容，Host1屏幕上显示不同乱码。</p><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> <span class="number">35</span> <span class="number">46</span> <span class="number">77</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实验问题与结果分析"><a href="#实验问题与结果分析" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><ol><li><p>实验1中，两台计算机的通信参数相同，波特率匹配，不会发⽣帧错误，因此字符传输正常。</p></li><li><p>实验2中，两台计算机的波特率不同，则它们单位时间内通信信号发⽣变化的次数不同，相应的检测信号的间隔也不一致，因此两台计算机显示出乱码且乱码值不同。</p></li><li><p>这个实验比较简单，是后面实验的基础，也让我初步掌握了一些使用超级终端的基本方法。通过动手操作串⼝的字符接收和发送，加深了对通信基本原理的理解。在理解通信基本原理和异步串⾏传输的基础上，进一步掌握RS－232接⼝标准以及RS-232帧格式，通过实验一和实验二的具体操作切实理解了通信双⽅参数匹配是正常通信的基本保证，明白了波特率等主要通信参数含义。</p></li></ol><h1 id="9-2-VLAN-基本操作实验"><a href="#9-2-VLAN-基本操作实验" class="headerlink" title="[9.2]VLAN 基本操作实验"></a>[9.2]VLAN 基本操作实验</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">VLAN基本操作实验</td><td align="center">2019-10-30</td></tr></tbody></table><h2 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>了解和掌握VLAN基本概念和操作</li></ul><ul><li>了解虚拟局域网的基本概念</li><li>掌握交换机实施虚拟局域网技术</li></ul><h2 id="实验设备-1"><a href="#实验设备-1" class="headerlink" title="实验设备"></a>实验设备</h2><ol><li>一台<em>CISCO</em>交换机和两台计算机担当实验设备，使用两根双绞线网线，将两台计算机以太网网卡通交换机连接起来</li><li>通过串行线将计算机<em>Host 1</em>串口<em>COM 1</em>同交换机<em>CONSOLE</em>口连接起来，使用超级终端作为交换机的操作平台。</li></ol><h2 id="实验网络拓扑-1"><a href="#实验网络拓扑-1" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191126210550455" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bqunjs6rj30wk0a4q3k.jpg" class="lazyload"></p><h2 id="实验原理-1"><a href="#实验原理-1" class="headerlink" title="实验原理"></a>实验原理</h2><ol><li>VLAN是通过软件把网络按<u>逻辑</u>分组，不受物理上交换机端口所限制，把不同地理位置的主机分割到相同VLAN内，VLAN是在交换机上实现。</li><li>VLAN能够解决<u>广播风暴</u>问题。交换机的每个端口是一个冲突域，但不能隔离广播，而一个VLAN就是一个广播域。</li></ol><h2 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>实验概要</p></blockquote><p>使用<em>CISCO</em>交换机作为实验设备，将交换机划分成三个<em>VLAN</em>，<em>VLAN 1</em>包含端口1 ~ 8，<em>VLAN 2</em>包含端口9 ~ 16，<em>VLAN 3</em>包含其余端口，连台计算机作为测试平台，设置成同一个子网<em>IP</em>地址。</p><ol><li>使用<em>Host 1<em>超级终端为交换机配置</em>VLAN</em></li><li>为<em>Host 1</em>和<em>Host 2</em>以太网网卡配置同子网<em>IP</em>地址。</li><li>然后用双绞线将两个网卡连接到交换机端口上，不断变换交换机端口，测试连通状况。（位于同一个<em>VLAN</em>时，两个主机将会连通；位于不同<em>VLAN</em>两个主机将无法连通）</li></ol><blockquote><p>一、未配置前端⼝通信实验</p></blockquote><ol><li><p>配置两主机IP地址: 192.168.0.2 及 192.168.0.5</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.0.2 连接到交换机的端⼝:1</span><br><span class="line">192.168.0.5 连接到交换机的端⼝:24</span><br></pre></td></tr></table></figure></li><li><p>测试192.168.0.2: ping 192.168.0.5，可连通192.168.0.2 和 192.168.0.5 </p></li></ol><blockquote><p>二、配置VLAN2</p></blockquote><ol><li><p>连接交换机，使用console线将计算机串口com2与路由器console口直接相连；</p></li><li><p>建立HyperTerminal：开始 -&gt; 程序 -&gt; 附件 -&gt; 通讯 -&gt; 超级终端 -&gt; 名称=<strong>switch</strong> -&gt; 连接=<strong>com2</strong> -&gt; (波特率)Baut Rate=<strong>9600</strong>,8,no parity, 1 stop bit；</p></li><li><p>进入特权模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch01&gt; en(able) </span><br><span class="line"><span class="built_in">pwd</span> = cisco //输入密码</span><br></pre></td></tr></table></figure></li><li><p>查看VLAN配置，可查看到当前所有端口以及VLAN的配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch01<span class="comment">#sh vlan</span></span><br></pre></td></tr></table></figure></li><li><p>建立VLAN2和VLAN3</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入VLAN配置模式</span><br><span class="line">switch01<span class="comment">#vlan database </span></span><br><span class="line">// 建⽴VLAN2</span><br><span class="line">switch01(vlan)<span class="comment">#vlan 2 name vlan2</span></span><br><span class="line">// 建⽴VLAN3</span><br><span class="line">switch01(vlan)<span class="comment">#vlan 3 name vlan3</span></span><br><span class="line">// 退出</span><br><span class="line">switch01(vlan)<span class="comment">#exit</span></span><br></pre></td></tr></table></figure></li><li><p>为VLAN2分配端口f0/1，最终通过查看VLAN2配置观察是否成功分配，注意要先两次exit才能退出配置模式进行查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">switch01<span class="comment">#config t</span></span><br><span class="line">// 进入f0/1端口</span><br><span class="line">switch01(config)<span class="comment">#in f0/1</span></span><br><span class="line">// 将端口f0/1分配给vlan2</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#switchport access vlan 2</span></span><br><span class="line">// 退出，使得配置生效</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#exit</span></span><br><span class="line">switch01(config)<span class="comment">#exit</span></span><br><span class="line">// 查看VLAN2配置，VLAN2被成功分配了端口f0/1</span><br><span class="line">switch01<span class="comment"># sh vlan name vlan2</span></span><br></pre></td></tr></table></figure></li><li><p>测试192.168.0.2: ping 192.168.0.5 ，不可连通</p></li><li><p>为VLAN2分配新端口f0/24，最终通过查看VLAN2配置观察是否成功分配</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">switch01<span class="comment">#config t</span></span><br><span class="line">// 进入f0/24端口</span><br><span class="line">switch01(config)<span class="comment">#in f0/24</span></span><br><span class="line">// 将端口f0/24分配给vlan2</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#switchport access vlan 2</span></span><br><span class="line">// 退出，使得配置生效</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#exit</span></span><br><span class="line">switch01(config)<span class="comment">#exit</span></span><br><span class="line">// 查看VLAN2配置，VLAN2被成功分配了端口f0/24</span><br><span class="line">switch01<span class="comment"># sh vlan name vlan2</span></span><br></pre></td></tr></table></figure></li><li><p>测试192.168.0.2: ping 192.168.0.5 ，连通</p></li></ol><blockquote><p>三、配置VLAN3</p></blockquote><ol><li><p>为VLAN3分配端口f0/1，最终通过查看VLAN3配置观察是否成功分配</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">switch01<span class="comment">#config t</span></span><br><span class="line">// 进入f0/1端口</span><br><span class="line">switch01(config)<span class="comment">#in f0/1</span></span><br><span class="line">// 将端口f0/1分配给vlan3</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#switchport access vlan 3</span></span><br><span class="line">// 退出，使得配置生效</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#exit</span></span><br><span class="line">switch01(config)<span class="comment">#exit</span></span><br><span class="line">// 查看VLAN3配置，VLAN3被成功分配了端口f0/1</span><br><span class="line">switch01<span class="comment"># sh vlan name vlan3</span></span><br></pre></td></tr></table></figure></li><li><p>测试192.168.0.2: ping 192.168.0.5 ，不可连通</p></li></ol><blockquote><p>四、删除VLAN</p></blockquote><ol><li><p>删除VLAN3的端口f0/1和VLAN2的f0/24</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进⼊配置模式</span><br><span class="line">switch01<span class="comment">#config t</span></span><br><span class="line">// 进⼊f0/1端⼝</span><br><span class="line">switch01(config)<span class="comment">#in f0/1</span></span><br><span class="line">// 将f0/1端⼝返还给VLAN1</span><br><span class="line">switch01(config-if)<span class="comment">#switchport access vlan 1</span></span><br><span class="line">// 退出</span><br><span class="line">switch01(config-if)<span class="comment">#exit</span></span><br><span class="line"></span><br><span class="line">// 进⼊f0/24端⼝</span><br><span class="line">switch01(config)<span class="comment">#in f0/24</span></span><br><span class="line">// 将f0/24端⼝返还给VLAN1</span><br><span class="line">switch01(config-if)<span class="comment">#switchport access vlan 1</span></span><br><span class="line">// 退出使配置⽣效</span><br><span class="line">switch01(config-if)<span class="comment">#exit</span></span><br><span class="line">switch01(config)<span class="comment">#exit</span></span><br></pre></td></tr></table></figure></li><li><p>查看VLAN配置，查看当前所有端口以及VLAN的配置。端口返还成功给VLAN1，VLAN2和VLAN3没有分配到任何端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch01<span class="comment">#sh vlan</span></span><br></pre></td></tr></table></figure></li><li><p>删除VLAN2和VLAN3</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入VLAN配置模式</span><br><span class="line">switch01<span class="comment">#vlan database</span></span><br><span class="line">//删除VLAN2</span><br><span class="line">switch01(vlan)<span class="comment">#no vlan 2</span></span><br><span class="line">//删除VLAN3</span><br><span class="line">switch01(vlan)<span class="comment">#no vlan 3</span></span><br><span class="line">//退出使配置⽣效</span><br><span class="line">switch01(vlan)<span class="comment">#exit</span></span><br></pre></td></tr></table></figure></li><li><p>查看VLAN配置，VLAN2和VLAN3被删除</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch01<span class="comment">#sh vlan</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实验问题与结果分析-1"><a href="#实验问题与结果分析-1" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><blockquote><p>一、测试192.168.0.2: ping 192.168.0.5能否连通</p></blockquote><ol><li>尚未配置VLAN前，VLAN1拥有所有端口，一个VLAN即一个广播域，在同一广播域下的92.168.0.2与192.168.0.5可以连通。</li><li>建立了VLAN2和VLAN3后，端⼝f0/1分配给VLAN2时，192.168.0.2与192.168.0.5位于不同的VLAN，不同VLAN中的两台计算机在不进⾏其他配置的情况下，不可连通</li><li>将端⼝f0/24分配给VLAN2后，两台计算机⼜处于同⼀VLAN，可以连通；</li><li>将端⼝f0/1分配给VLAN3后查看VLAN配置，⼀个端⼝只能被分配给⼀个VLAN(一个VLAN可以拥有多个端口，一对多关系)，两台计算机处于不同VLAN，不可连通；</li></ol><blockquote><p>二、实验注意事项</p></blockquote><ol><li>分配完端口后需查看VLAN2配置，观察是否成功分配，且要退出配置模式才能进行查看；</li><li>在进⾏实验前要注意清除两台计算机的DNS，并关闭防⽕墙；</li><li>有时端口不可用，可切换到其他端口进行实验；</li><li>注意连接交换机时，使用console线将计算机串口com2与路由器console口直接相连。</li><li>要注意设备上其他同学之前配置过VLAN没有删除，否则可能一直不能连通。</li></ol><blockquote><p>三、实验心得</p></blockquote><p>本次实验中接触了<em>IOS</em>网络操作系统，了解了实验室中的交换机与路由器，并初步掌握了该操作系统的一些常用指令，如配置端口等操作。通过对交换机进行<em>VLAN</em>的配置，对虚拟局域网有了更深的理解。</p><h1 id="10-1-静态路由配置实验"><a href="#10-1-静态路由配置实验" class="headerlink" title="[10.1]静态路由配置实验"></a>[10.1]静态路由配置实验</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">静态路由配置实验</td><td align="center">2019-11-06</td></tr></tbody></table><h2 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li><p>了解和掌握路由器端口配置；</p></li><li><p>配置静态路由，实现网际通信。</p></li></ol><h2 id="实验设备-2"><a href="#实验设备-2" class="headerlink" title="实验设备"></a>实验设备</h2><p>由两台路由器、两台计算机和一台交换机组成，模拟两个远程子网互联。</p><ul><li>使用单根串行交叉线将两个路由器的串口对接起来，代表路由器之间的远程网络；</li><li>将路由器以太网端口和两台计算机网卡都用网线直接连接到交换机，由交换机担当网络连接；</li><li>通过串行线将计算机串口COM同路由器CONSOLE口连接起来，两台计算机超级终端作为路由器管理的操作平台</li></ul><h2 id="实验网络拓扑-2"><a href="#实验网络拓扑-2" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191229113432753" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1gadfsfzel7j30u80du0tm.jpg" class="lazyload"></p><h2 id="实验原理-2"><a href="#实验原理-2" class="headerlink" title="实验原理"></a>实验原理</h2><blockquote><p>一、静态路由原理</p></blockquote><ul><li><p>路由：负责路由器控制层面的工作，决定数据包从来源端到目的端所经过的路由路径（源主机到目标主机之间的最佳传输路径）</p></li><li><p>路由器上的每个接口是一个广播域；交换机上的每个接口是一个冲突域*；</p></li><li><p>路由表：路由器中维护的路由条目的集合，路由器根据路由表做出路径选择</p></li><li><p>路由表的形成：直连网段和非直连网段（直接相连和间接相连）</p></li><li><p>非直连：静态路由和动态路由</p></li><li><p>静态路由由管理员手工配置，特点是单向的且缺乏灵活性（适合小范围）</p></li><li><p>默认路由：路由表找不到目标网络的路由条目时，将请求转发到默认路由接口（通向其他网段有且仅有一条路径）</p></li><li><p>优先级：当路由表中同时存在静态路由和默认路由的时候，静态路由的优先级最高，匹配上了立刻进行转发，如果没有匹配上静态路由，则按照默认路由进行转发。</p></li></ul><blockquote><p>二、路由器转发数据包的封装过程（三层转发原理）</p></blockquote><ul><li>特点：IP不变，MAC始终在变；路由器是隔离广播的</li></ul><p>从网上找到以下资料，用于详细说明这个过程：</p><p><img alt="image-20191209100139745" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9q8poulyzj31hk0u0tqj.jpg" class="lazyload"></p><p>首先，我们的环境是所有设备都是初始状态，即对外界几乎一无所知，现在要实现主机 A和主机 B之间通信。</p><ol><li><p>主机A想要与主机B通信，但是目前只知道主机B的IP地址，所以要先经过网关，而此时主机A并不知道路由器A的MAC地址，所以发送ARP广播请求从而获取路由器A的MAC地址，此时四要素：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">源IP地址：192.168.1.2/24</span><br><span class="line">源MAC地址： 00-11-12-21-11-11</span><br><span class="line">目的IP地址：192.168.1.1/24</span><br><span class="line">目标MAC地址：FF-FF-FF-FF</span><br></pre></td></tr></table></figure></li><li><p>由于是ARP广播，所以路由器A的E0端口接收到这个广播，查看数据帧发现是自己的IP地址，由路由器A的E0端口给出回应，主机A收到回应进行ARP缓存，此时由主机A发送一个ping的数据包，此时四要素（主要内容是）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">源IP地址：192.168.1.2/24</span><br><span class="line">源MAC地址： 00-11-12-21-11-11</span><br><span class="line">目的IP地址：192.168.2.2/24</span><br><span class="line">目标MAC地址：00-11-12-21-22-22</span><br></pre></td></tr></table></figure></li><li><p>路由器A的E0接口发现目标MAC地址是自己，然后拆开数据包（解开MAC头部），发现IP地址是主机B的IP地址，此时路由器A会打开路由表查询是否有该条目信息，匹配目标网段，找到路径是E1方向，此时需要重新封装MAC头部信息，但是现在无法封装，因为没有目标的MAC地址，只能将该ping包丢弃，此时路由器A的E1端口发起一个ARP广播，此时四要素是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">源IP地址：10.1.1.1/8</span><br><span class="line">源MAC地址：00-11-12-21-33-33</span><br><span class="line">目的IP地址：10.1.1.2/8</span><br><span class="line">目标MAC地址：FF-FF-FF-FF</span><br></pre></td></tr></table></figure></li><li><p>此时路由器B的E1端口接收到此广播，发现是目标IP是自己，将给出回应，于是将（路由器B的E1端口）自己的MAC地址（00-11-12-21-44-44）告诉路由器A的E1端口，那么路由器A的E1端口缓存路由器B的E1接口的MAC地址，此时主机A的ping包可以到达路由器B的E1端口，路由器B发现找的是自己，此时开始拆包，查询路由表，找到要经过路由器B的E0端口将数据封装后发送出去，但是此时不知道目标（主机B）的MAC地址，将该ping 包丢弃，那么此时路由器B的E0端口将发起一个ARP广播，从而获取主机B的MAC地址，此时四要素是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">源IP地址：192.168.2.1/24</span><br><span class="line">源MAC地址：00-11-12-21-55-55</span><br><span class="line">目的IP地址：192.168.2.2/24</span><br><span class="line">目标MAC地址：FF-FF-FF-FF</span><br></pre></td></tr></table></figure></li><li><p>此时主机B收到该广播，拆包发现目标IP是自己的，将对路由器B的E0接口给出回应，告诉它自己的MAC的地址，此时路由器B的E0接口缓存该回应的信息，此时主机A的ping包数据再次过来，此时四要素：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">源IP地址：192.168.2.1/24</span><br><span class="line">源MAC地址：00-11-12-21-55-55</span><br><span class="line">目的IP地址：192.168.2.2/24</span><br><span class="line">目标MAC地址：00-11-12-21-66-66</span><br></pre></td></tr></table></figure><p>此后主机A和主机B就可以正常互相通信，从而不再需要进行ARP的广播过程。注意上述过程中的(2)和(5)，是否验证了前面所说的“IP不变，MAC始终在变”的转发特点。</p></li></ol><h2 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、连接路由器</p></blockquote><ol><li><p>打开路由器电源</p></li><li><p>连接交换机，使用console线将计算机串口com1与路由器console口直接相连；</p></li><li><p>建立HyperTerminal：开始 -&gt; 程序 -&gt; 附件 -&gt; 通讯 -&gt; 超级终端 -&gt; 名称=<strong>router</strong> -&gt; 连接=<strong>com1</strong> -&gt; (波特率)Baut Rate=<strong>9600</strong>,8,no parity, 1 stop bit；</p></li><li><p>进入特权模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01&gt;en(able)</span><br><span class="line"><span class="built_in">pwd</span>=cisco //输入密码</span><br><span class="line">// 记录FastEthernet0/0的IP </span><br><span class="line">router01<span class="comment">#sh interface f0/0 </span></span><br><span class="line">// 记录Serial3/0的IP </span><br><span class="line">router01<span class="comment">#sh interface s2/0</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>二、配置Router的FastEthernet0/0及Serial2/0</p></blockquote><ol><li><p>router01的配置快速以太网f0/0，配置的IP地址需要与连接的Host主机的⽹关地址⼀致</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">router01<span class="comment">#config t</span></span><br><span class="line">// 进入以太口</span><br><span class="line">router01(config)<span class="comment">#in f0/0</span></span><br><span class="line">// 添加IP地址</span><br><span class="line">router01(config-if)<span class="comment">#ip address 192.168.1.1 255.255.255.0</span></span><br><span class="line">// 开启端口功能</span><br><span class="line">router01(config-if)<span class="comment">#no shut</span></span><br></pre></td></tr></table></figure></li><li><p>router01的配置串口s2/0</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 退到配置模式</span><br><span class="line">router01(config-if)<span class="comment">#exit</span></span><br><span class="line">// 进入串口</span><br><span class="line">router01(config)<span class="comment">#in s2/0</span></span><br><span class="line">// 设置IP地址</span><br><span class="line">router01(config-if)<span class="comment">#ip addr 202.168.1.1 255.255.255.0</span></span><br></pre></td></tr></table></figure></li><li><p>同理配置router02</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`router01`</span><br><span class="line">f0/0的以太网IP地址：192.168.1.1</span><br><span class="line">s2/0的串口地址：202.168.1.1</span><br><span class="line"></span><br><span class="line">`router02`</span><br><span class="line">f0/0的以太网IP地址：192.168.2.1</span><br><span class="line">s2/0的串口地址：202.168.1.2</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>三、静态路由配置</p></blockquote><ol><li><p>添加对端路由  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/******* router01路由器 *******/</span><br><span class="line">router01<span class="comment">#config t </span></span><br><span class="line">// 添加对端路由</span><br><span class="line">router01(config)<span class="comment">#ip route 192.168.2.0 255.255.255.0 202.168.1.2</span></span><br><span class="line">// 查看路由表</span><br><span class="line">router01<span class="comment">#sh ip route </span></span><br><span class="line"></span><br><span class="line">/******* router02路由器 *******/</span><br><span class="line">router02<span class="comment">#config t </span></span><br><span class="line">// 添加对端路由</span><br><span class="line">router02(config)<span class="comment">#ip route 192.168.1.0 255.255.255.0 202.168.1.1 </span></span><br><span class="line">// 查看路由表</span><br><span class="line">router01<span class="comment">#sh ip route</span></span><br></pre></td></tr></table></figure><ul><li><p>route01的路由表</p><p><img alt="image-20191209103726622" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9q9qtq65oj30q60363yv.jpg" class="lazyload"></p></li><li><p>route02的路由表</p><p><img alt="image-20191209104439373" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9q9ybtgbpj30s2030aaf.jpg" class="lazyload"></p></li></ul></li><li><p>测试，用ping连通192.168.2.254，成功连通</p><p><img alt="image-20191209104946418" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qa3na4m5j30qg078t9y.jpg" class="lazyload"></p></li></ol><blockquote><p>四、缺省路由</p></blockquote><ol><li><p>删除静态路由并添加缺省路由</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/******* router01路由器 *******/</span><br><span class="line">router01<span class="comment">#config t </span></span><br><span class="line">// 删除静态路由</span><br><span class="line">router01(config)<span class="comment">#no ip route 192.168.2.0 255.255.255.0 </span></span><br><span class="line">// 添加缺省路由</span><br><span class="line">router01(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 202.168.1.2 </span></span><br><span class="line">router01<span class="comment">#sh ip route </span></span><br><span class="line"></span><br><span class="line">/******* router02路由器 *******/</span><br><span class="line">router02<span class="comment">#config t </span></span><br><span class="line">// 删除静态路由</span><br><span class="line">router02(config)<span class="comment">#no ip route 192.168.1.0 255.255.255.0 </span></span><br><span class="line">// 添加缺省路由</span><br><span class="line">router02(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 202.168.1.1 </span></span><br><span class="line">router02<span class="comment">#sh ip route</span></span><br></pre></td></tr></table></figure><ul><li><p>route01的路由表</p><p><img alt="image-20191209105444317" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qa8t3p3lj30se01ymxe.jpg" class="lazyload"></p></li><li><p>route02的路由表</p><p><img alt="image-20191209105618624" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qaagc4k2j30s401wjrm.jpg" class="lazyload"></p></li></ul></li><li><p>测试，用ping连通192.168.2.254，成功连通 </p><p><img alt="image-20191209110357920" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qaiep8svj30u407cwfs.jpg" class="lazyload"></p></li><li><p>检查router01的运行配置，可查看到所有配置信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01<span class="comment">#sh running config</span></span><br></pre></td></tr></table></figure><p><img alt="image-20191209110726993" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qam19lsfj30s80he763.jpg" class="lazyload"></p></li></ol><h2 id="实验问题与结果分析-2"><a href="#实验问题与结果分析-2" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><p>​     在本次实验中，两台路由器都需要进行相似的配置，需要将路由器、主机、交换机都连接起来，静态路由配置实验与之前的两个实验相比设备、连线显得更加复杂和困难一些。</p><p>​    通过本次静态路由配置实验，了解和掌握了路由器相关配置指令，通过不断地配置（刚开始的时候不熟练好几个地方配置错误）对静态路由相关概念有了更深刻的理解。</p><h1 id="11-1-帧中继配置实验"><a href="#11-1-帧中继配置实验" class="headerlink" title="[11.1]帧中继配置实验"></a>[11.1]帧中继配置实验</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="right">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="right">1751720</td><td align="center">软件工程</td><td align="center">帧中继配置实验</td><td align="center">2019-11-13</td></tr></tbody></table><h2 id="实验目的-3"><a href="#实验目的-3" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li>了解广域网基本概念</li><li>了解和掌握帧中继技术的原理，熟悉帧中继交换机永久虚电路配置步骤</li><li>熟悉使用帧中继链路的路由配置</li></ol><p>2 熟悉使用帧中继链路的路由配置。</p><h2 id="实验设备-3"><a href="#实验设备-3" class="headerlink" title="实验设备"></a>实验设备</h2><ul><li>实验环境主要由三台路由器、三台计算机和一台交换机组成，模拟一个由局域网和广域网组成的网际网。</li><li>路由器（模拟帧中继交换机）使用单根串行交叉线将路由器A和路由器C的广域网串口连接起来，路由器B和路由器C的广域网串口连接起来（构建帧中继网络专线以连接两个远程子网），并使同<em>Router C</em>相连的电缆连接线类型均为<em>DCE</em>（将两条通讯链路配置成单条PVC永久虚电路）</li><li>将路由器A和路由器B以太网端口和两台计算机网卡都用网线直接连接到交换机，由交换机担当网络连接</li><li>通过串行线将各个计算机串口COM同路由器CONSOLE口连接起来，使用各自超级终端作为路由器管理的操作平台。</li></ul><h2 id="实验网络拓扑-3"><a href="#实验网络拓扑-3" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191229120741678" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1gadgqw0pcqj30wc03qgm4.jpg" class="lazyload"></p><h2 id="实验原理-3"><a href="#实验原理-3" class="headerlink" title="实验原理"></a>实验原理</h2><ol><li>帧中继交换机</li></ol><ul><li><p>DLCI(数据链路连接标识)：用于标识源和目的设备间的逻辑链路；</p></li><li><p>PVC(永久虚电路)：一对进出的链路可以配置成一条虚电路；</p></li><li><p>LMI(本地管理接口)：一种信令标志，负责管理设备之间的连接、维护，配置时需要将交换机和路由器相连端口设置成同一种接口类型，分三种：cisco、ansi和q939a。</p></li></ul><ol start="2"><li>路由器使用帧中继链路</li></ol><ul><li>帧中继映射表Router01：将IP地址同链路绑定，缺省情况下，路由器通过inverse-arp灰动态生成，也可以静态生成。</li></ul><table><thead><tr><th>NEXT-Hop</th><th>DLCI</th></tr></thead><tbody><tr><td>202.168.1.2</td><td>200</td></tr></tbody></table><h2 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、帧中继交换机配置</p></blockquote><ol><li><p>路由器设置成帧中继交换机  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入全局配置模式</span><br><span class="line">router03<span class="comment">#config t</span></span><br><span class="line">// 启用作为帧中继交换机</span><br><span class="line">router03(config)<span class="comment">#frame switching</span></span><br><span class="line">// 查看帧中继功能</span><br><span class="line">router03<span class="comment">#sh run</span></span><br></pre></td></tr></table></figure></li><li><p>设置s0/0/0端口  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 查看端口物理连接</span><br><span class="line">router03<span class="comment">#sh control s0/0/0 </span></span><br><span class="line">// 设置端口</span><br><span class="line">router03 (config)<span class="comment">#in s0/0/0 </span></span><br><span class="line">// 封装端口为Frame</span><br><span class="line">router03 (config-if)<span class="comment">#encap frame</span></span><br><span class="line">// 帧封装方式</span><br><span class="line">router03 (config-if)<span class="comment">#fram intf-type dce </span></span><br><span class="line">// 设置lmi类型</span><br><span class="line">router03 (config-if)<span class="comment">#fram lmi-type cisco </span></span><br><span class="line">// 时钟频率</span><br><span class="line">router03 (config-if)<span class="comment">#clock rate 56000</span></span><br><span class="line">// 配置广域路由(pvc)</span><br><span class="line">router(config-if)<span class="comment">#fram route 200 inter s0/0/1 100</span></span><br><span class="line">// 启动端口：</span><br><span class="line">router03 (config-if)<span class="comment">#no shut</span></span><br><span class="line">router03 (config-if)<span class="comment">#exit</span></span><br></pre></td></tr></table></figure></li><li><p>设置s0/0/1端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 设置端口</span><br><span class="line">router03 (config)<span class="comment">#in s0/0/1 </span></span><br><span class="line">// 封装端口为Frame</span><br><span class="line">router03 (config-if)<span class="comment">#encap frame </span></span><br><span class="line">// 配置端口类型DCE</span><br><span class="line">router03 (config-if)<span class="comment">#fram intf-type dce </span></span><br><span class="line">// 设置lmi类型</span><br><span class="line">router03 (config-if)<span class="comment">#fram lmi-type cisco </span></span><br><span class="line">// 时钟频率</span><br><span class="line">router03 (config-if)<span class="comment">#clock rate 56000</span></span><br><span class="line">// 配置广域路由(pvc)</span><br><span class="line">router03 (config-if)<span class="comment">#fram route 100 inter s0/0/0 200</span></span><br></pre></td></tr></table></figure></li><li><p>检查帧中继交换机 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 查看配置</span><br><span class="line">router03<span class="comment">#sh run</span></span><br><span class="line">// 查看交换机路由表，即pvc构成</span><br><span class="line">router03<span class="comment">#sh frame route</span></span><br><span class="line">// 查看pvc使用情况</span><br><span class="line">router03<span class="comment">#sh frame pvc #端口类型DCE，DLCI用途是Switching，激活状态</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>IN_Port</th><th>IN_DLCI</th><th>OUT_Port</th><th>OUT_DLCI</th></tr></thead><tbody><tr><td>S0/0/0</td><td>200</td><td>S0/1</td><td>100</td></tr><tr><td>S0/0/1</td><td>100</td><td>S0/0</td><td>200</td></tr></tbody></table></li></ol><blockquote><p>二、配置路由器Router01和Router02</p></blockquote><ol><li><p>配置快速以太网f0/0，相关操作与静态路由部分相似,Router01和Router02步骤相似  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">router01<span class="comment">#config t</span></span><br><span class="line">// 进入以太口</span><br><span class="line">router01(config)<span class="comment">#in f0/0</span></span><br><span class="line">// 删除旧IP地址</span><br><span class="line">router01(config-if)<span class="comment">#no ip address &lt;ipaddress&gt;&lt;subnet mask&gt;</span></span><br><span class="line">// 添加IP地址</span><br><span class="line">router01(config-if)<span class="comment">#ip address &lt;ipaddress&gt;&lt;subnet mask&gt;</span></span><br><span class="line">// 开启端口功能</span><br><span class="line">router01(config-if)<span class="comment">#no shut</span></span><br></pre></td></tr></table></figure></li><li><p>配置帧中继广域网链路</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 查看pvc链路号</span><br><span class="line">router01<span class="comment">#sh frame pvc #看不到</span></span><br><span class="line">// 设置端口</span><br><span class="line">router01(config)<span class="comment">#in s0/0/0</span></span><br><span class="line">// 封装端口为Frame</span><br><span class="line">router01(config-if)<span class="comment">#encap  frame#线路才启用； </span></span><br><span class="line">// 查看并记录DLCI编号</span><br><span class="line">router01<span class="comment">#sh frame pvc</span></span><br><span class="line">// 设置lmi类型</span><br><span class="line">router01(config-if)<span class="comment">#fram lmi-type cisco </span></span><br><span class="line">// 设置IP地址</span><br><span class="line">router01(config)<span class="comment">#ip addr 202.168.2.1 255.255.255.0 </span></span><br><span class="line">// 启动端口</span><br><span class="line">router01(config-if)<span class="comment">#no shut</span></span><br></pre></td></tr></table></figure></li><li><p>地址映射管理</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 查看DLCI同IP地址映射状态</span><br><span class="line">router01<span class="comment">#sh frame map #已经映射就不用设立；</span></span><br></pre></td></tr></table></figure></li><li><p>静态路由配置 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加缺省路由</span><br><span class="line">router01(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 202.168.2.2 # 对端广域端口地址；</span></span><br><span class="line">// 或添加静态路由</span><br><span class="line">router01(config)<span class="comment">#ip route 192.168.y.0 255.255.255.0 202.168.2.2 </span></span><br><span class="line">// 查看路由表：router01<span class="comment"># sh ip route</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>三、测试</p></blockquote><ol><li><p><code>ping 192.168.1.254</code></p></li><li><p>静态建立帧中继映射  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 关闭动态反向地址解析</span><br><span class="line">router01(config)<span class="comment">#int s0/0/0 #指定端口</span></span><br><span class="line">router01(config-if)<span class="comment">#no fram inverse</span></span><br><span class="line">router01(config-if)<span class="comment">#shut #重启端口</span></span><br><span class="line">router01(config-if)<span class="comment">#no shut</span></span><br><span class="line">// 查看DLCI同IP地址映射状态</span><br><span class="line">router01<span class="comment">#sh frame map #不存在映射</span></span><br><span class="line">// 建立映射DLCI</span><br><span class="line">router01(config-if)<span class="comment">#fram map ip 202.168.2.2 200#对端地址</span></span><br></pre></td></tr></table></figure></li><li><p>重新测试，<code>ping 192.168.2.254</code>  </p></li></ol><blockquote><p>四、实验结果</p></blockquote><ol><li><p>测试连通</p><p><code>ping 192.168.1.254</code></p></li></ol><p><img alt="IMG_20191120_150043" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1gadhd7666cj31400u0h69.jpg" class="lazyload"></p><ol start="2"><li><p>查看路由表、查看地址映射、查看<em>PVC</em>使用情况</p><p><code>sh ip route</code>&amp;<code>sh frame map</code>&amp;<code>sh frame pvc</code></p></li></ol><p><img alt="image-20191229123205907" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1gadhganjhzj30tc0qohdt.jpg" class="lazyload"></p><p><img alt="image-20191229123148261" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1gadhg35kt9j30q80k44qp.jpg" class="lazyload"></p><ol start="3"><li><p>查看交换机路由表</p><p><code>sh frame route</code></p></li></ol><p><img alt="image-20191229123106340" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1gadhf919tvj30te05ydmn.jpg" class="lazyload"></p><h2 id="实验问题与结果分析-3"><a href="#实验问题与结果分析-3" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><blockquote><p>一、专业名词</p></blockquote><ol><li>DLCI：数据链路连接标识</li><li>PVC：永久虚电路</li></ol><blockquote><p>二、实验心得</p></blockquote><p>帧中继配置实验这个实验比较复杂，完成实验也花了比较多的时间，还好之前有静态路由配置实验作为铺垫，难度衔接得还是比较有层次感的，理论课上讲到的帧中继相关理论的时候，一开始不是很理解，做了实验之后进一步认识了帧中继技术，也更加掌握了其路由表的建立的机制。</p><h1 id="12-1-ACL访问控制列表"><a href="#12-1-ACL访问控制列表" class="headerlink" title="[12.1]ACL访问控制列表"></a>[12.1]ACL访问控制列表</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">ACL访问控制列表</td><td align="center">2019-11-20</td></tr></tbody></table><h2 id="实验目的-4"><a href="#实验目的-4" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li>了解路由器包过滤基本原理</li><li>了解访问控制列表实施原理</li><li>利用控制列表实施网络安全</li><li>掌握访问控制组配置</li><li>实施包过滤，有选择地允许某些地址组进行网际通信</li></ol><h2 id="实验设备-4"><a href="#实验设备-4" class="headerlink" title="实验设备"></a>实验设备</h2><p>实验环境主要由两台路由器、两台计算机和一台交换机组成。</p><ul><li>使用单根串行交叉线将两个路由器的串口对接起来</li><li>将路由器以太网端口和两台计算机网卡都用网线直接连接交换机，由交换机担当网络连接</li><li>通过串行线将计算机串口<em>COM</em>同路由器<em>CONSOLE</em>连接起来，两台计算机超级终端作为路由器管理平台</li></ul><p>路由器串口地址、端口地址，计算机网关地址、<em>IP</em>地址与之前实验相同</p><h2 id="实验网络拓扑-4"><a href="#实验网络拓扑-4" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191229123636228" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1gadhkzhhzwj30pe0aemxq.jpg" class="lazyload"></p><h2 id="实验原理-4"><a href="#实验原理-4" class="headerlink" title="实验原理"></a>实验原理</h2><ul><li><p>路由器对每个经过的IP包实行转发，需要对每一个IP包的头部进行分析，这就称为包过滤。正常情况下，包过滤只是转发的一个环节，但利用包过滤，可以加入其他的处理规则，比如，ACL就是添加允许是否通行的规则，起到一定的网络安全作用。</p></li><li><p>通配符掩码/屏蔽字，定义地址组，形式同字网掩妈相反，1表示忽略，0表示保留；150.1.1.x 0.0.0.255 150.1.1.0</p></li><li><p>包过滤方向，指流入包还是流出包，路由器上有两个位置都可使用存取表，最优选择应离数据流最近的地方；对于内部地址，串口应是out，以太口应是in；对于外部地址，以太口应是out，串口应是in。</p></li><li><p>其工程主要作用是保护内部主机，或阻止访问特定不安全的外部主机。</p></li></ul><h2 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、连接路由器 </p></blockquote><ol><li><p>打开路由器电源</p></li><li><p>连接交换机，使用console线将计算机串口<strong>com1</strong>与路由器console口直接相连；</p></li><li><p>建立HyperTerminal：开始 -&gt; 程序 -&gt; 附件 -&gt; 通讯 -&gt; 超级终端 -&gt; 名称=<strong>router</strong> -&gt; 连接=<strong>com1</strong> -&gt; (波特率)Baut Rate=<strong>9600</strong>,8,no parity, 1 stop bit；</p></li><li><p>进入特权模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01&gt;en(able)</span><br><span class="line"><span class="built_in">pwd</span>=cisco //输入密码</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>二、静态路由配置</p></blockquote><ol><li><p>配置Router01快速以太f0/0    </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">router01<span class="comment">#config t</span></span><br><span class="line">// 进入以太口：</span><br><span class="line">router01(config)<span class="comment">#in f0/0</span></span><br><span class="line">// 添加IP地址</span><br><span class="line">router01 (config-if)<span class="comment">#ip address 192.168.1.1 255.255.255.0</span></span><br><span class="line">// 开启端口功能</span><br><span class="line">router01(config-if)<span class="comment">#no shut</span></span><br></pre></td></tr></table></figure></li><li><p>配置Router01串口，s2/0  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 退到配置模式</span><br><span class="line">router01(config-if)<span class="comment">#exit</span></span><br><span class="line">// 进入串口</span><br><span class="line">router01(config)<span class="comment">#in s2/0</span></span><br><span class="line">// 设置地址</span><br><span class="line">router01 (config-if)<span class="comment">#ip address 202.168.1.1 255.255.255.0</span></span><br><span class="line">// 开启端口功能</span><br><span class="line">router01(config-if)<span class="comment">#no shut</span></span><br></pre></td></tr></table></figure></li><li><p>同理配置router02</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`router01`</span><br><span class="line">f0/0的以太网IP地址：192.168.1.1</span><br><span class="line">s2/0的串口地址：202.168.1.1</span><br><span class="line"></span><br><span class="line">`router02`</span><br><span class="line">f0/0的以太网IP地址：192.168.2.1</span><br><span class="line">s2/0的串口地址：202.168.1.2</span><br></pre></td></tr></table></figure></li><li><p>静态缺省路由配置  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/******* router01路由器 *******/</span><br><span class="line">router01<span class="comment">#config t </span></span><br><span class="line">// 添加缺省路由</span><br><span class="line">router01(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 202.168.1.2 </span></span><br><span class="line">router01<span class="comment">#sh ip route </span></span><br><span class="line"></span><br><span class="line">/******* router02路由器 *******/</span><br><span class="line">router02<span class="comment">#config t </span></span><br><span class="line">// 添加缺省路由</span><br><span class="line">router02(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 202.168.1.1 </span></span><br><span class="line">router02<span class="comment">#sh ip route</span></span><br></pre></td></tr></table></figure><ul><li><p>route01的路由表</p><p><img alt="image-20191209105444317" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qa8t3p3lj30se01ymxe.jpg" class="lazyload"></p></li><li><p>route02的路由表</p><p><img alt="image-20191209105618624" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qaagc4k2j30s401wjrm.jpg" class="lazyload"></p></li></ul></li><li><p>host测试，用ping连通192.168.2.15，成功连通 </p><p><img alt="image-20191209152813783" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qi5dcj82j30oi07ejsi.jpg" class="lazyload"></p></li></ol><blockquote><p>三、访问控制组, 只允许内部地址外出  </p></blockquote><ol><li><p>目的</p><p>只允许内部地址外出permit：192.168.1.0/28</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.1.15可以外出；</span><br><span class="line">192.168.1.17不可以外出；</span><br></pre></td></tr></table></figure></li><li><p>建立访问控制组  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">router01<span class="comment">#config t</span></span><br><span class="line">// 建立访问控制组1</span><br><span class="line">router01(config)<span class="comment"># access-list 1 permit 192.168.1.0  0.0.0.15</span></span><br><span class="line">// 查看访问控制组</span><br><span class="line">router01<span class="comment">#sh access-list</span></span><br></pre></td></tr></table></figure><p>router01的访问控制组：</p><p><img alt="image-20191209153500365" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qicfjn0ij30s801udfx.jpg" class="lazyload"></p></li><li><p>实施包过滤1  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 指定以太端口</span><br><span class="line">router01<span class="comment"># config t</span></span><br><span class="line">router01(config)<span class="comment">#in f0/0</span></span><br><span class="line">// 建立映射</span><br><span class="line">router01(config)<span class="comment">#ip access-group 1 in </span></span><br><span class="line">// 查看包过滤</span><br><span class="line">router01<span class="comment">#sh run</span></span><br></pre></td></tr></table></figure><p>查看包过滤：</p><p><img alt="image-20191209154640454" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qiokbdg6j30sc02yq36.jpg" class="lazyload"></p></li><li><p>host测试，用ping连通对端计算机</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 测试连通(从计算机)</span><br><span class="line">ping 192.168.2.15  <span class="comment"># 对端路由器，成功</span></span><br><span class="line">// 修改计算机IP地址：192.168.1.17</span><br><span class="line">// 测试连通(从计算机)</span><br><span class="line">ping 192.168.2.15   <span class="comment"># 对端路由器，不成功</span></span><br></pre></td></tr></table></figure><p>第一次测试：</p><p><img alt="image-20191209153848187" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qigdr899j30r607aaba.jpg" class="lazyload"></p><p>修改计算机IP地址：192.168.1.17后，第二次测试：</p><p><img alt="image-20191209153939539" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qih9jkiej30x406aq3z.jpg" class="lazyload"></p></li><li><p>实施包过滤2 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 指定实施端口</span><br><span class="line">router01<span class="comment"># config t</span></span><br><span class="line">router01(config)<span class="comment">#in f0/0</span></span><br><span class="line">// 删除映射</span><br><span class="line">router01(config)<span class="comment"># no ip access-group 1 in </span></span><br><span class="line">// 查看包过滤</span><br><span class="line">router01<span class="comment"># sh run</span></span><br><span class="line">// 指定串行端口</span><br><span class="line">router01<span class="comment">#config t</span></span><br><span class="line">router01(config)<span class="comment">#in s2/0</span></span><br><span class="line">// 建立映射</span><br><span class="line">router01(config)<span class="comment">#ip access-group 1 out</span></span><br></pre></td></tr></table></figure><p>删除映射后查看包过滤：</p><p><img alt="image-20191209154745863" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qippgxz5j30sa02cglr.jpg" class="lazyload"></p><p>s2/0建立映射后查看包过滤：</p><p><img alt="image-20191209155359701" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qiw6tz0ej30s408idgq.jpg" class="lazyload"></p></li></ol><blockquote><p>三、访问控制组, 只允许外部地址进入  </p></blockquote><ol><li><p>目的</p><p>只允许外部地址进入permit：192.168.y.0/28</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.2.15可以进入；</span><br><span class="line">192.168.2.17不可以进入；</span><br></pre></td></tr></table></figure></li><li><p>建立访问控制组2 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">router01<span class="comment">#config t</span></span><br><span class="line">// 建立访问控制组2</span><br><span class="line">router01(config)<span class="comment">#access-list 2 permit 192.168.2.0  0.0.0.15</span></span><br><span class="line">// 查看访问控制组</span><br><span class="line">router01<span class="comment">#sh access-list</span></span><br></pre></td></tr></table></figure><p>router01的访问控制组：</p><p><img alt="image-20191209155813510" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qj0kyudoj30s402y3yu.jpg" class="lazyload"></p></li><li><p>实施包过滤</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 指定以太端口</span><br><span class="line">router01<span class="comment">#config t</span></span><br><span class="line">router01(config)<span class="comment">#in s2/0</span></span><br><span class="line">// 建立映射</span><br><span class="line">router01(config)<span class="comment">#ip access-group 2 in</span></span><br><span class="line">// 查看包过滤</span><br><span class="line">router01<span class="comment">#sh run</span></span><br></pre></td></tr></table></figure><p>查看包过滤：</p><p><img alt="image-20191209155923609" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qj1syy3tj30se02st8z.jpg" class="lazyload"></p></li><li><p>host测试，用ping连通对端计算机，本机计算机IP地址：192.168.1.15</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 测试连通(从对端计算机)</span><br><span class="line">ping 192.168.2.15<span class="comment"># 对端路由器，成功</span></span><br><span class="line">// 配置对端计算机IP地址：192.168.2.17</span><br><span class="line">// 测试连通(从对端计算机)</span><br><span class="line">ping 192.168.2.17<span class="comment"># 对端路由器，不成功</span></span><br></pre></td></tr></table></figure><p>第一次测试，成功：</p><p><img alt="image-20191209153848187" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qigdr899j30r607aaba.jpg" class="lazyload"></p><p>修改对端计算机IP地址：192.168.2.17后，第二次测试，不成功：</p><p><img alt="image-20191209160204652" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qj4llny3j30py06agml.jpg" class="lazyload"></p></li><li><p>查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//查看运行状态</span><br><span class="line">router01<span class="comment"># show run</span></span><br></pre></td></tr></table></figure><p><img alt="image-20191209160655883" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qj9nltx1j30rm0ksdi3.jpg" class="lazyload"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 查看访问控制组</span><br><span class="line">router01<span class="comment"># show access-list 1</span></span><br><span class="line">router01<span class="comment"># show access-list 2</span></span><br></pre></td></tr></table></figure><p><img alt="image-20191209160749961" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qjaldczpj30s6040t97.jpg" class="lazyload"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 删除</span><br><span class="line">router01(config) no access-list 1</span><br><span class="line">// 测试连通(从计算机)</span><br><span class="line">ping 192.168.2.15<span class="comment"># 对端计算机,成功</span></span><br></pre></td></tr></table></figure><p><img alt="image-20191209161005041" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qjcxffzgj30oe07aab9.jpg" class="lazyload"></p></li></ol><h2 id="实验问题与结果分析-4"><a href="#实验问题与结果分析-4" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><p>​    有了前面实验的铺垫，已经对连线和路由器配置等基本操作比较熟悉，实验比较顺畅。ACL控制访问列表实验是一个基于静态路由配置的实验，其网络拓扑结构与静态路由配置实验完全相同。通过本次实验掌握了访问控制组的相关配置指令，初步认识了路由器包过滤机制，更加认识了网络安全的相关内容。</p><h1 id="13-1-NAT网络地址转换"><a href="#13-1-NAT网络地址转换" class="headerlink" title="[13.1]NAT网络地址转换"></a>[13.1]NAT网络地址转换</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">NAT网络地址转换</td><td align="center">2019-11-27</td></tr></tbody></table><h2 id="实验目的-5"><a href="#实验目的-5" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li><p>了解地址转换原理，理解私有网与互联网互通和互联网接入共享原理</p></li><li><p>了解<em>NAT</em>技术                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p></li><li><p>了解和掌握路由器地址转换功能，作为网络安全内容 </p></li></ol><h2 id="实验设备-5"><a href="#实验设备-5" class="headerlink" title="实验设备"></a>实验设备</h2><p>由两台路由器、两台计算机和一台交换机组成。</p><ul><li>使用单根串行交叉线将两个路由器的串口对接起来</li><li>将路由器以太网端口和两台计算机网卡都用网线直接连接交换机，由交换机担当网络连接</li><li>通过串行线将计算机串口<em>COM</em>同路由器<em>CONSOLE</em>连接起来，两台计算机超级终端作为路由器管理平台</li></ul><p>路由器串口地址、端口地址，计算机网关地址、<em>IP</em>地址与之前实验相同</p><h2 id="实验网络拓扑-5"><a href="#实验网络拓扑-5" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191229124623864" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1gadhv5sh7aj30ra0agaan.jpg" class="lazyload"></p><h2 id="实验原理-5"><a href="#实验原理-5" class="headerlink" title="实验原理"></a>实验原理</h2><ol><li>网络地址转换（Network Address Translation，缩写为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。它是一个方便且得到了广泛应用的技术。</li><li>NAT缺点：让主机之间的通信变得复杂，导致了通信效率的降低。</li><li>NAT将网络划分为内部网络(inside)和外部网络(outside)两部分。局域网主机利用NAT访问网络时，是将局域网内部的本地地址转换为全局地址(互联网合法IP地址)后转发数据包。</li><li>NAT有三种类型：静态NAT(StaticNAT)、动态地址NAT(PooledNAT)、网络地址端口转换NAPT（Port-LevelNAT）。</li><li>网络地址端口转换NAPT（NetworkAddressPortTranslation）则是把内部地址映射到外部网络的一个IP地址的不同端口上。它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的端口号。 NAPT是使用最普遍的一种转换方式。</li></ol><h2 id="实验内容-5"><a href="#实验内容-5" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、连接路由器</p></blockquote><ol><li><p>打开路由器电源</p></li><li><p>连接交换机，使用console线将计算机串口com1与路由器console口直接相连；</p></li><li><p>建立HyperTerminal：开始 -&gt; 程序 -&gt; 附件 -&gt; 通讯 -&gt; 超级终端 -&gt; 名称=<strong>router</strong> -&gt; 连接=<strong>com1</strong> -&gt; (波特率)Baut Rate=<strong>9600</strong>,8,no parity, 1 stop bit；</p></li><li><p>进入特权模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01&gt;en(able)</span><br><span class="line"><span class="built_in">pwd</span>=cisco //输入密码</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>二、转换方案</p></blockquote><ol><li><p>转换方案如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 不转换，内网访问</span><br><span class="line">192.168.1.1～15 </span><br><span class="line">// 转换，外网访问</span><br><span class="line">192.168.1.16～31 -&gt; 202.168.1.4～6</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>三、建立NAT</p></blockquote><ol><li><p>在Router01建立访问控制组和转换地址池。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 建立访问控制组</span><br><span class="line">router01(config)<span class="comment"># access-list 1 permit 192.168.1.16 0.0.0.15</span></span><br><span class="line">// 建立转换地址池</span><br><span class="line">router01(config)<span class="comment"># ip nat pool mypool 202.168.1.4 202.168.1.6 netmask 255.255.255.0</span></span><br></pre></td></tr></table></figure></li><li><p>设置动态NAT关系</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 设置动态NAT关系</span><br><span class="line">router05(config)<span class="comment"># ip nat inside source list 1 pool mypool</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>四、端口设置</p></blockquote><ol><li><p>设置Router01出口，端口 s2/0    </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 设置端口 s0/0</span><br><span class="line">router01 (config)<span class="comment">#in s2/0</span></span><br><span class="line">// 设置地址</span><br><span class="line">router01 (config-if)<span class="comment">#ip address 202.168.1.1 255.255.255.0</span></span><br><span class="line">// 设置转换方向，出口</span><br><span class="line">router01 (config-if)<span class="comment">#ip nat outside</span></span><br></pre></td></tr></table></figure></li><li><p>设置Router01进口，端口 f0/0  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 设置端口 f0/0</span><br><span class="line">router01 (config)<span class="comment">#in f0/0</span></span><br><span class="line">// 设置地址</span><br><span class="line">router01 (config-if)<span class="comment">#ip address 192.168.1.1 255.255.255.0</span></span><br><span class="line">// 设置转换方向，进口</span><br><span class="line">router01 (config-if)<span class="comment">#ip nat inside</span></span><br></pre></td></tr></table></figure></li><li><p>设置单向路由  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01 (config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 202.168.1.2</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>五、测试</p></blockquote><ol><li><p>检测         </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01<span class="comment"># debug ip nat</span></span><br></pre></td></tr></table></figure></li><li><p>配置计算机Host1的IP地址如下，此时是内网访问，不会被转成202.168.1.4~6，不能ping通</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host1的IP地址：192.168.1.15  </span><br><span class="line">ping 192.168.2.1</span><br></pre></td></tr></table></figure></li><li><p>配置计算机Host1的IP地址如下，此时是外网访问，会被转成202.168.1.4~6，能ping通</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host1的IP地址：192.168.1.17  </span><br><span class="line">ping 192.168.2.1</span><br></pre></td></tr></table></figure></li><li><p>查看转换地址表，动态转换只有才完成时才会显示。    </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01<span class="comment"># sh ip nat translation</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实验问题与结果分析-5"><a href="#实验问题与结果分析-5" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><blockquote><p>一、实验总结</p></blockquote><ol><li>NAT全称是“NetworkAddressTranslation”，即“网络地址转换”。</li><li>实验场景类似于微观角度的同济校园网，允许一个整体机构以一个公用IP（InternetProtocol）地址出现Internet上，是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。</li><li>记得设置端口方向inside和outside。</li></ol><blockquote><p>二、实验心得</p></blockquote><p>​    NAT网络地址转换实验是一个基于静态路由配置的实验，需要用到上节课学到的访问控制组的相关配置指令。本次实验一开始的时候对NAT网络地址转换有较大的疑惑，尚未学习相关的理论，感觉比较抽象。后来通过跟老师的交流并结合网上一些资料，对NAT网络地址转换的原理有了更深入的理解，了解了VPN的相关原理和私网与公网的接入原理。</p><p>​    </p><h1 id="14-1-RIP动态路由配置"><a href="#14-1-RIP动态路由配置" class="headerlink" title="[14.1]RIP动态路由配置"></a>[14.1]RIP动态路由配置</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">RIP动态路由配置</td><td align="center">2019-12-04</td></tr></tbody></table><h2 id="实验目的-6"><a href="#实验目的-6" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li>了解动态路由表生成基本原理</li><li>了解最短路径优先算法基本思想</li><li>了解掌握开放式最短路径优先<em>OSPF</em>概念及其动态路由技能</li><li>配置<em>OSPF</em>动态路由，实现网际通信</li></ol><h2 id="实验设备-6"><a href="#实验设备-6" class="headerlink" title="实验设备"></a>实验设备</h2><p>由两台路由器、两台计算机和一台交换机组成。</p><ul><li>使用两根串行交叉线将两个路由器的串口对接起来，创建两个远程传输子网，便于动态路由选择。</li><li>将路由器以太网端口和两台计算机网卡都用网线直接连接到交换机，由交换机担当网络连接。</li><li>通过串行线将两台计算机串口<em>COM</em>和路由器<em>CONSOLE</em>口连接起来，两台计算机超级终端作为路由器管理的操作平台</li></ul><h2 id="实验网络拓扑-6"><a href="#实验网络拓扑-6" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191229125600877" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1gadi56dh0vj30sg0aaaas.jpg" class="lazyload"></p><h2 id="实验原理-6"><a href="#实验原理-6" class="headerlink" title="实验原理"></a>实验原理</h2><blockquote><p>一、动态路由协议概述 </p></blockquote><p>​    路由协议是运行在路由器上的软件进程，与其他路由器上相同路由协议之间交换路由信息，学习非直连网络的路由信息，加入路由表。并且在网络拓扑结构变化时自动调整，维护正确的路由信息。</p><p>​    动态路由协议通过路由信息的交换生成并维护转发引擎需要的路由 表。网络拓扑结构改变时自动更新路由表，并负责决定数据传输最佳路径。</p><p>​    动态路由协议的<strong>优点</strong>是可以自动适应网络状态的变化，自动维护路由信息而不用网络管理员的参与。其<strong>缺点</strong>为由于需要相互交换路由信息，需要占用网络带宽，并且要占用系统资源。另外安全性也不如使用静态路由。在有冗余连接的复杂网络环境中，适合采用动态路由协议。目的网络是否可达取决于网络状态  </p><p><strong>动态路由协议分类</strong> </p><ul><li>按路由算法划分： <ul><li>距离-矢量路由协议( 如RIP ) ：定期广播整个路由信息，易形成路由环路，收敛慢 </li><li>链路状态路由协议（如OSPF）：收集网络拓扑信息，运行协议算法 计算最佳路由根本解决路由环路问题，收敛快 </li></ul></li></ul><blockquote><p>二、RIP协议概述</p></blockquote><p>​    RIP协议采用距离向量算法，在实际使用中已经较少适用。在默认情况下，RIP使用一种非常简单的度量制度：距离就是通往目的站点所需经过的链路数，取值为0~16，数值16表示路径无限长。RIP进程使用UDP的520端口来发送和接收RIP分组。RIP分组每隔30s以广播的形式发送一次，为了防止出现“广播风暴”，其后续的分组将做随机延时后发送。在RIP中，如果一个路由在180s内未被刷，则相应的距离就被设定成无穷大，并从路由表中删除该表项。RIP分组分为两种：请求分组和响应分组。</p><p>​    RIP-1被提出较早，其中有许多缺陷。为了改善RIP-1的不足，在RFC1388中提出了改进的RIP-2，并在RFC1723和RFC2453中进行了修订。RIP-2定义了一套有效的改进方案，新的RIP-2支持子网路由选择，支持CIDR，支持组播，并提供了验证机制。</p><p>​    随着OSPF和IS-IS的出现，许多人认为RIP已经过时了。但事实上RIP也有它自己的优点。对于小型网络，RIP就所占带宽而言开销小，易于配置、管理和实现，并且RIP还在大量使用中。但RIP也有明显的不足，即当有多个网络时会出现环路问题。为了解决环路问题，IETF提出了分割范围方法，即路由器不可以通过它得知路由的接口去宣告路由。分割范围解决了两个路由器之间的路由环路问题，但不能防止3个或多个路由器形成路由环路。触发更新是解决环路问题的另一方法，它要求路由器在链路发生变化时立即传输它的路由表。这加速了网络的聚合，但容易产生广播泛滥。总之，环路问题的解决需要消耗一定的时间和带宽。若采用RIP协议，其网络内部所经过的链路数不能超过15，这使得RIP协议不适于大型网络。</p><h2 id="实验内容-6"><a href="#实验内容-6" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、连接路由器</p></blockquote><ol><li><p>打开路由器电源</p></li><li><p>连接交换机，使用console线将计算机串口com1与路由器console口直接相连；</p></li><li><p>建立HyperTerminal：开始 -&gt; 程序 -&gt; 附件 -&gt; 通讯 -&gt; 超级终端 -&gt; 名称=<strong>router</strong> -&gt; 连接=<strong>com1</strong> -&gt; (波特率)Baut Rate=<strong>9600</strong>,8,no parity, 1 stop bit；</p></li><li><p>进入特权模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01&gt;en(able)</span><br><span class="line"><span class="built_in">pwd</span>=cisco //输入密码</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>二、配置Router的IP地址和动态路由</p></blockquote><ol><li><p>router01的配置快速以太网f0/0</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">router01<span class="comment">#config t</span></span><br><span class="line">// 进入以太口</span><br><span class="line">router01(config)<span class="comment">#in f0/0</span></span><br><span class="line">// 添加IP地址</span><br><span class="line">router01(config-if)<span class="comment">#ip address 192.168.1.1 255.255.255.0</span></span><br><span class="line">// 开启端口功能</span><br><span class="line">router01(config-if)<span class="comment">#no shut</span></span><br></pre></td></tr></table></figure></li><li><p>router01的配置串口s2/0</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 退到配置模式</span><br><span class="line">router01(config-if)<span class="comment">#exit</span></span><br><span class="line">// 进入串口</span><br><span class="line">router01(config)<span class="comment">#in s2/0</span></span><br><span class="line">// 设置IP地址</span><br><span class="line">router01(config-if)<span class="comment">#ip addr 202.168.1.1 255.255.255.0</span></span><br></pre></td></tr></table></figure></li><li><p>router01的配置串口s3/0</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 退到配置模式</span><br><span class="line">router01(config-if)<span class="comment">#exit</span></span><br><span class="line">// 进入串口</span><br><span class="line">router01(config)<span class="comment">#in s3/0</span></span><br><span class="line">// 设置IP地址</span><br><span class="line">router01(config-if)<span class="comment">#ip addr 202.168.2.1 255.255.255.0</span></span><br><span class="line">// 设置带宽</span><br><span class="line">router01(config-if)<span class="comment">#band 256</span></span><br></pre></td></tr></table></figure></li><li><p>router01配置RIP动态路由，如果路由功能关闭，rip必须重新配置    </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加RIP</span><br><span class="line">router01(config)<span class="comment">#router rip</span></span><br><span class="line">// 指定邻居网络</span><br><span class="line">router01(config-router)<span class="comment"># network 192.168.1.0</span></span><br><span class="line">router01(config-router)<span class="comment"># network 202.168.1.0</span></span><br><span class="line">router01(config-router)<span class="comment"># network 202.168.2.0</span></span><br><span class="line">// 查看RIP路由表</span><br><span class="line">router01<span class="comment"># sh ip route rip</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img alt="image-20191204182729022" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9kv8cppkuj30u60223yp.jpg" class="lazyload"></p></li><li><p>同理配置router02，以下为两个路由器配置的IP地址和动态路由</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`router01`</span><br><span class="line">f0/0的以太网IP地址：192.168.1.1</span><br><span class="line">s2/0的串口地址：202.168.1.1</span><br><span class="line">s3/0的串口地址：202.168.2.1，其中带宽设置为256</span><br><span class="line">RIP路由表： 192.168.2.0 202.168.1.0 202.168.2.0 </span><br><span class="line"></span><br><span class="line">`router02`</span><br><span class="line">f0/0的以太网IP地址：192.168.2.1</span><br><span class="line">s2/0的串口地址：202.168.1.1</span><br><span class="line">s3/0的串口地址：202.168.2.1，其中带宽设置为256</span><br><span class="line">RIP路由表： 192.168.2.0 202.168.1.0 202.168.2.0</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>三、测试</p></blockquote><ol><li><p>配置计算机IP地址  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host1: 192.168.1.250</span><br><span class="line">Host2: 192.168.2.250</span><br></pre></td></tr></table></figure></li><li><p>输入如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01(config)<span class="comment">#no ip domain-lookup</span></span><br><span class="line">router01(config)<span class="comment">#exit</span></span><br><span class="line">router01<span class="comment">#trace ip 192.168.2.250</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img alt="image-20191204182519481" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9kv63aoyij30yc03eq3c.jpg" class="lazyload"></p></li><li><p>跟踪调试  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 查看信息发送端口</span><br><span class="line">router01<span class="comment">#debug ip rip</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img alt="image-20191204182910952" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9kva4esupj312208edhk.jpg" class="lazyload"></p></li><li><p>被动接口设置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入RIP设置</span><br><span class="line">router01(config)<span class="comment">#router rip</span></span><br><span class="line">// 以太网端口配置成被动模式</span><br><span class="line">router01(config-router)<span class="comment">#passive-interface f0/0</span></span><br></pre></td></tr></table></figure></li><li><p>查看调试，以太口不再发送：</p><p><img alt="image-20191204183317991" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9kvef14b7j314g0hyn11.jpg" class="lazyload"></p></li></ol><h2 id="实验问题与结果分析-6"><a href="#实验问题与结果分析-6" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><blockquote><p>一、注意事项</p></blockquote><ol><li>一开始的时候将router02的两个串口地址配置成了202.168.1.1和202.168.1.2，两边路由串口设置成了一样的，后来在查看rip路由表的时候发现了这个问题</li></ol><blockquote><p>二、实验心得</p></blockquote><p>通过本次实验，我掌握了RIP协议的概念和原理，初步了解了RIP和OSPF的异同点。本实验跟后续的OSPF动态路由配置实验拓扑结构上相同，而且配置指令也相差无几。</p><h1 id="14-2-OSPF动态路由配置"><a href="#14-2-OSPF动态路由配置" class="headerlink" title="[14.2]OSPF动态路由配置"></a>[14.2]OSPF动态路由配置</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">OSPF动态路由配置</td><td align="center">2019-12-04</td></tr></tbody></table><h2 id="实验目的-7"><a href="#实验目的-7" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li><p>了解和掌握开放式最短路径优先OSPF概念；</p></li><li><p>配置OSPF动态路由，实现网际通信。</p></li></ol><h2 id="实验设备-7"><a href="#实验设备-7" class="headerlink" title="实验设备"></a>实验设备</h2><ol><li>两台路由器，使⽤串⾏线将两个0串⼝对接；</li><li>两台计算机作为操作平台；</li><li>⼀台交换机担当⽹络连接。</li></ol><h2 id="实验网络拓扑-7"><a href="#实验网络拓扑-7" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191204190927439" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9kwg0rba8j30xa0dwab6.jpg" class="lazyload"></p><h2 id="实验原理-7"><a href="#实验原理-7" class="headerlink" title="实验原理"></a>实验原理</h2><blockquote><p>一、OSPF协议概述 </p></blockquote><p>​    OSPF路由协议是用于[网际协议（IP）网络的链路状态路由协议。该协议使用链路状态路由算法的内部网关协议（IGP），在单一自治系统（AS）内部工作。适用于IPv4的OSPFv2协议定义于RFC 2328，RFC 5340定义了适用于IPv6的OSPFv3。</p><p>​    开放式最短路径优先（Open Shortest Path First，OSPF）是目前广泛使用的一种动态路由协议，它属于链路状态路由协议，具有路由变化收敛速度快、无路由环路、支持变长子网掩码（VLSM）和汇总、层次区域划分等优点。在网络中使用OSPF协议后，大部分路由将由OSPF协议自行计算和生成，无须网络管理员人工配置，当网络拓扑发生变化时，协议可以自动计算、更正路由，极大地方便了网络管理。但如果使用时不结合具体网络应用环境，不做好细致的规划，OSPF协议的使用效果会大打折扣，甚至引发故障。 [1] </p><p>​    OSPF协议是一种链路状态协议。每个路由器负责发现、维护与邻居的关系，并将已知的邻居列表和链路费用LSU(Link State Update)报文描述，通过可靠的泛洪与自治系统AS(Autonomous System)内的其他路由器周期性交互，学习到整个自治系统的网络拓扑结构;并通过自治系统边界的路由器注入其他AS的路由信息，从而得到整个Internet的路由信息。每隔一个特定时间或当链路状态发生变化时，重新生成LSA，路由器通过泛洪机制将新LSA通告出去，以便实现路由的实时更新。</p><h2 id="实验内容-7"><a href="#实验内容-7" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、连接路由器</p></blockquote><ol><li><p>打开路由器电源</p></li><li><p>连接交换机，使用console线将计算机串口com1与路由器console口直接相连；</p></li><li><p>建立HyperTerminal：开始 -&gt; 程序 -&gt; 附件 -&gt; 通讯 -&gt; 超级终端 -&gt; 名称=<strong>router</strong> -&gt; 连接=<strong>com1</strong> -&gt; (波特率)Baut Rate=<strong>9600</strong>,8,no parity, 1 stop bit；</p></li><li><p>进入特权模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01&gt;en(able)</span><br><span class="line"><span class="built_in">pwd</span>=cisco //输入密码</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>二、配置Router的IP地址和动态路由</p></blockquote><ol><li><p>router01的配置快速以太网f0/0</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">router01<span class="comment">#config t</span></span><br><span class="line">// 进入以太口</span><br><span class="line">router01(config)<span class="comment">#in f0/0</span></span><br><span class="line">// 添加IP地址</span><br><span class="line">router01(config-if)<span class="comment">#ip address 192.168.1.1 255.255.255.0</span></span><br><span class="line">// 开启端口功能</span><br><span class="line">router01(config-if)<span class="comment">#no shut</span></span><br></pre></td></tr></table></figure></li><li><p>router01的配置串口s2/0</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 退到配置模式</span><br><span class="line">router01(config-if)<span class="comment">#exit</span></span><br><span class="line">// 进入串口</span><br><span class="line">router01(config)<span class="comment">#in s2/0</span></span><br><span class="line">// 设置IP地址</span><br><span class="line">router01(config-if)<span class="comment">#ip addr 202.168.1.1 255.255.255.0</span></span><br></pre></td></tr></table></figure></li><li><p>router01的配置串口s3/0</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 退到配置模式</span><br><span class="line">router01(config-if)<span class="comment">#exit</span></span><br><span class="line">// 进入串口</span><br><span class="line">router01(config)<span class="comment">#in s3/0</span></span><br><span class="line">// 设置IP地址</span><br><span class="line">router01(config-if)<span class="comment">#ip addr 202.168.2.1 255.255.255.0</span></span><br><span class="line">// 设置带宽</span><br><span class="line">router01(config-if)<span class="comment">#band 256</span></span><br></pre></td></tr></table></figure></li><li><p>router01配置OSPF动态路由，如果路由功能关闭，rip必须重新配置，同理配置router02。    </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加OSPF</span><br><span class="line">router01(config)<span class="comment">#router ospf 100</span></span><br><span class="line">// 指定邻居网络</span><br><span class="line">router01(config-router)<span class="comment"># network 192.168.1.0 0.0.0.255 area 0</span></span><br><span class="line">router01(config-router)<span class="comment"># network 202.168.1.0 0.0.0.255 area 0</span></span><br><span class="line">router01(config-router)<span class="comment"># network 202.168.2.0 0.0.0.255 area 0</span></span><br><span class="line">// 查看OSPF ID</span><br><span class="line">router01<span class="comment"># sh ip ospf int </span></span><br><span class="line">// 查看OSPF路由表</span><br><span class="line">router01<span class="comment"># sh ip route ospf </span></span><br><span class="line">// 查看OSPF邻居</span><br><span class="line">router01<span class="comment"># sh ip ospf nei</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p>OSPF路由表：</p><p><img alt="image-20191204201001181" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ky71gpgkj30sa0183yk.jpg" class="lazyload"></p><p>OSPF邻居：</p><p><img alt="image-20191204201043514" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ky7ri5vfj30s603s3yw.jpg" class="lazyload"></p></li></ol><blockquote><p>三、测试</p></blockquote><ol><li><p>配置计算机IP地址  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host1: 192.168.1.250</span><br><span class="line">Host2: 192.168.2.250</span><br></pre></td></tr></table></figure></li><li><p>输入如下命令，测试连通：<code>ping 192.168.2.1</code>，测试连通，表示网关、远程连接子网和动态路由均发挥作用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01(config)<span class="comment">#no ip domain-lookup</span></span><br><span class="line">router01(config)<span class="comment">#exit</span></span><br><span class="line">router01<span class="comment">#trace ip 192.168.2.250</span></span><br></pre></td></tr></table></figure><p>结果如下，跟踪传输路径：<code>trace ip 192.168.2.250</code>，经过了网关、远程连接子网<code>202.168.1.0/24</code>的<code>202.168.1.2</code>端口，没有经过远程连接子网<code>202.168.2.0/24</code></p><p><img alt="image-20191204201941982" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kyh40ma8j30s403c3yw.jpg" class="lazyload"></p></li></ol><h2 id="实验问题与结果分析-7"><a href="#实验问题与结果分析-7" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><p>本实验无需手动配置路由表，通过本次实验，加深了对<em>Dijkstra</em>算法的应用的理解，了解了动态路由的便利性，掌握了 RIP与OSPF 这两个不同的动态路由协议之间在算法、距离度量上的差异。</p><h1 id="15-1-期末自选实验ns3"><a href="#15-1-期末自选实验ns3" class="headerlink" title="[15.1]期末自选实验ns3"></a>[15.1]期末自选实验ns3</h1><table><thead><tr><th>姓名</th><th>学号</th><th>专业</th><th>分工</th></tr></thead><tbody><tr><td>黄钰琳</td><td>1751720</td><td>软件工程</td><td>实验一代码</td></tr><tr><td>石晓楠</td><td>1750995</td><td>软件工程</td><td>实验一整体设计+报告</td></tr><tr><td>王菲凡</td><td>1751694</td><td>软件工程</td><td>实验二代码</td></tr><tr><td>张亦驰</td><td>1751593</td><td>软件工程</td><td>实验二整体设计+报告</td></tr></tbody></table><h2 id="实验目的-8"><a href="#实验目的-8" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li>观察TCP、UDP共享瓶颈链路时如何相互影响的探究。</li><li>探究缓冲区大小对TCP和UDP流的影响；</li></ol><h2 id="实验设备-8"><a href="#实验设备-8" class="headerlink" title="实验设备"></a>实验设备</h2><p>仿真工具NS3</p><h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><p><img alt="image-20191218165419437" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga0z7qldb5j30pg0c4dhf.jpg" class="lazyload"></p><h2 id="实验原理-8"><a href="#实验原理-8" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="一、实验设计"><a href="#一、实验设计" class="headerlink" title="一、实验设计"></a>一、实验设计</h3><ol><li><p><strong>拓扑结构构建：</strong></p><p>构建一个哑铃型网络拓扑结构，其中路由器R1和R2由<code>10 Mbps，100 ms</code>的链接相连接。每个路由器都连接3个主机，即R1连接H1，H2，H3，R2连接H4，H5，H6。所有主机都通过<code>100 Mbps，10 ms</code>的链接连接到路由器。</p><p>两个路由器（即R1和R2）都使用 drop-tail 队列，并根据带宽延迟乘积设置相等的队列大小。选择1.5 KB的数据包大小。</p></li><li><p><strong>实验一</strong></p><p>开启4个TCP New Reno流，过一会儿再开启2个基于UDP的CBR流，每个流为20 Mbps。这些流量随机分布在H1，H2和H3之间。将一个UDP流的速率提高到100 Mbps，并观察其对TCP流和另一个UDP流的吞吐量的影响。</p></li><li><p><strong>实验二</strong></p><p>在10个数据包到800个数据包的范围内改变缓冲区大小，并重复上述实验以找出缓冲区大小对系统公平份额的影响。</p></li></ol><h3 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h3><ol><li><p>计算机⽹络速率，带宽，吞吐量概念</p><ul><li><p>速率（DataRate）</p><p>速率是指计算机⽹络中的主机在数字信道上，单位时间内从⼀端传送到另⼀端的数据量，即数据传输 率，也称数据率或⽐特率。⽐特(bit)是数据量的最⼩单位，s(秒)是时间的最⼩单位。所以速率单位为 bit/s或bps(bit persecond)</p></li><li><p>带宽（Bandwidth）</p></li></ul><p>计算机⽹络中的主机在数字信道上，单位时间内从⼀端传送到另⼀端的最⼤数据量，即最⼤速率。</p><ul><li><p>吞吐量（Throughout）</p><p>吞吐量是指对⽹络、设备、端⼝或其他设施在单位时间内成功地传送数据的数量（以⽐特、字节等测量 单位），也就是说吞吐量是指在没有帧丢失的情况下，设备能够接收并转发的最⼤数据速率。</p></li></ul></li><li><p>TCP/UDP的接受缓冲区和发送缓冲区</p><p>每个TCP socket在内核中都有⼀个发送缓冲区和⼀个接收缓冲区，TCP的全双⼯的⼯作模式以及TCP的</p><p>流量(拥塞)控制便是依赖于这两个独⽴的缓冲区以及缓冲区的填充状态。</p><ul><li><p>TCP接收缓冲区</p><p>接收缓冲区把数据缓存⼊内核，应⽤进程⼀直没有调⽤recv()进⾏读取的话，此数据会⼀直缓存在相应 socket的接收缓冲区内。不管进程是否调⽤recv()读取socket，对端发来的数据都会经由内核接收并且 缓存到socket的内核接收缓冲区之中。</p><blockquote><p>recv()，就是把内核缓冲区中的数据拷⻉贝到应⽤层⽤户的buﬀer⾥⾯，并返回。</p></blockquote></li><li><p>TCP发送缓冲区</p><p>进程调⽤send()发送的数据的时候，⼀般情况下，将数据拷⻉贝进⼊socket的内核发送缓冲区之中，然后 send便会在上层返回。换句话说，send（）返回之时，数据不⼀定会发送到对端去（和write写⽂件有 点类似）。</p><blockquote><p>send()，仅仅是把应⽤层buﬀer的数据拷⻉贝进socket的内核发送buﬀer中，发送是TCP的事情，和 send其实没有太⼤关系。</p></blockquote><p>⼀般来说，接收缓冲区被TCP和UDP⽤来缓存⽹络上来的数据，⼀直被保存到应⽤进程读取为⽌。对于 TCP来说，如果应⽤进程⼀直没有对缓冲区进⾏读取，那么接收缓冲区满了以后，接收端会通知发送 端，接收窗⼝关闭，保证了TCP套接⼝接收缓冲区不会溢出，从⽽保证了TCP是可靠传输。</p><p>发出TCP包的数量及每个包承载的数据的规模除了受到⾃身服务器配置和环境带宽影响，对端的接收状 态也会影响本端的发送状况。</p></li><li><p>UDP接收缓冲区</p><p>每个UDP socket都有⼀个接收缓冲区，没有发送缓冲区，字⾯上说就是UDP有数据就发，不管对⽅是否 可以正确接收。</p><p>UDP当接收缓冲区满时，新来的数据⽆法进⼊缓冲区，此数据包被丢弃。UDP是没有流量控制的，快的 发送者可以很容易的就填满满的接收者，导致接收⽅的的UDP丢弃数据包</p><p>UDP、TCP在缓冲区上的差异，亦是TCP可靠、UDP不可靠的表现。</p></li></ul></li><li><p>公平性度量（Fair Measure）</p><p>公平性度量或量度⽤于⽹络⼯程中，以确定⽤户或应⽤程序是否获得了系统资源的公平共享。公平有⼏ 个数学和概念上的定义。</p><p>新的⽹络传输协议或相应应⽤程序的拥塞机制（Congestion control mechanism）必须与TCP良好交</p><p>互。TCP公平性要求新协议接收的⽹络份额不得超过可⽐较的TCP流。这⼀点⼗分重要，因为TCP是因特 ⽹上的主要传输协议，如果新协议获得不公平的容量，它们会引起诸如⽹络堵塞崩溃的问题。</p><p><strong>Jain平滑指数</strong>：公平性度量或量度用于网络工程中，以确定用户或应用程序是否获得了系统资源的公平共享。公平有几个数学和概念上的定义。</p><p>使用<strong>Jain平滑指数</strong>分析流量变化，指示系统资源是否公平分配。<br>$$<br>FairnessIndex = (sumFlow * sumFlow)/ (6 * sumFlowSqr)<br>$$</p></li><li><p>为何使用吞吐量作为参考指标</p><p>一般使用的参考指标：丢包率、抖动（jitter）和吞吐量。</p><ul><li>丢包率与数据包长度以及包发送频率相关。</li><li>抖动是 QOS 里面常用的一个概念，其意思是指分组延迟的变化程度。</li><li>吞吐量通常是对一个系统和它的部件处理传输数据请求能力的总体评价。</li></ul><p><strong>为了更好地从整体观察实验结果，因此使用<code>吞吐量</code>作为参考指标来评估整个实验系统和它的部件处理传输数据请求能力。</strong></p></li><li><p>ns3的PCAP Tracing</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AsciiTraceHelper ascii; <span class="comment">//创建一个ASCII trace对象</span></span><br><span class="line">p2p.EnableAsciiAll(ascii.CreateFileStream (<span class="string">"script_buffersize.tr"</span>));   <span class="comment">//script_buffersize.tr</span></span><br><span class="line">p2p.EnalbePcapAll(<span class="string">"script_buffersize"</span>); <span class="comment">//script_buffersize.pcap</span></span><br></pre></td></tr></table></figure><p>导出.cc 生成的抓包文件.pcap，使用 Wireshark 可视化</p><p><code>&lt;prefix&gt;-&lt;node&gt;-&lt;device&gt;</code>，为模拟中的每个点对点设备创建一个tracing文件，但是数据繁杂，不易分析</p></li><li><p>gnuplot可视化</p><p>用C++的标准输入输出FairnessIndex和吞吐量，并用gnuplot可视化结果并进行分析</p></li></ol><h2 id="实验内容-8"><a href="#实验内容-8" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="一、构建网络拓扑结构"><a href="#一、构建网络拓扑结构" class="headerlink" title="一、构建网络拓扑结构"></a>一、构建网络拓扑结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点容器以容纳8个节点</span></span><br><span class="line">  NodeContainer nodes;</span><br><span class="line">  nodes.Create (<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个链接创建节点容器</span></span><br><span class="line">  NodeContainer n0n3 = NodeContainer (nodes.Get (<span class="number">0</span>), nodes.Get (<span class="number">3</span>));</span><br><span class="line"><span class="comment">// h1r1</span></span><br><span class="line">  NodeContainer n1n3 = NodeContainer (nodes.Get (<span class="number">1</span>), nodes.Get (<span class="number">3</span>));</span><br><span class="line"><span class="comment">// h2r1</span></span><br><span class="line">  NodeContainer n2n3 = NodeContainer (nodes.Get (<span class="number">2</span>), nodes.Get (<span class="number">3</span>));</span><br><span class="line"><span class="comment">// h3r1</span></span><br><span class="line">  NodeContainer n3n4 = NodeContainer (nodes.Get (<span class="number">3</span>), nodes.Get (<span class="number">4</span>));</span><br><span class="line"><span class="comment">// r1r2</span></span><br><span class="line">  NodeContainer n4n5 = NodeContainer (nodes.Get (<span class="number">4</span>), nodes.Get (<span class="number">5</span>));</span><br><span class="line"><span class="comment">// r2h4</span></span><br><span class="line">  NodeContainer n4n6 = NodeContainer (nodes.Get (<span class="number">4</span>), nodes.Get (<span class="number">6</span>));</span><br><span class="line"><span class="comment">// r2h5</span></span><br><span class="line">  NodeContainer n4n7 = NodeContainer (nodes.Get (<span class="number">4</span>), nodes.Get (<span class="number">7</span>));</span><br><span class="line"><span class="comment">// r2h6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点上安装Internet协议栈（协议）</span></span><br><span class="line">  InternetStackHelper internet;</span><br><span class="line">  internet.Install (nodes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点之间创建点对点通道</span></span><br><span class="line">  PointToPointHelper p2p;</span><br><span class="line"><span class="comment">// 主机到路由器的链接</span></span><br><span class="line">  p2p.SetDeviceAttribute (<span class="string">"DataRate"</span>, StringValue (<span class="string">"100Mbps"</span>));</span><br><span class="line">  p2p.SetChannelAttribute (<span class="string">"Delay"</span>, StringValue (<span class="string">"10ms"</span>));</span><br><span class="line">  NetDeviceContainer d0d3 = p2p.Install (n0n3);</span><br><span class="line">  NetDeviceContainer d1d3 = p2p.Install (n1n3);</span><br><span class="line">  NetDeviceContainer d2d3 = p2p.Install (n2n3);</span><br><span class="line">  NetDeviceContainer d4d5 = p2p.Install (n4n5);</span><br><span class="line">  NetDeviceContainer d4d6 = p2p.Install (n4n6);</span><br><span class="line">  NetDeviceContainer d4d7 = p2p.Install (n4n7);</span><br><span class="line"><span class="comment">// //路由器到路由器的链接</span></span><br><span class="line">  p2p.SetQueue (<span class="string">"ns3::DropTailQueue"</span>, <span class="string">"MaxPackets"</span>, UintegerValue(<span class="number">100000</span>*<span class="number">10</span>/packetSize));</span><br><span class="line">  p2p.SetDeviceAttribute (<span class="string">"DataRate"</span>, StringValue (<span class="string">"10Mbps"</span>));</span><br><span class="line">  p2p.SetChannelAttribute (<span class="string">"Delay"</span>, StringValue (<span class="string">"100ms"</span>));</span><br><span class="line">  NetDeviceContainer d3d4 = p2p.Install (n3n4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个接口分配IP地址</span></span><br><span class="line">  Ipv4AddressHelper ipv4;</span><br><span class="line">  ipv4.SetBase (<span class="string">"10.1.1.0"</span>, <span class="string">"255.255.255.0"</span>);</span><br><span class="line">  Ipv4InterfaceContainer i0i3 = ipv4.Assign (d0d3);</span><br><span class="line"></span><br><span class="line">  ipv4.SetBase (<span class="string">"10.1.2.0"</span>, <span class="string">"255.255.255.0"</span>);</span><br><span class="line">  Ipv4InterfaceContainer i1i3 = ipv4.Assign (d1d3);</span><br><span class="line"></span><br><span class="line">  ipv4.SetBase (<span class="string">"10.1.3.0"</span>, <span class="string">"255.255.255.0"</span>);</span><br><span class="line">  Ipv4InterfaceContainer i2i3 = ipv4.Assign (d2d3);</span><br><span class="line"></span><br><span class="line">  ipv4.SetBase (<span class="string">"10.1.4.0"</span>, <span class="string">"255.255.255.0"</span>);</span><br><span class="line">  Ipv4InterfaceContainer i3i4 = ipv4.Assign (d3d4);</span><br><span class="line"></span><br><span class="line">  ipv4.SetBase (<span class="string">"10.1.5.0"</span>, <span class="string">"255.255.255.0"</span>);</span><br><span class="line">  Ipv4InterfaceContainer i4i5 = ipv4.Assign (d4d5);</span><br><span class="line"></span><br><span class="line">  ipv4.SetBase (<span class="string">"10.1.6.0"</span>, <span class="string">"255.255.255.0"</span>);</span><br><span class="line">  Ipv4InterfaceContainer i4i6 = ipv4.Assign (d4d6);</span><br><span class="line"></span><br><span class="line">  ipv4.SetBase (<span class="string">"10.1.7.0"</span>, <span class="string">"255.255.255.0"</span>);</span><br><span class="line">  Ipv4InterfaceContainer i4i7 = ipv4.Assign (d4d7);</span><br><span class="line"></span><br><span class="line">  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();</span><br></pre></td></tr></table></figure><h3 id="二、变量和统计指标"><a href="#二、变量和统计指标" class="headerlink" title="二、变量和统计指标"></a>二、变量和统计指标</h3><ol><li>设置数据传输速率：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncRate</span> <span class="params">(Ptr&lt;MyApp&gt; app, DataRate rate)</span></span>&#123;</span><br><span class="line">  app-&gt;ChangeRate(rate);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>每秒计算吞吐量和计算Jain平滑指数</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Throughput</span> <span class="params">(FlowMonitorHelper *fmhelper, Ptr&lt;FlowMonitor&gt; flowMon)</span></span>&#123;</span><br><span class="line">  Ptr&lt;Ipv4FlowClassifier&gt; classifier = DynamicCast&lt;Ipv4FlowClassifier&gt; (fmhelper-&gt;GetClassifier ());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;FlowId, FlowMonitor::FlowStats&gt; stats = flowMon-&gt;GetFlowStats ();</span><br><span class="line">  <span class="keyword">double</span> sumFlow = <span class="number">0</span>, sumFlowSqr = <span class="number">0</span>, sumFlowTCP = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;FlowId, FlowMonitor::FlowStats&gt;::const_iterator i = stats.<span class="built_in">begin</span> (); i != stats.<span class="built_in">end</span> (); ++i)&#123;</span><br><span class="line">    Ipv4FlowClassifier::FiveTuple t = classifier-&gt;FindFlow (i-&gt;first);</span><br><span class="line">    <span class="comment">// 计算吞吐量</span></span><br><span class="line">    <span class="keyword">double</span> TPut = i-&gt;second.rxBytes * <span class="number">8.0</span> / (i-&gt;second.timeLastRxPacket.GetSeconds() - i-&gt;second.timeFirstTxPacket.GetSeconds())/<span class="number">1000000</span>;</span><br><span class="line">    sumFlow += TPut;</span><br><span class="line">    sumFlowSqr += TPut * TPut ;</span><br><span class="line">    <span class="keyword">if</span>(t.sourceAddress == <span class="string">"10.1.1.1"</span> &amp;&amp; t.destinationAddress == <span class="string">"10.1.7.2"</span>)&#123;</span><br><span class="line">      sumFlowTCP += TPut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.sourceAddress == <span class="string">"10.1.1.1"</span> &amp;&amp; t.destinationAddress == <span class="string">"10.1.2.1"</span>)&#123;</span><br><span class="line">      sumFlowTCP += TPut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.sourceAddress == <span class="string">"10.1.6.2"</span> &amp;&amp; t.destinationAddress == <span class="string">"10.1.7.2"</span>)&#123;</span><br><span class="line">      sumFlowTCP += TPut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.sourceAddress == <span class="string">"10.1.5.2"</span> &amp;&amp; t.destinationAddress == <span class="string">"10.1.3.1"</span>)&#123;</span><br><span class="line">      sumFlowTCP += TPut;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算Jain平滑指数</span></span><br><span class="line">  <span class="keyword">double</span> FairnessIndex = (sumFlow * sumFlow)/ (<span class="number">6</span> * sumFlowSqr) ;</span><br><span class="line">  dataset.Add ((<span class="keyword">double</span>)Simulator::Now().GetSeconds(), FairnessIndex);</span><br><span class="line">  <span class="keyword">if</span>(sumFlowTCP!=<span class="number">0</span>)</span><br><span class="line">    datasetTcp.Add ((<span class="keyword">double</span>)Simulator::Now().GetSeconds(), sumFlowTCP);</span><br><span class="line">  <span class="keyword">if</span>(sumFlow-sumFlowTCP!=<span class="number">0</span>)</span><br><span class="line">    datasetUdp.Add ((<span class="keyword">double</span>)Simulator::Now().GetSeconds(), sumFlow - sumFlowTCP);</span><br><span class="line">  <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; <span class="string">" FairnessIndex: "</span> &lt;&lt; FairnessIndex &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span>;</span><br><span class="line">  Simulator::Schedule(Seconds(<span class="number">1</span>),&amp;Throughput, fmhelper, flowMon);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、实验一"><a href="#三、实验一" class="headerlink" title="三、实验一"></a>三、实验一</h3><ol><li><p>开启4个TCP New Reno流，每个流为20 Mbps</p><p><strong>4个TCP流：h1-h6、h4-h3、h1-h2、h5-h6</strong></p><p>以h1-h6为例：</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP流，h1 - h6</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port1 = <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建接收器sink</span></span><br><span class="line">  <span class="function">Address <span class="title">sinkAdd1</span> <span class="params">(InetSocketAddress (i4i7.GetAddress (<span class="number">1</span>), port1))</span></span>;</span><br><span class="line">  <span class="function">PacketSinkHelper <span class="title">packetSink1</span> <span class="params">(<span class="string">"ns3::TcpSocketFactory"</span>, InetSocketAddress (Ipv4Address::GetAny (), port1))</span></span>;</span><br><span class="line"><span class="comment">// 使用 PacketSinkHelper 的接收器应用程序，该应用程序使用port1的所有数据包</span></span><br><span class="line">  ApplicationContainer sinkApps1 = packetSink1.Install (nodes.Get (<span class="number">7</span>));</span><br><span class="line">  sinkApps1.Start (Seconds (start_time_sink));</span><br><span class="line">  sinkApps1.Stop (Seconds (run_time));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为发送方应用程序创建一个TCP Socket</span></span><br><span class="line">  Ptr&lt;Socket&gt; tcpSocket1 = Socket::CreateSocket (nodes.Get (<span class="number">0</span>), TcpSocketFactory::GetTypeId ());</span><br><span class="line">  tcpSocket1-&gt;SetAttribute(<span class="string">"SndBufSize"</span>,  ns3::UintegerValue(bufferSize));</span><br><span class="line">  tcpSocket1-&gt;SetAttribute(<span class="string">"RcvBufSize"</span>,  ns3::UintegerValue(bufferSize));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发送者应用程序</span></span><br><span class="line">  Ptr&lt;MyApp&gt; tcp_Agent1 = CreateObject&lt;MyApp&gt; ();</span><br><span class="line">  tcp_Agent1-&gt;Setup (tcpSocket1, sinkAdd1, packetSize, packetsToSend, DataRate (<span class="string">"20Mbps"</span>));</span><br><span class="line">  nodes.Get (<span class="number">0</span>)-&gt;AddApplication (tcp_Agent1);</span><br><span class="line">  tcp_Agent1-&gt;SetStartTime (Seconds (start_time_apps));</span><br><span class="line">  tcp_Agent1-&gt;SetStopTime (Seconds (run_time));</span><br></pre></td></tr></table></figure><ol start="2"><li><p>开启2个基于UDP的CBR流，每个流为20 Mbps</p><p><strong>2个UDP流：h2-h3、h4-h5</strong></p><p>以h2-h3为例</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UDP流，h2-h3</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port5 = <span class="number">8085</span>;</span><br><span class="line"><span class="comment">// 创建接收器sink</span></span><br><span class="line">  <span class="function">Address <span class="title">sinkAdd5</span> <span class="params">(InetSocketAddress (i2i3.GetAddress (<span class="number">0</span>), port5))</span></span>;</span><br><span class="line">  <span class="function">PacketSinkHelper <span class="title">packetSink5</span> <span class="params">(<span class="string">"ns3::UdpSocketFactory"</span>, InetSocketAddress (Ipv4Address::GetAny (), port5))</span></span>;</span><br><span class="line"><span class="comment">// 创建接收器应用程序，使用来自上述端口的所有数据包</span></span><br><span class="line">  ApplicationContainer sinkApps5 = packetSink5.Install (nodes.Get (<span class="number">2</span>));</span><br><span class="line">  sinkApps5.Start (Seconds (start_time_sink));</span><br><span class="line">  sinkApps5.Stop (Seconds (run_time));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建UDP Socket</span></span><br><span class="line">  Ptr&lt;Socket&gt; ns3UdpSocket5 = Socket::CreateSocket (nodes.Get (<span class="number">1</span>), UdpSocketFactory::GetTypeId ());</span><br><span class="line">  ns3UdpSocket5-&gt;SetAttribute(<span class="string">"RcvBufSize"</span>,  ns3::UintegerValue(bufferSize));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发送者应用程序</span></span><br><span class="line">  Ptr&lt;MyApp&gt; udp_Agent1 = CreateObject&lt;MyApp&gt; ();</span><br><span class="line">  udp_Agent1-&gt;Setup (ns3UdpSocket5, sinkAdd5, packetSize, packetsToSend, DataRate (<span class="string">"20Mbps"</span>));</span><br><span class="line">  nodes.Get (<span class="number">1</span>)-&gt;AddApplication (udp_Agent1);</span><br><span class="line">  udp_Agent1-&gt;SetStartTime (Seconds (start_time_apps));</span><br><span class="line">  udp_Agent1-&gt;SetStopTime (Seconds (run_time));</span><br></pre></td></tr></table></figure><ol start="3"><li>在第7秒时将其中一个UDP流（h2-h3）的速率从 20 Mbps 提高到 100 Mbps</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Simulator::Schedule (Seconds(<span class="number">7.0</span>), &amp;IncRate, udp_Agent1, DataRate(<span class="string">"100Mbps"</span>));</span><br></pre></td></tr></table></figure><ol start="4"><li><p>实验结果</p><p>实验表明：第7秒时，其中一个UDP流的速率从 20 Mbps 提高到 100 Mbps，用于统计系统带宽分配份额的公平性的Jain平滑指数急剧下    降，TCP New Reno流的吞吐量小幅度下降，UDP流急剧上升。</p><p>共享瓶颈链路时，UDP流速率变化在影响自身吞吐量的同时，也会影响同一TCP吞吐量，且对整个网络的系统资源公平共享分配造成影响。</p></li></ol><center class="half">  <img style="zoom:40%" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaaza992z1j30hs0dcjr9.jpg" class="lazyload"><img style="zoom:40%" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaazfrpn4qj30hs0dcmx1.jpg" class="lazyload"><img style="zoom:40%" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaazgapmxcj30hs0dcwed.jpg" class="lazyload"></center>  <h3 id="四、实验二"><a href="#四、实验二" class="headerlink" title="四、实验二"></a>四、实验二</h3><ol><li><p>在10个数据包到800个数据包的范围内改变缓冲区大小，重复实验一步骤</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(bufferSize=<span class="number">10</span>*packetSize;bufferSize&lt;=<span class="number">800</span>*packetSize;)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实验结果</p><p>实验表明：在10个数据包到800个数据包的范围内改变缓冲区大小，缓冲区较小时对系统带宽分配公平性、TCP、UDP的影响较大，随着缓冲区增大而分配公平性趋于稳定值，TCP、UDP的吞吐量缓慢增加。</p></li></ol><center class="half">  <img style="zoom:40%" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaazo1gpdrj30hs0dc745.jpg" class="lazyload"><img style="zoom:40%" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaazp9bsrej30hs0dc0sm.jpg" class="lazyload"><img style="zoom:40%" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaazptgk13j30hs0dca9y.jpg" class="lazyload"></center>  <h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>​    做实验的时候一开始小组内各个成员ns3下载的版本差别有点大，操作系统也各不相同，所以一开始有些成员写的东西在另外一个成员电脑里试测的时候运行失败，版本问题一定要多注意，尤其是小组项目，运行环境之类的要尽量保持一致。</p><p>​    两个实验分别表明在此网络拓扑结构下，共享瓶颈链路时，UDP流速率变化在影响自身吞吐量的同时，也会影响同一TCP吞吐量，且对整个网络的系统资源公平共享分配造成影响。同时，改变缓冲区大小可以观测出，缓冲区较小时对系统带宽分配公平性、TCP、UDP的影响较大，随着缓冲区增大而分配公平性趋于稳定值，TCP、UDP的吞吐量缓慢增加。</p><p>​    实验设计中要注意一些基本的设计规范，比如控制变量，比如可映射到真实环境中，具有一定的实验价值。如TCP流和UDP流在现实的网络中是经常同时出现并相互影响的，所以实验模拟两者相互影响的现象，而现实生活中缓冲区大小也是对两种流吞吐量和带宽份额分配公平性都会产生一定影响。</p><p>​    一学期的计算机网络实验至此就结束了，回顾整个学期，从一开始学习一些基本操作，再到通过实验熟悉各种路由器配置并模拟一些重要的网络拓扑结构和算法等，最后再结合计算机网络理论课和实验课学到的知识设计一个有意义有价值的实验，层层递进，步步深入，在整个过程中收获良多。不论是个人实验还是小组合作，都要扎实掌握理论知识，而后运用实践，遇到难题要善于思考，敏而好学，从而学到更多东西。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络实验报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2019/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="关系型数据库-NoSQL-分布式数据库"><a href="#关系型数据库-NoSQL-分布式数据库" class="headerlink" title="关系型数据库 - NoSQL - 分布式数据库"></a>关系型数据库 - NoSQL - 分布式数据库</h1><blockquote><p>参考网址：<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">百度搜索 - 数据库</a></p><p>参考网址：<a href="https://blog.csdn.net/qq_36411874/article/details/82013020" target="_blank" rel="noopener">关系型数据库与非关系型数据库Nosql区别汇总</a></p></blockquote><h2 id="发展现状"><a href="#发展现状" class="headerlink" title="发展现状"></a>发展现状</h2><p>数据库先后经历了层次数据库、网状数据库和关系数据库等各个阶段的发展，其中关系型数据库已成为目前数据库产品中最重要的一员，80年代以来，几乎所有的数据库厂商新出的数据库产品都支持关系型数据库，即使一些非关系数据库产品也几乎都有支持关系数据库的接口。这主要是传统的关系型数据库可以比较好的解决管理和存储关系型数据的问题。</p><p>随着云计算的发展和大数据时代的到来，由于越来越多的半关系型和非关系型数据需要用数据库进行存储管理，以此同时，分布式技术等新技术的出现也对数据库的技术提出了新的要求，于是越来越多的非关系型数据库就开始出现，这类数据库与传统的关系型数据库在设计和数据结构有了很大的不同，它们更强调数据库数据的高并发读写和存储大数据，这类数据库一般被称为NoSQL（Not only SQL）数据库。但传统的关系型数据库在一些传统领域依然保持了强大的生命力。</p><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。常见的关系型数据库有Mysql，SqlServer等。通过外键关联来建立表与表之间的关系。</p><p>数据库的SELECT，INSERT，UPDATE，DELETE对应了我们常用的增删改查四种操作。对于结构化数据的处理更合适，如学生成绩、地址等，这样的数据一般情况下需要使用结构化的查询，例如join，<br>这样的情况下，关系型数据库就会比NoSQL数据库性能更优，而且精确度更高。由于结构化数据的规模不算太大，数据规模的增长通常也是可预期的，所以针对结构化数据使用关系型数据库更好。关系型数据库十分注意数据操作的事务性、一致性，如果对这方面的要求关系型数据库无疑可以很好的满足。</p><p><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926113945323-238845177.png" class="lazyload"></p><h3 id="标准SQL语句"><a href="#标准SQL语句" class="headerlink" title="标准SQL语句"></a>标准SQL语句</h3><p>虽然关系型数据库有很多，但是大多数都遵循SQL（结构化查询语言，Structured Query Language）标准。常见的操作有查询，新增，更新，删除，求和，排序等。</p><ul><li>查询语句：SELECT param FROM table WHERE condition 该语句可以理解为从 table 中查询出满足 condition 条件的字段 param。</li><li>新增语句：INSERT INTO table （param1，param2，param3） VALUES （value1，value2，value3） 该语句可以理解为向table中的param1，param2，param3字段中分别插入value1，value2，value3。 </li><li>更新语句：UPDATE table SET param=new_value WHERE condition 该语句可以理解为将满足condition条件的字段param更新为 new_value 值。 [2] </li><li>删除语句：DELETE FROM table WHERE condition 该语句可以理解为将满足condition条件的数据全部删除。</li><li>去重查询：SELECT DISTINCT param FROM table WHERE condition 该语句可以理解为从表table中查询出满足条件condition的字段param，但是param中重复的值只能出现一次。 </li><li>排序查询：SELECT param FROM table WHERE condition ORDER BY param1该语句可以理解为从表table 中查询出满足condition条件的param，并且要按照param1升序的顺序进行排序。</li></ul><h2 id="非关系型数据库-NoSQL"><a href="#非关系型数据库-NoSQL" class="headerlink" title="非关系型数据库(NoSQL)"></a>非关系型数据库(NoSQL)</h2><p>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库中，我们查询一条数据，结果出来一个数组，关系型数据库中，查询一条数据结果是一个对象。</p><p>随着近些年技术方向的不断拓展，大量的NoSql数据库如MongoDB、Redis、Memcache出于简化数据库结构、避免冗余、影响性能的表连接、摒弃复杂分布式的目的被设计。</p><p><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114007198-781865994.png" class="lazyload"></p><p>NoSQL是分布式的、非关系型的、不保证遵循ACID原则的数据存储系统。NoSQL数据库技术与<code>CAP理论、一致性哈希算法</code>有密切关系。</p><ul><li><p>CAP理论：简单来说就是一个分布式系统不可能满足可用性、一致性与分区容错性这三个要求，一次性满足两种要求是该系统的上限。</p></li><li><p>一致性哈希算：指的是NoSQL数据库在应用过程中，为满足工作需求而在通常情况下产生的一种数据算法，该算法能有效解决工作方面的诸多问题但也存在弊端，即工作完成质量会随着节点的变化而产生波动，当节点过多时，相关工作结果就无法那么准确。这一问题使整个系统的工作效率受到影响，导致整个数据库系统的数据乱码与出错率大大提高，甚至会出现数据节点的内容迁移，产生错误的代码信息。</p></li></ul><p>但尽管如此，NoSQL数据库技术还是具有非常明显的应用优势，如数据库结构相对简单，在大数据量下的读写性能好；能满足随时存储自定义数据格式需求，非常适用于大数据处理工作。</p><p>NoSQL数据库适合追求速度和可扩展性、业务多变的应用场景。对于非结构化数据的处理更合适，如文章、评论，这些数据如全文搜索、机器学习通常只用于模糊处理，并不需要像结构化数据一样，进行精确查询，而且这类数据的数据规模往往是海量的，数据规模的增长往往也是不可能预期的，而NoSQL数据库的扩展能力几乎也是无限的，所以NoSQL数据库可以很好的满足这一类数据的存储。NoSQL数据库利用key-value可以大量的获取大量的非结构化数据，并且数据的获取效率很高，但用它查询结构化数据效果就比较差。</p><h3 id="NoSQL数据库分类"><a href="#NoSQL数据库分类" class="headerlink" title="NoSQL数据库分类"></a>NoSQL数据库分类</h3><p>目前NoSQL数据库仍然没有一个统一的标准，它现在有四种大的分类：</p><ul><li>键值对存储（key-value）：代表软件Redis，它的优点能够进行数据的快速查询，而缺点是需要存储数据之间的关系。<br><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114118589-2082748939.png" class="lazyload"></li><li>列存储：代表软件Hbase，它的优点是对数据能快速查询，数据存储的扩展性强。而缺点是数据库的功能有局限性。<br><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114133792-1420784459.png" class="lazyload"></li><li>文档数据库存储：代表软件MongoDB，它的优点是对数据结构要求不特别的严格。而缺点是查询性的性能不好，同时缺少一种统一查询语言。<br><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114108995-605863133.png" class="lazyload"></li><li>图形数据库存储：代表软件InfoGrid，它的优点可以方便的利用图结构相关算法进行计算。而缺点是要想得到结果必须进行整个图的计算，而且遇到不适合的数据模型时，图形数据库很难使用。<br><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114142948-896683327.png" class="lazyload"></li></ul><h2 id="关系型数据库与NoSQL的区别"><a href="#关系型数据库与NoSQL的区别" class="headerlink" title="关系型数据库与NoSQL的区别"></a>关系型数据库与NoSQL的区别</h2><table><thead><tr><th align="center">区别</th><th align="left">关系型数据库</th><th align="left">非关系型数据库（Nosql）</th></tr></thead><tbody><tr><td align="center">存储方式</td><td align="left">表格式存储。存储在表的行和列中。他们之间很容易关联协作存储，提取数据很方便</td><td align="left">Nosql数据库则与其相反，他是大块的组合在一起。通常存储在数据集中，就像文档、键值对或者图结构。</td></tr><tr><td align="center">存储结构</td><td align="left"><code>结构化数据</code>。数据表都预先定义了结构（列的定义），结构描述了数据的形式和内容。这一点对数据建模至关重要，虽然预定义结构带来了可靠性和稳定性（优点），但是修改这些数据比较困难（缺点）。</td><td align="left">而Nosql数据库基于动态结构，使用<code>非结构化数据</code>。因为Nosql数据库是动态结构，可以很容易适应数据类型和结构的变化。</td></tr><tr><td align="center">存储规范</td><td align="left">数据存储为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。虽然管理起来很清晰，但是单个操作设计到多张表的时候，数据管理就显得有点麻烦</td><td align="left">而Nosql数据存储在平面数据集中，数据经常可能会重复。单个数据库很少被分隔开，而是存储成了一个整体，这样整块数据更加便于读写</td></tr><tr><td align="center">存储扩展</td><td align="left">系型数据库是<code>纵向扩展</code>，也就是说想要提高处理能力，要使用速度更快的计算机。因为数据存储在关系表中，操作的性能瓶颈可能涉及到多个表，需要通过提升计算机性能来克服。虽然有很大的扩展空间，但是最终会达到纵向扩展的上限</td><td align="left">而Nosql数据库是<code>横向扩展</code>的，它的存储天然就是分布式的，可以通过给资源池添加更多的普通数据库服务器来分担负载。</td></tr><tr><td align="center">查询方式</td><td align="left">结构化查询语言来操作数据库（就是我们通常说的SQL），使用关系型数据库表中<code>主键</code>，关系型数据库使用预定义优化方式（比如索引）来加快查询操作</td><td align="left">以块为单元操作数据，使用的是非结构化查询语言（UnQl），它是没有标准的，使用Nosql中存储文档的<code>D</code>,是更简单更精确的数据访问模式</td></tr><tr><td align="center">事务</td><td align="left">遵循<code>ACID规则</code>（原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)），支持对事务原子性细粒度控制，并且易于回滚事务。</td><td align="left">遵循<code>BASE原则</code>（基本可用（Basically Availble）、软/柔性事务（Soft-state ）、最终一致性（Eventual Consistency））Nosql数据库是在CAP（一致性、可用性、分区容忍度）中任选两项，因为基于节点的分布式系统中，很难全部满足，所以对事务的支持不是很好，虽然也可以使用事务，但是并不是Nosql的闪光点。</td></tr><tr><td align="center">性能</td><td align="left">为了维护数据的一致性付出了巨大的代价，读写性能比较差。在面对高并发读写性能非常差，面对海量数据的时候效率非常低。</td><td align="left">Nosql存储的格式都是key-value类型的，并且存储在内存中，非常容易存储，而且对于数据的 一致性是 弱要求。Nosql无需sql的解析，提高了读写性能。</td></tr><tr><td align="center">授权方式</td><td align="left">关系型数据库通常有SQL Server，Mysql，Oracle。大多数的关系型数据库都是付费的并且价格昂贵，成本较大。</td><td align="left">主流的Nosql数据库有redis，memcache，MongoDb。Nosql数据库通常都是开源的。</td></tr></tbody></table><h2 id="关系型数据库与NoSQL优缺点对比"><a href="#关系型数据库与NoSQL优缺点对比" class="headerlink" title="关系型数据库与NoSQL优缺点对比"></a>关系型数据库与NoSQL优缺点对比</h2><table><thead><tr><th align="center">类型</th><th align="left">关系型数据库 SQLite、Oracle、mysql</th><th align="left">非关系型数据库MongoDb、redis、HBase</th></tr></thead><tbody><tr><td align="center">特性</td><td align="left">1. 关系型数据库，是指采用了关系模型来组织数据的数据库；<br> 2. 关系型数据库的最大特点就是事务的一致性；<br> 3. 简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</td><td align="left">1. 使用键值对存储数据；<br> 2. 分布式；<br> 3. 一般不支持ACID特性；<br> 4. 非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</td></tr><tr><td align="center">优点</td><td align="left">1. 容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2. 使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3. 易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br> 4. 复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</td><td align="left">1. 速度快：无需经过sql层的解析，读写性能很高，nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>2. 高扩展性：基于键值对，数据没有耦合性，容易扩展；<br>3. 数据存储格式灵活：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。<br>4. 成本低：nosql数据库部署简单，基本都是开源软件。</td></tr><tr><td align="center">缺点</td><td align="left">1. 为了维护一致性所付出的巨大代价就是其读写性能比较差，尤其是海量数据的高效率读写；<br>2. 固定的表结构，灵活度稍欠；<br>3. 高并发读写需求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈；<br> 4. 难以进行海量数据的高效率读写；</td><td align="left">1. 不提供sql支持，学习和使用成本较高；<br>2. 无事务处理，附加功能bi和报表等支持也不好；</td></tr></tbody></table><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>所谓的分布式数据库技术，就是结合了数据库技术与分布式技术的一种结合。具体指的是把那些在地理意义上分散开的各个数据库节点，但在计算机系统逻辑上又是属于同一个系统的数据结合起来的一种数据库技术。既有着数据库间的协调性也有着数据的分布性。这个系统并不注重系统的集中控制，而是注重每个数据库节点的自治性，此外为了让程序员能够在编写程序时可以减轻工作量以及系统出错的可能性，一般都是完全不考虑数据的分布情况，这样的结果就使得系统数据的分布情况一直保持着透明性。 </p><p>数据独立性概念在分布式数据库管理系统中同样是十分重要的一环，但是不仅如此，分布式数据管理系统还增加了一个叫分布式透明性的新概念。这个新概念的作用是让数据进行转移时使程序正确性不受影响，就像数据并没有在编写程序时被分布一样。 </p><p>在分布式数据库里，数据冗杂是一种被需要的特性，这点和一般的集中式数据库系统不一样。第一点是为了提高局部的应用性而要在那些被需要的数据库节点复制数据。第二点是因为如果某个数据库节点出现系统错误，在修复好之前，可以通过操作其他的数据库节点里复制好的数据来让系统能够继续使用，提高系统的有效性。 </p><h1 id="数据库常见面试知识总结"><a href="#数据库常见面试知识总结" class="headerlink" title="数据库常见面试知识总结"></a>数据库常见面试知识总结</h1><p>这里是一些面试相关时数据库相关知识</p><blockquote><p>参考网址：<a href="https://github.com/huihut/interview#-%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">Github - 面试基础知识总结</a></p></blockquote><blockquote><p>本节部分知识点来自《数据库系统概论（第 5 版）》</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>数据（data）：描述事物的符号记录称为数据。</li><li>数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。</li><li>数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。</li><li>数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。</li><li>属性（attribute）：实体所具有的某一特性称为属性。</li><li>码（key）：唯一标识实体的属性集称为码。</li><li>实体（entity）：客观存在并可相互区别的事物称为实体。</li><li>实体(类)型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体(类)型。</li><li>实体集（entity set）：同一实体型的集合称为实体集。</li><li>联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。</li><li>模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li><li>外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li><li>内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。</li></ul><h2 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h2><ul><li>层次模型（hierarchical model）</li><li>网状模型（network model）</li><li>关系模型（relational model）<ul><li>关系（relation）：一个关系对应通常说的一张表</li><li>元组（tuple）：表中的一行即为一个元组</li><li>属性（attribute）：表中的一列即为一个属性</li><li>码（key）：表中可以唯一确定一个元组的某个属性组</li><li>域（domain）：一组具有相同数据类型的值的集合</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，一般表示为 <code>关系名(属性1, 属性2, ..., 属性n)</code></li></ul></li><li>面向对象数据模型（object oriented data model）</li><li>对象关系数据模型（object relational data model）</li><li>半结构化数据模型（semistructure data model）</li></ul><h2 id="常用-SQL-操作"><a href="#常用-SQL-操作" class="headerlink" title="常用 SQL 操作"></a>常用 SQL 操作</h2><table>  <tr>    <th>对象类型</th>    <th>对象</th>    <th>操作类型</th>  </tr>  <tr>    <td rowspan="4">数据库模式</td>    <td>模式</td>    <td><code>CREATE SCHEMA</code></td>  </tr>  <tr>    <td>基本表</td>    <td><code>CREATE SCHEMA</code>，<code>ALTER TABLE</code></td>  </tr>    <tr>    <td>视图</td>    <td><code>CREATE VIEW</code></td>  </tr>    <tr>    <td>索引</td>    <td><code>CREATE INDEX</code></td>  </tr>    <tr>    <td rowspan="2">数据</td>    <td>基本表和视图</td>    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>  </tr>    <tr>    <td>属性列</td>    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>  </tr></table><br><br><blockquote><p>SQL 语法教程：<a href="http://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">菜鸟Runoob - SQL 教程</a></p></blockquote><blockquote><p>DB2 教程：<a href="https://www.yiibai.com/db2/db2_databases.html" target="_blank" rel="noopener">易百 - DB2 教程</a></p></blockquote><h2 id="关系型数据库-1"><a href="#关系型数据库-1" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><ul><li><p>基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改</p></li><li><p>关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性。</p><ul><li>实体完整性：要求每个数据表都必须有主键，而作为主键的所有字段，其属性必须是独一及非空值。</li><li>参照完整性：相关联的两个表之间的约束，要求关系中不允许引用不存在的实体。</li><li>用户定义的完整性：用户自定义完整性是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。主要包括非空约束、唯一约束、检查约束、主键约束、外键约束</li></ul></li><li><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3></li><li><p>数据库索引：顺序索引、B+ 树索引、hash 索引</p></li><li><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></p></li></ul><h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><ul><li>数据库的完整性是指数据的正确性和相容性。<ul><li>完整性：为了防止数据库中存在不符合语义（不正确）的数据。</li><li>安全性：为了保护数据库防止恶意破坏和非法存取。</li></ul></li><li>触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。</li></ul><h2 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h2><ul><li>数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。</li><li>最重要的数据依赖：函数依赖、多值依赖。</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li>第一范式（1NF）：属性（字段）是最小单位不可再分。</li><li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。</li><li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）。</li><li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。</li><li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。</li></ul><h2 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h2><ul><li>事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li><li>事物的 ACID 特性：原子性、一致性、隔离性、持续性。</li><li>恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。</li><li>建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。</li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul><li>事务是并发控制的基本单位。</li><li>并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。</li><li>并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。</li><li>基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。</li><li>活锁死锁：<ul><li>活锁：事务永远处于等待状态，可通过先来先服务的策略避免。</li><li>死锁：事物永远不能结束<ul><li>预防：一次封锁法、顺序封锁法；</li><li>诊断：超时法、等待图法；</li><li>解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。</li></ul></li></ul></li><li>可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。</li></ul><h1 id="常见大型数据库"><a href="#常见大型数据库" class="headerlink" title="常见大型数据库"></a>常见大型数据库</h1><blockquote><p>参考网址：<a href="https://blog.csdn.net/jxcjxinxing/article/details/2088900" target="_blank" rel="noopener">常用大型数据库比较</a></p></blockquote><p>目前商品化的数据库管理系统以关系型数据库为主导产品，技术比较成熟。国际国内的主导关系型数据库管理系统有ORACLE、SYBASE、INFORMIX和INGRES。这些产品都支持多平台，如UNIX、VMS、 WINDOWS，但支持的程度不一样。</p><p>IBM 的 DB2 也是成熟的关系型数据库。但是，DB2是内嵌于IBM的 AS/400系列机中，只支持OS/400操作系统。</p><p>根据选择数据库管理系统的依据，我们比较、分析一下这几种数据库管理系统的性能：</p><h2 id="ORACLE数据库管理系统"><a href="#ORACLE数据库管理系统" class="headerlink" title="ORACLE数据库管理系统"></a>ORACLE数据库管理系统</h2><ul><li>无范式要求，可根据实际系统需求构造数据库。</li><li>采用标准的SQL结构化查询语言。</li><li>具有丰富的开发工具，覆盖开发周期的各阶段。</li><li>支持大型数据库，数据类型支持数字、字符、大至2GB的二进制数<br>据，为数据库的面向对象存储提供数据支持。</li><li>具有第四代语言的开发工具（SQL<em>FORMS、SQL</em>REPORTS、SQL*MENU等）。</li><li>具有字符界面和图形界面，易于开发。ORACLE7。1版本具有面<br>向对象的开发环境CDE2。</li><li>通过SQL*DBA控制用户权限，提供数据保护功能，监控数据库的<br>运行状态，调整数据缓冲区的大小。</li><li>分布优化查询功能。</li><li>具有数据透明、网络透明，支持异种网络、异构数据库系统。并行<br>处理采用动态数据分片技术。</li><li>支持客户机/服务器体系结构及混合的体系结构（集中式、分布式、<br>客户机/服务器）。</li><li>实现了两阶段提交、多线索查询手段。</li><li>支持多种系统平台（HPUX、SUNOS、OSF/1、VMS、<br>WINDOWS、WINDOWS/NT、OS/2）。</li><li>数据安全保护措施：没有读锁，采取快照SNAP方式完全消除了分<br>布读写冲突。自动检测死锁和冲突并解决。</li><li>数据安全级别为C2级（最高级）。</li><li>数据库内模支持多字节码制，支持多种语言文字编码。</li><li>具有面向制造系统的管理信息系统和财务系统应用系统。</li><li>ORACLE7。1版本服务器支持1000—10000个用户。<br>WORKGROUP/2000具有ORACLE7WORKGROUP服务器，<br>POWER OBJECTS（图形开发环境，支持OS/2、UNIX、 WINDOWS/NT平台。</li><li>在中国的销售份额占50%以上。</li></ul><h2 id="DB2数据库管理系统"><a href="#DB2数据库管理系统" class="headerlink" title="DB2数据库管理系统"></a>DB2数据库管理系统</h2><p>DB2是内嵌于IBM的AS/400系统上的数据库管理系统，直接由硬件支持。它支持标准的SQL语言，具有与异种数据库相连的GATEWAY。因此它具有速度快、可靠性好的优点。</p><p>但是，只有硬件平台选择了IBM的AS/400，才能选择使用DB2数据库管理系统。</p><h2 id="SYBASE-10-数据库管理系统"><a href="#SYBASE-10-数据库管理系统" class="headerlink" title="SYBASE 10 数据库管理系统"></a>SYBASE 10 数据库管理系统</h2><p>SYBASE数据库系统从1992年11月开始开发，历经12 — 24个月的开发形成产品，产品包括：SQL SERVER 10（数据库管理系统的核心），REPLICATION SERVER（实现数据库分布的服务器），BACKUP SERVER（网络环境下的快速备份服务器），OMINI SQL GATEWAY（异构数据库库关）， NAVIGATION SERVER（网络上可扩充的并行处理能力服务器），CONTROL SERVER（数据库管理员服务器）。属于客户机/服务器体系结构，提供了在网络环境下的各节点上的数据库数据的互访。</p><h3 id="SYBASE的技术特点"><a href="#SYBASE的技术特点" class="headerlink" title="SYBASE的技术特点"></a>SYBASE的技术特点</h3><ul><li>完全的客户机/服务器体系结构，能适应OLTP（ON—LINE<br>TRANSACTION PROCESSING）要求，能为数百用户提供高性能需求。</li><li>采用单进程多线索（SINGLE PORCESS AND MULTI—THREADED）<br>技术进行查询，节省系统开销，提高内存的利用率。</li><li>支持存储过程，客户只需通过网络发出执行请求，就可马<br>上执行，有效地加快了数据库访问速度，明显减少网络通讯量，<br>有可能极大的改善网络环境的运行效率，增加数据库的服务容量。</li><li>虚服务器体系结构与对称多处理器（SMP）技术结合，充分发<br>挥多CPU硬件平台的高性能。</li><li>数据库管理系统DBA在线调整监控数据库系统的性能。</li><li>提供日志与数据库的镜象，提高数据库容错能力。</li><li>支持计算机蔟族（CLUSTER）环境下的快速故障切换。</li><li>通过存储和触发器（TRIGGER）由服务器制约数据的完整性。</li><li>多种安全机制对表、视图、存储过程、命令进行授权。</li><li>分布式事务处理采用2PC（TWO PHASE COMMIT）技术访问</li><li>支持IMAGE和TEXT的数据类型，为工程数据库和多媒体应<br>用提供了良好的基础。</li></ul><h3 id="SYBASE的开发工具"><a href="#SYBASE的开发工具" class="headerlink" title="SYBASE的开发工具"></a>SYBASE的开发工具</h3><ul><li>DATA WORKBENCH</li><li>VISUAL QUERY LANGUANGE（图形查询语言）</li><li>REPORT WORKBENCH（报表系统）</li><li>INTERACTIVE SQL（交互式SQL环境）</li><li>DATA ENTRY（快速录入数据）<br>APT WORKBENCH<br>EMBEDED SQL</li><li>SQR WORKBENCH（开放式报表系统）</li><li>EASY SQR（基于菜单的报表生成器）</li><li>SQR 4GL（第四代语言报表生成器）</li><li>SQR DEBUG（调试工具）</li><li>SQL—EXECUTE（动态表格配置）<br>GAIN MOMENTUM（面向对象的多媒体开发平台，可以<br>编辑动画、声音、位图）</li></ul><h3 id="SYBASE的不足"><a href="#SYBASE的不足" class="headerlink" title="SYBASE的不足"></a>SYBASE的不足</h3><ul><li>多服务器系统不支持分布透明</li><li>REPLICATION SERVER数据方面的性能较差，并不能<br>与操作系统集成</li><li>对中文的支持较差</li><li>多用于银行系统等</li><li>尚无在此数据库基础上的企业管理信息系统</li></ul><h2 id="INGRES智能关系性数据库管理系统"><a href="#INGRES智能关系性数据库管理系统" class="headerlink" title="INGRES智能关系性数据库管理系统"></a>INGRES智能关系性数据库管理系统</h2><p>INGRES数据库系统的多项技术直接采用了伯克利大学最新研究成果。技术上一直处于领先水平。INGRES数据库不仅能管理数据，而且还能管理知识和对象（对象是指数据与操作的结合体，计算机把他们作为整体处理）。 </p><p>INGRES产品分为三类：第一类为数据库基本系统，包括了数据管理、知识管理、和对象管理。第二类为开发工具。第三类为开放互联产品。</p><h3 id="INGRES的特点"><a href="#INGRES的特点" class="headerlink" title="INGRES的特点"></a>INGRES的特点</h3><ul><li>开放的客户机/服务器体系结构，允许用户建立多个多线索服务器。</li><li>编译的数据库过程。数据库过程用INGRES第四代语言编<br>写。由服务器编译管理，用来实现预定义的事务处理，减小CPU负载，减小网络开销。</li><li>智能优化功能。根据查询语言的要求自动地在网络环境中调 整查询顺序，寻找最佳路径。</li><li>数据的在线备份。无需中断系统的正常运行，备份保持一致性的数据库备份。</li><li>I/O减量处理。提供快速提交、成组提交、多块读出与写入的技术。减少I/O量。</li><li>多文件存储数据。一个表用一个文件存储，便于在异常情况下对数据库存进行恢复。</li><li>采用两阶段提交协议，保证了网络分布事务的一致性。</li><li>具有数据库规则系统。自动激活满足行为条件的规则，对每个表拥有的独立规则数不受限制，</li><li>无限制的向前推理和无限递归，确保数据库的一致性。</li><li>具有报警系统，当数据在规定的数据量极限时，自动作出相应的操作。</li><li>资源控制与查询优化相结合，由服务器控制查询的资源消耗，确保系统的可预测性能。</li><li>能够对用户自己定义的数据类型进行处理、存储，定义数据的有效区间。</li><li>允许用户将自己定义的函数嵌入到数据库管理系统中。</li></ul><h3 id="INGRES的开发工具"><a href="#INGRES的开发工具" class="headerlink" title="INGRES的开发工具"></a>INGRES的开发工具</h3><ul><li>INGRES/WINDOWS 4GL，该工具通过面向对象的第四代语言和调试器，提高程序员的生产率。支持MICROSOFT WINDOWS、OPEN LOOK、DECWIN等窗口环境。 </li><li>INGRES/VISION。是应用代码生成器，包括支持高级界面特征（应用结构的图形表示、菜单驱动、在线HELP、有效数据的动态选择）。还允许用户调整生成的代码。用户决策支持工具。包括GQL（GRAPHIC QUERY LANGUAGE）、GRAFSMAN、IPM（INTERACTIVE PERFORMANCE MONITOR </li><li>INGRES/NET，是一种基于全局通信体系结构，能与OSI兼容的客户机/服务器通信协议。支持诗句的透明性、网络的透明性、多平台透明性。 </li><li>INGRE/STAR，是一种分布信息管理机制，他允许用户将分布在不同场地的数据库视为整体，为分布式数据库提供多数据库存的集成、分布数据字典、分布 查询优化、分布处理。 </li><li>INGRES/GATEWAY，非INGRES数据库系统与INGRES数据库互联产品。</li><li>INGRES ENHANCED SECURITY增强保安系统，按美国B1 安全指标设计的安全系统，满足数据一致性、可用性、可信性要求，具有行层标签、底层多层安全系统、安全标签数据类型和复杂的一致性机制。</li></ul><h3 id="INGRES的不足"><a href="#INGRES的不足" class="headerlink" title="INGRES的不足"></a>INGRES的不足</h3><p>学术价值大于实用价值。即在学术方面掌握领先技术，在产品服务上比较薄弱。</p><h2 id="INFORMIX数据库管理系统"><a href="#INFORMIX数据库管理系统" class="headerlink" title="INFORMIX数据库管理系统"></a>INFORMIX数据库管理系统</h2><p>INFORMIX运行在UNIX平台，支持SUNOS、HPUX、 ALFAOSF/1。采用双引擎机制，占用资源小，简单易用。适用于中小型数据库管理。</p><h3 id="INFORMIX的特点"><a href="#INFORMIX的特点" class="headerlink" title="INFORMIX的特点"></a>INFORMIX的特点</h3><ul><li>DSA（DYMANIC SCALABLE ARCHITECTURE）动态可调整结构支持SMP查询语句</li><li>多线索查询机制</li><li>具有三个任务队列</li><li>具有虚拟处理器</li><li>提供并行索引功能，是高性能的OLTP数据库</li><li>数据物理结构为静态分片</li><li>支持双机簇族（CLUSTER）（只支持SESQUENT 平台）</li><li>具有对复杂系统应用开发的INFORMIX 4GL CADE工具</li></ul><h3 id="INFORMIX的主要产品"><a href="#INFORMIX的主要产品" class="headerlink" title="INFORMIX的主要产品"></a>INFORMIX的主要产品</h3><ul><li>INFORMIX—SE</li><li>INFORMIX—ONLINE</li><li>INFORMIX—SQL</li><li>INFORMIX—4GL</li><li>INFORMIX—OPEN CASE/TOOL BUS</li><li>INFORMIX—VIEW POINT</li><li>INFORMIX—STAR</li><li>INFORMIX—NET</li><li>INFORMIX—GATEWAY</li></ul><h3 id="INFORMIX的不足"><a href="#INFORMIX的不足" class="headerlink" title="INFORMIX的不足"></a>INFORMIX的不足</h3><ul><li>网络性能不好，不支持异种网络。即只支持数据透明不支持网络透明。</li><li>并发控制易死锁。</li><li>数据备份具有软件镜象功能，速度慢、可靠性差。</li><li>对大型数据库系统不能得到很好的性能。</li><li>开发工具不成熟，只具有字符界面，多媒体数据弱，无覆盖全开发过程的CASE工具。</li><li>无CLIENT/SERVER分布式处理模式</li><li>可移植性差，不同版本的数据结构不兼容。</li><li>4GL与CADE的代码不可移植。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ebook微服务学习笔记</title>
      <link href="/2019/11/12/ebook%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
      <url>/2019/11/12/ebook%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>这里是构建基于微服务的ebook的一些记录。将会继续更新</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://www.bilibili.com/video/av74750602?p=46" target="_blank" rel="noopener">黑马乐优项目12月视频合集</a>：[45]搭建聚合工程及注册中心,[46]搭建聚合工程及注册中心,[47]添加路由规则,[56-73]vue学习,[76]运行后台管理前端工程,[77]同一环境,[78]域名访问项目,[79]nginx</p></li><li><p><a href="https://www.bilibili.com/video/av29882762?p=4" target="_blank" rel="noopener">千锋教育iToken视频合集</a>：敏捷开发、XP、部署持续集成、nginx反向代理</p></li></ol><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>才发现居然没有用Docker。。。</p><p><img alt="乐优架构图" data-src="https://wx3.sinaimg.cn/mw690/007CtYmwgy1g8vqesx7l2j30pt0smdjz.jpg" class="lazyload"></p><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><h4 id="nginx-千锋iToken笔记"><a href="#nginx-千锋iToken笔记" class="headerlink" title="nginx(千锋iToken笔记)"></a>nginx(千锋iToken笔记)</h4><p>nginx像一个伪CDN，功能有：</p><ol><li>服务器：要通过浏览器请求，就必须有一个服务器比如tomcat。tomcat既是一个服务器也是一个servler容器，但nginx就是一个静态服务器</li><li>虚拟主机：一个服务器上虚拟出多个网站，例如个人网站使用的虚拟主机，tomcat也有这个功能，多配几个host就多了几个虚拟主机</li><li>反向代理、负载均衡：多并发时，需要多台服务器集群时可以用nginx时可以用它反向代理，且可以使得多台服务器平均分担负载</li></ol><h2 id="开发填坑"><a href="#开发填坑" class="headerlink" title="开发填坑"></a>开发填坑</h2><h4 id="sudo-nginx报错"><a href="#sudo-nginx报错" class="headerlink" title="sudo nginx报错"></a>sudo nginx报错</h4><p>原因是8080端口被占用。报错如图所示：<br><img alt data-src="https://wx4.sinaimg.cn/mw690/007CtYmwgy1g8vqe6vq2zj30vi04040g.jpg" class="lazyload"></p><p>解决方法如下：</p><ul><li><p>8080端口被占用，根据进程PID(38871)关闭进程</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">kill</span> -9 38871</span><br></pre></td></tr></table></figure></li><li><p>重新启动nginx：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo nginx -c /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>浏览器中打开 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>，启动成功</p></li><li><p>打开nginx.conf文件进行编辑</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ open /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>修改nginx后输入  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure></li></ul><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>接下来要实现用nginx管理zuul网关，后台api赶快连一下。</p><h2 id="随笔记录"><a href="#随笔记录" class="headerlink" title="随笔记录"></a>随笔记录</h2><p>上传了一下项目到github上，收到了24封dependabot邮件,有空看一下</p><p>乐优是通过更改host为leyou.com来实现伪域名的，目前停在了这里。</p><p>nginx的作用是用来管理zuul网关，用于实现高可用性。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发备忘录</title>
      <link href="/2019/11/12/%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>/2019/11/12/%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="git与github"><a href="#git与github" class="headerlink" title="git与github"></a>git与github</h3><p>参考视频：<a href="https://www.bilibili.com/video/av55780016?p=3" target="_blank" rel="noopener">bilibili：1小时玩转 Git/Github</a></p><h4 id="保存到远程仓库"><a href="#保存到远程仓库" class="headerlink" title="保存到远程仓库"></a>保存到远程仓库</h4><ol><li>新建一个仓库后，在电脑创建一个空文件[如/code]，然后cd到该文件，终端里输入, <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> code</span><br><span class="line">$ git <span class="built_in">clone</span> &lt;&lt;iwork项目的SSH或HTTPS&gt;&gt;</span><br></pre></td></tr></table></figure></li><li>cd到[/code/iwork]下，输入sudo git status查看状态<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> iwork</span><br></pre></td></tr></table></figure></li><li>在本地文件夹里增加文件，然后输入sudo git add &lt;文件名.md&gt;或sudo git add .此时文件保存到git的index中，但是还没有同步到远程上。此时sudo git status查看一下状态，会发现新文件但没有commit。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo git add .</span><br></pre></td></tr></table></figure></li><li>输入sudo git commit  -m “the message you want when commit”，可以sudo git status查看一下状态，文件已经commit <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo git commit  -m “the message you want when commit”</span><br></pre></td></tr></table></figure></li><li>输入 git push 后github上远程可见 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure></li></ol><h3 id="Mac查看IP地址和MAC"><a href="#Mac查看IP地址和MAC" class="headerlink" title="Mac查看IP地址和MAC"></a>Mac查看IP地址和MAC</h3><ol><li>终端输入ifconfig然后回车   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo git commit  -m “the message you want when commit”</span><br></pre></td></tr></table></figure></li><li>其中“eth0”表示以太网网卡，“lo0”表示环回地址。下图的以太网网卡IP地址是“192.168.239.141”，MAC地址是38:0c:29:26:bc:07”</li></ol><p><img alt data-src="/Users/hamster/Desktop/Life/github/iBlog/iBlog/source/_posts/images/20191113_1.jpg" class="lazyload"></p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h4 id="创建SSH"><a href="#创建SSH" class="headerlink" title="创建SSH"></a>创建SSH</h4><h1 id="DB2"><a href="#DB2" class="headerlink" title="DB2"></a>DB2</h1><p>编译因含有中文乱码<br><code>javac -encoding UTF-8 XXX.java</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DB2-数据库最新研究</title>
      <link href="/2019/11/11/DB2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%80%E6%96%B0%E7%A0%94%E7%A9%B6/"/>
      <url>/2019/11/11/DB2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%80%E6%96%B0%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库最新进展"><a href="#数据库最新进展" class="headerlink" title="数据库最新进展"></a>数据库最新进展</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Butterfly的建站日志</title>
      <link href="/2019/11/10/%E5%9F%BA%E4%BA%8EButterfly%E7%9A%84%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
      <url>/2019/11/10/%E5%9F%BA%E4%BA%8EButterfly%E7%9A%84%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d // 部署到github</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h1 id="根据Butterfly文档进行配置"><a href="#根据Butterfly文档进行配置" class="headerlink" title="根据Butterfly文档进行配置"></a>根据Butterfly文档进行配置</h1><p>文档网址：<a href="[https://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B](https://jerryc.me/posts/21cfbf15/#快速開始)">hexo-butterfly文档</a></p><h2 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h2><h3 id="主页文章节选"><a href="#主页文章节选" class="headerlink" title="主页文章节选"></a>主页文章节选</h3><p>主页文章节选只支持自动节选和文章页description两种，此处设置为文章页description，关闭了自动节选，因为文字和代码块等的显示可能因此导致不正常。</p><h3 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h3><p>尚未设置，请参考文档的3.7-3.11</p><p>link:  <a href="https://jerryc.me/posts/21cfbf15/#文章相關項" target="_blank" rel="noopener">Butterfly文档</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">post_copyright:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  license: CC BY-NC-SA 4.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/</span><br></pre></td></tr></table></figure><h3 id="post的img"><a href="#post的img" class="headerlink" title="post的img"></a>post的img</h3><p>现在通过Typora+iPic上传图片为微博图片</p><h3 id="note的示例效果预览"><a href="#note的示例效果预览" class="headerlink" title="note的示例效果预览"></a>note的示例效果预览</h3><p><a href="https://theme-next.org/docs/tag-plugins/note" target="_blank" rel="noopener">点击这里查看note官方文档</a></p><div class="note ">            <h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>(without define class style)</p>          </div><div class="note default">            <h4 id="Default-Header"><a href="#Default-Header" class="headerlink" title="Default Header"></a>Default Header</h4><p>Welcome to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note primary">            <h4 id="Primary-Header"><a href="#Primary-Header" class="headerlink" title="Primary Header"></a>Primary Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note info">            <h4 id="Info-Header"><a href="#Info-Header" class="headerlink" title="Info Header"></a>Info Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note success">            <h4 id="Success-Header"><a href="#Success-Header" class="headerlink" title="Success Header"></a>Success Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note warning">            <h4 id="Warning-Header"><a href="#Warning-Header" class="headerlink" title="Warning Header"></a>Warning Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note danger">            <h4 id="Danger-Header"><a href="#Danger-Header" class="headerlink" title="Danger Header"></a>Danger Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note info no-icon">            <h4 id="No-icon-note"><a href="#No-icon-note" class="headerlink" title="No icon note"></a>No icon note</h4><p>Note <strong>without</strong> icon: <code>note info no-icon</code></p><p>note info, note info, note info<br>note info, note info, note info<br>note info, note info, note info</p>          </div><div class="note success">            <h4 id="Codeblock-in-note"><a href="#Codeblock-in-note" class="headerlink" title="Codeblock in note"></a>Codeblock in note</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br></pre></td></tr></table></figure>          </div><div class="note default">            <h4 id="Lists-in-note"><a href="#Lists-in-note" class="headerlink" title="Lists in note"></a>Lists in note</h4><ul><li>ul</li><li>ul<ul><li>ul</li><li>ul</li></ul></li><li>ul</li></ul><ol><li>ol</li><li>ol<ol><li>ol</li><li>ol</li></ol></li><li>ol</li></ol>          </div><h4 id="Table-in-Note"><a href="#Table-in-Note" class="headerlink" title="Table in Note"></a>Table in Note</h4><div class="note default">            <table><thead><tr><th>1</th><th>2</th></tr></thead><tbody><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table>          </div><h3 id="gallery相册的效果预览"><a href="#gallery相册的效果预览" class="headerlink" title="gallery相册的效果预览"></a>gallery相册的效果预览</h3><div class="justified-gallery"><p><img alt data-src="https://gratisography.com/wp-content/uploads/2019/10/gratisography-scary-pumpkin-hand-900x600.jpg" class="lazyload"><br><img alt data-src="https://gratisography.com/wp-content/uploads/2019/10/gratisography-fresh-fish-dinner-900x600.jpg" class="lazyload"><br><img alt data-src="https://gratisography.com/wp-content/uploads/2019/10/gratisography-mountain-cloud-landscape-900x600.jpg" class="lazyload"><br><img alt data-src="https://picjumbo.com/wp-content/uploads/iphone-free-stock-photos-2210x3315.jpg" class="lazyload"><br><img alt data-src="https://picjumbo.com/wp-content/uploads/young-millennial-girl-drinking-lemonade-and-overlooking-the-city-2210x1473.jpg" class="lazyload"><br><img alt data-src="https://picjumbo.com/wp-content/uploads/modern-graphic-designer-essentials_free_stock_photos_picjumbo_HNCK4919-2210x1474.jpg" class="lazyload"></p>          </div><h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>在想要置顶的markdown的文章的title中加一个属性：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxx</span><br><span class="line">tags:</span><br><span class="line">  - xxx</span><br><span class="line">date: 2018-08-08 08:08:08</span><br><span class="line">top: <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="3-29-32完成"><a href="#3-29-32完成" class="headerlink" title="3.29-32完成"></a>3.29-32完成</h3><p>出现一个很奇怪的bug，运行hexo clean &amp; hexo g后public下的index.html就消失了，目前不知道哪里出了问题只能手动添加一下index.html再hexo s了</p><p>又看了一下，hexo clean的时候会删除整个public文件夹，hexo g的时候又会重新生成，但是没有index.html了,也不报错。。。</p><p>啊我个傻子，原因是<strong>配置文章置顶功能</strong>的时候，要先npm uninstall hexo-generator-index –save 然后 npm install hexo-generator-index-pin-top –save。<br>我只做了第一步。。。。。。。</p><p>个傻子，学会了认真看文档+版本管理QAQ</p><h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>分享弄完了，push一下</p><h2 id="文档之外的功能"><a href="#文档之外的功能" class="headerlink" title="文档之外的功能"></a>文档之外的功能</h2><p>看着ffgg的加了一只狗狗，我们姑且叫他小咕</p><p>ffgg的加密不能用，会与目录冲突，先放着</p><p>评论不能加，蹲一波dalao的回复。找到一篇博主的文章，但还是失败了<br><a href="https://blog.csdn.net/weixin_30721077/article/details/96266356" target="_blank" rel="noopener">【Valine评论设置——基于next】</a></p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>1.这个Sakura主题的blog好好看！！！！<br><a href="https://yremp.live/hexo-sakura/" target="_blank" rel="noopener">Sakura</a></p><p>喜欢鼠标、喜欢返回顶部和里面的代码！要是能八一八就好惹～</p><p>2.配置文件的<br>选择<a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">【Valine】</a>作为评论服务商。<br>注册完了但是失败。。。有空再调一下吧</p><p>搜索的Algolia没有弄，网站验证下次再说,不想搞，不想被发现QAQ<br>footer背景没弄,因为没找到合适的<br>PWA失败，再说吧</p><p>3.加一下音视频<br>加密继续，参考ffgg的配置，多看看别人的blog</p>]]></content>
      
      
      <categories>
          
          <category> 开发日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站日志 Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown手册</title>
      <link href="/2019/11/10/markdown%E6%89%8B%E5%86%8C/"/>
      <url>/2019/11/10/markdown%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="git与github版本管理"><a href="#git与github版本管理" class="headerlink" title="git与github版本管理"></a>git与github版本管理</h3><ul><li><input checked="" disabled="" type="checkbox"> P45 搭建聚合工程及注册中心</li><li><input checked="" disabled="" type="checkbox"> P46 搭建网关微服务及common工程</li><li><input checked="" disabled="" type="checkbox"> P47 添加路由规则</li><li><input disabled="" type="checkbox"> P48 56-73 vue学习</li><li><input checked="" disabled="" type="checkbox"> P76 运行后台管理前端工程<br>￼</li><li><input checked="" disabled="" type="checkbox"> P77 同一环境</li><li><input checked="" disabled="" type="checkbox"> P78 域名访问项目</li></ul>]]></content>
      
      
      <categories>
          
          <category> 手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手册 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编译原理</title>
      <link href="/2019/11/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/2019/11/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习要求：先整理笔记，再把视频看完，最后回顾高老师PPT</p></blockquote><blockquote><p>视频：</p></blockquote><ul><li><input disabled type="checkbox"> 绪论 1-6</li><li><input disabled type="checkbox"> 语言及其文法 2.5完整看完</li><li><input checked disabled type="checkbox"> </li><li><input disabled type="checkbox"> chapter 9</li><li><input disabled type="checkbox"> </li><li><input disabled type="checkbox"> </li></ul><p>考点用<code>重点考点</code>进行标识</p><p>需要补充的地方<code>[?]</code></p><p>参考网址：<a href="https://blog.csdn.net/qq_33414271/category_9292415.html" target="_blank" rel="noopener">编译原理MOOC笔记</a></p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h2><p>计算机程序语言可以自顶向下可以分为高级语言、汇编语言和机器语言三种，其中开发程序员最长接触的为高级语言，如JAVA，高级语言经过编译就会生成汇编语言或机器语言，具体关系如下图：</p><p><img alt="image-20191127165753230" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpaz1yxvj312i0n84a1.jpg" class="lazyload"></p><p>编译的过程就是将<code>高级语言</code>翻译成<code>汇编语言或机器语言</code>的过程 ，即将<code>源语言</code>转化为<code>目标语言</code>的过程。</p><p>编译器在语言处理系统中的位置如下图所示：</p><p><img alt="image-20191127165935095" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpcqqihfj310o0oan77.jpg" class="lazyload"></p><ul><li><p>可重定位(Relocatable)： 在内存中存放的起始位置L不是固定的</p></li><li><p>加载器：修改可重定位地址；将修改后的指令和数据放到内存中适当的位置</p><center>起始位置+相对地址=绝对地址</center></li><li><p><code>链接器</code>的作用：</p><ol><li>将多个可重定位的机器代码文件（包括库文件）</li><li>连接到一起解决外部内存地址问题</li></ol></li></ul><h2 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h2><p>在有了高级语言程序之后（如一段C语言代码），编译器应该怎么翻译成汇编语言程序或机器语言程序呢？</p><p>我们先来看一下人工英汉怎么进行翻译的，编译器所做的工作有类似之处。</p><p><img alt="image-20191127170344850" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cph2jthrj311m0k07e8.jpg" class="lazyload"></p><p>首先我们分析源语言，即英文，先拆分名词、动词等，然后组成短语，最终才能组合成句。即一段语言的分析理解包括了<code>3个基本的小部分</code>,最终才能连接成为一个完整的句子</p><ol><li>词法分析（Lexical Analysis）</li><li>语法分析（Syntax Analysis）</li><li>语义分析（Semantic Analysis）</li></ol><p>那么一个完整的编译器结构如下图所示：</p><p><img alt="image-20191127170550711" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpj9ct2bj30so0tu7d2.jpg" class="lazyload"></p><h2 id="词法分析概述"><a href="#词法分析概述" class="headerlink" title="词法分析概述"></a>词法分析概述</h2><p>词法分析顾名思义就是通过扫描源程序，识别出每一个单词，确定单词类型，然后转化为统一的机内表示——<code>词法单元（token）</code>形式。</p><p>token：&lt; 种别码，属性值&gt;</p><p>例如if、else对应唯一的表示形式。具体的表示形式如下表所示：</p><p><img alt="image-20191127170722792" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpkudcwfj30yc0dkte0.jpg" class="lazyload"></p><p>例如有一句代码为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(value!=<span class="number">100</span>)&#123;num++;&#125;</span><br></pre></td></tr></table></figure><p>则经过词法分析后如下所示，其中每句后的&lt;-,-&gt;表示每个单词的含义。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>      &lt; WHILE ,    -  &gt;  <span class="comment">// 关键词，一词一码</span></span><br><span class="line">(          &lt;SLP    ,    -  &gt;  <span class="comment">// 界限符，一词一码</span></span><br><span class="line">value      &lt;IDN    ,  value&gt;  <span class="comment">// 标识符，多词一码，&lt; 种别码，属性值value&gt;</span></span><br><span class="line">!=         &lt;NE     ,    -  &gt;  <span class="comment">// 运算符，一词一码</span></span><br><span class="line"><span class="number">100</span>        &lt;CONST,<span class="number">100</span>&gt; <span class="comment">// 常 量，一型一码</span></span><br><span class="line">)          &lt;SRP,-&gt;            <span class="comment">// 界限符，一词一码</span></span><br><span class="line">&#123;          &lt;LP,-&gt;             <span class="comment">// 界限符，一词一码</span></span><br><span class="line">num        &lt;IDN,num&gt;          <span class="comment">// 标识符，多词一码，&lt; 种别码，属性值value&gt;</span></span><br><span class="line">++         &lt;INC,-&gt;            <span class="comment">// 运算符，一词一码</span></span><br><span class="line">;          &lt;SEMI,-&gt;           <span class="comment">// 界限符，一词一码</span></span><br><span class="line">&#125;          &lt;RP,-&gt;             <span class="comment">// 界限符，一词一码</span></span><br></pre></td></tr></table></figure><h2 id="语法分析概述"><a href="#语法分析概述" class="headerlink" title="语法分析概述"></a>语法分析概述</h2><p>语法分析器(parser)从词法分析器输出的token序列中识别出各类短语，并构造<code>语法分析树(parsetree)</code>。简而言之就是将词法分析后识别出来的单词构成短语，将短语整合成一个完整的句子。</p><p>语法分析树描述了句子的语法结构。如下是<code>赋值语句</code>的语法分析树：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">position</span>      =      initial      +    rate      *    <span class="number">60</span>     ;  </span><br><span class="line">&lt;id，<span class="built_in">position</span>&gt;  &lt;=&gt;   &lt;id,initial&gt;  &lt;+&gt; &lt;id, rate&gt; &lt;*&gt; &lt;num,<span class="number">60</span>&gt; &lt;;&gt;</span><br></pre></td></tr></table></figure><p><img alt="image-20191127180738395" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9crbjmk6gj312o0dytcs.jpg" class="lazyload"></p><p>例如我们需要得到<code>变量声明的分析树</code>，变量声明可以是int a；也可以是int a,b,c；抽象成文法（变量声明的规则）和分析树为：</p><p><img alt="image-20191127181449598" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9crj1i7inj31460fg78x.jpg" class="lazyload"></p><h2 id="语义分析概述"><a href="#语义分析概述" class="headerlink" title="语义分析概述"></a>语义分析概述</h2><p>语义分析的主要任务是<code>收集标识符的属性信息</code>，其中包括种属（简单变量、复合变量···）、类型（整型、实型···）、存储位置、长度等；除此之外语义分析还要进行<code>语义检查</code>，其中包括变量是否是没有声明就使用了。</p><h2 id="中间代码生成及编译器后端概述"><a href="#中间代码生成及编译器后端概述" class="headerlink" title="中间代码生成及编译器后端概述"></a>中间代码生成及编译器后端概述</h2><p>常见的中间表示形式为：</p><ul><li><p><code>三地址码(Three-address Code)</code>：三地址码由类似于汇编语言的指令序列组成， 每个指令最多有三个操作数(operand)。</p></li><li><p><code>语法结构树/语法树(Syntax Trees)</code></p></li></ul><p>常见的为三地址形式，其中表示方法为<code>四元式(Quadruples)</code>：(op, y, z, x)。</p><p><img alt="image-20191127182026339" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9crouz1dzj310s0p8wn7.jpg" class="lazyload"></p><p>中间代码生成的案例为：</p><blockquote><p>[!!!重点题]先画出语法分析树，然后再进行分析</p></blockquote><p><img alt="image-20191127182553003" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cruj4rhyj313o0hcwn5.jpg" class="lazyload"></p><h1 id="语言及其文法"><a href="#语言及其文法" class="headerlink" title="语言及其文法"></a>语言及其文法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>正如英语是由句子组成的集合，而句子又是由单词和标点符号组成的序列那样。程序设计语言 C 语言，是由 C 程序所组成的集合，而程序是由类似 if , begin, end 的符号，字母和数字这样一些基本符号所组成。</p><p>从字面上看，每个程序都是一个“基本符号”串，设有一基本符号串，那么 C 语言可看成是在这个基本符号集上定义的，按一定规则构成的一切基本符号串组成的集合。</p><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表$$\sum$$是一个<strong>有穷</strong>的符号集合，其中符号包括<strong>字母、数字和标点符号</strong>等</p><p>如:</p><ul><li><p>二进制字母表：{ 0,1 } ；</p></li><li><p>ASCII字符集 ；</p></li><li><p>Unicode字符。</p></li></ul><h3 id="字母表上的运算"><a href="#字母表上的运算" class="headerlink" title="字母表上的运算"></a>字母表上的运算</h3><blockquote><p> 字母表 $\sum_1$ 和 $\sum_2$ 的<code>乘积</code>( product)</p></blockquote><p><img alt="image-20191127203325412" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvj89hi8j30rs07gabz.jpg" class="lazyload"></p><blockquote><p>字母表 $\sum$ 的<code>n次幂</code>( power)：长度为n的符号串构成的集合</p></blockquote><p><img alt="image-20191127203359267" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvjtdnjzj30u80a6go6.jpg" class="lazyload"></p><blockquote><p> 字母表 $\sum$ 的<code>正闭包</code>( positive closure)：长度为正数的符号串构成的集合</p></blockquote><p><img alt="image-20191127203508021" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvl0gye3j30wu09iad6.jpg" class="lazyload"></p><blockquote><p>字母表 $\sum$ 的克林闭包(Kleene closure)：任意符号串(<code>跟正闭包相比长度可以为零</code>）构成的集合</p></blockquote><p><img alt="image-20191127203705801" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvn26xlzj30ym08itbn.jpg" class="lazyload"></p><h3 id="符号串"><a href="#符号串" class="headerlink" title="符号串"></a>符号串</h3><p><strong>由字母表中的符号组成的任何有穷序列称为符号串。</strong></p><p><strong>串 s 的长度</strong>，通常记作 |s| ，是指 s 中符号的个数。例：|aab|=3。</p><p><strong>空串是长度为 0 的串</strong>，用 ε 表示，|ε|=0。</p><h3 id="串上的运算"><a href="#串上的运算" class="headerlink" title="串上的运算"></a>串上的运算</h3><blockquote><p>串的连接：</p></blockquote><p>如果 x 和 y 是串，那么 x 和 y 的连接，是把 y 附加到 x 后面而形成的串，记作 xy。</p><p>例如，如果 x=dog 且 y=house，那么 xy=doghouse。</p><p>空串是连接运算的单位元，即，对于任何串 s 都有， εs=sε=s。</p><blockquote><p>串的幂运算：将 n 个 串连接起来。</p></blockquote><p><img alt="image-20191127204538740" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvvyj03cj30xs0buwh1.jpg" class="lazyload"></p><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><p>自然语言中句子的构成规则为：句子由名词短语构和动词短语成，名词短语由形容词和名词短语构成···，直到最终特定的名词、动词、形容词等。</p><p><strong>分析一个自然语言的例子，得出句子的构成规则。</strong></p><p><img alt="image-20191127201802385" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cv3an5odj314g0k8qcd.jpg" class="lazyload"></p><h3 id="文法的形式化定义"><a href="#文法的形式化定义" class="headerlink" title="文法的形式化定义"></a>文法的形式化定义</h3><p>$$<br>G = (V_T , V_N , P , S )<br>$$</p><ul><li><p>G：表示文法，文法由一个四元组定义</p></li><li><p><strong>终结符集合和非终结符集合都是字母表</strong></p></li><li><p><strong>终结符集合与非终结符集合是不相交的</strong> -&gt; $V_T∩V_N=Φ$ </p></li><li><p><strong>终结符集合与非终结符集合的并集是文法符号集</strong> -&gt; $V_T∪V_N$：文法符号集</p></li><li><p>$V_T$：</p><p><img alt="image-20191127210706311" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwiac7sij30y807amzp.jpg" class="lazyload"></p></li><li><p>$V_N$：<strong>因为从它们可以推出其他的语法成分，所以被称为非终结符</strong></p><p><img alt="image-20191127210747647" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwjbrw6nj30wi08kmzw.jpg" class="lazyload"></p></li><li><p>P：产生式集合，注意左部和右部的取值，左部是正闭包，右部是克林闭包</p><p>例： P = &lt;句子&gt; → &lt;名词短语&gt;&lt;动词短语&gt;, &lt;名词短语&gt; → &lt;形容词&gt;&lt;名词短语&gt;</p><p><img alt="image-20191127211430931" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwq1999lj30x60aqwie.jpg" class="lazyload"></p></li><li><p>S：开始符号</p><p>$S∈V_N$，开始符号(start symbol)表示的是该文法中最大的语法成分。例：S = &lt;句子&gt;</p><p><img alt="image-20191127212009896" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwvvddqrj30yg050gn9.jpg" class="lazyload"></p><p>例：<img alt="image-20191127212046791" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwwi6n07j30y408kgok.jpg" class="lazyload"></p></li></ul><h3 id="产生式的简写"><a href="#产生式的简写" class="headerlink" title="产生式的简写"></a>产生式的简写</h3><p><img alt="image-20191127212509659" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx138jbzj30ys0gsq7a.jpg" class="lazyload"></p><h3 id="符号的约定"><a href="#符号的约定" class="headerlink" title="符号的约定"></a>符号的约定</h3><ul><li><p>终结符</p><p><img alt="image-20191127213016136" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx6fd6qwj30xg0cuwkb.jpg" class="lazyload"></p></li><li><p>非终结符</p></li></ul><p><img alt="image-20191127213110142" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx7ceu2nj30yw0ck0zh.jpg" class="lazyload"></p><ul><li><p>其他</p><p><img alt="image-20191127213523082" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxbpc4g8j30ny0aqdqa.jpg" class="lazyload"></p></li></ul><h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><h3 id="推导与规约"><a href="#推导与规约" class="headerlink" title="推导与规约"></a>推导与规约</h3><p>假设自然语言的<strong>文法</strong>可以表示为</p><p><img alt="image-20191127213748634" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxe85up2j30sg0jijz9.jpg" class="lazyload"></p><p><strong>单词串</strong>：little boy eats apple</p><p>有了文法（语言规则），如何判定一个单词串是否是满足文法的句子？</p><p>答案是：<strong>推导和规约</strong>。</p><p>$ a_0$ 经过 n 步推导出$ a_n$ ，可简记为：$ a_0 -&gt; a_n$ </p><p><img alt="image-20191127215130972" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxsi5orij316209udl7.jpg" class="lazyload"></p><p><img alt="image-20191127215144948" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxspwvmpj31600ce42p.jpg" class="lazyload"></p><p>例：</p><p>由上而下为推导，即具体化的过程——-从生成语言的角度</p><p>由下而上为规约，即抽象化的过程——从识别语言的角度</p><p><img alt="image-20191127214236911" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxj8iz9dj315i0k444b.jpg" class="lazyload"></p><h3 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h3><blockquote><p>句型：</p></blockquote><p><img alt="image-20191127214426061" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxl48vy4j315y07owhd.jpg" class="lazyload"></p><blockquote><p>句子：<strong>句子是不包含非终结符的句型</strong></p></blockquote><p><img alt="image-20191127214450796" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxljms1mj316a024q3r.jpg" class="lazyload"></p><p>例：</p><p><img alt="image-20191127214531118" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxm92s64j31600fm0yl.jpg" class="lazyload"></p><h3 id="语言的形式化定义"><a href="#语言的形式化定义" class="headerlink" title="语言的形式化定义"></a>语言的形式化定义</h3><p>由文法 G 的开始符号 S 推导出的所有<code>句子</code>构成的集合称为<code>文法G生成的语言</code>，记作 L(G)，即：`</p><p><img alt="image-20191127215520196" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxwg8l4aj315g0203ym.jpg" class="lazyload"></p><p>例1：</p><p>$E-&gt;E+E | E * E | (E) | id$ 生成的语言中包含多少个<code>句子</code></p><p>答案是无数个，文法解决了无穷语言的有穷表示问题</p><p>例2：</p><p>我们现在拥有的文法 G 如下所示，其生成的语言标识符，即以字母开头的字符串。因为S定义为一个字母或以字母开头的字母数字串，即用于表示标识符。</p><p><img alt="image-20191127215638460" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxxthzt9j31640fo42p.jpg" class="lazyload"></p><h3 id="语言上的运算"><a href="#语言上的运算" class="headerlink" title="语言上的运算"></a>语言上的运算</h3><p><img alt="image-20191127220637268" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cy87ik0hj315w0fogrn.jpg" class="lazyload"></p><h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><h3 id="0型文法，无限制文法，短语结构文法"><a href="#0型文法，无限制文法，短语结构文法" class="headerlink" title="0型文法，无限制文法，短语结构文法"></a>0型文法，无限制文法，短语结构文法</h3><ul><li>α中至少包含1个非终结符</li></ul><p><img alt="image-20191127221027086" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyc6uglwj31600fe78m.jpg" class="lazyload"></p><h3 id="1型文法，上下文有关文法-CSG"><a href="#1型文法，上下文有关文法-CSG" class="headerlink" title="1型文法，上下文有关文法(CSG)"></a>1型文法，上下文有关文法(CSG)</h3><ul><li><p>产生式左部符号的个数不能多于右部</p></li><li><p>CSG不包含 $\varepsilon$ 产生式，即产生式<strong>右部是空串的产生式</strong>，因为左部至少包含一个非终结符，左部长度至少为1，如果右部是 $\varepsilon$ ，右部长度为1，与CGS定义不符合。</p></li></ul><p><img alt="image-20191127221328301" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyfbx748j315y0i2afd.jpg" class="lazyload"></p><h3 id="2型文法，上下文无关文法-CFG"><a href="#2型文法，上下文无关文法-CFG" class="headerlink" title="2型文法，上下文无关文法(CFG)"></a>2型文法，上下文无关文法(CFG)</h3><ul><li>左边是一个非终结符，将其替换不需要考虑其上下文</li><li>所举的例子即2型文法</li></ul><p><img alt="image-20191127221344869" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyfm18zwj315w0ig786.jpg" class="lazyload"></p><h3 id="3型文法，正规文法，正则文法-RG"><a href="#3型文法，正规文法，正则文法-RG" class="headerlink" title="3型文法，正规文法，正则文法(RG)"></a>3型文法，正规文法，正则文法(RG)</h3><ul><li>3型文法分为2种文法</li><li>产生式右部最多只有一个非终结符，且只能在一侧</li><li>例子中的两个文法都是指标识符，即一个字母或以字母开头的字母数字串</li><li>程序语言中的多数单词都能用正则文法表示</li></ul><p><img alt="image-20191127222052426" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyn3744ej315u0ian4k.jpg" class="lazyload"></p><h3 id="四种文法之间的关系"><a href="#四种文法之间的关系" class="headerlink" title="四种文法之间的关系"></a>四种文法之间的关系</h3><p><img alt="image-20191127222635614" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyszv3q5j31620fi43y.jpg" class="lazyload"></p><h2 id="上下文无关文法的分析树"><a href="#上下文无关文法的分析树" class="headerlink" title="上下文无关文法的分析树"></a>上下文无关文法的分析树</h2><p>程序语言中的多数单词都能用正则文法表示，但正则文法生成能力有限，句子构造则需要用上下文无关文法进行描述。</p><h3 id="CFG分析树定义"><a href="#CFG分析树定义" class="headerlink" title="CFG分析树定义"></a>CFG分析树定义</h3><p>例：图中跟节点表示的是对第三个式子的应用</p><p><img alt="image-20191127222833264" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyv3e5bpj315y0hwq9o.jpg" class="lazyload"></p><h3 id="分析树是推导的图形化表示"><a href="#分析树是推导的图形化表示" class="headerlink" title="分析树是推导的图形化表示"></a>分析树是推导的图形化表示</h3><p>推导过程中产生许多<code>句型</code>,最终推导出分析树的边缘</p><p><img alt="image-20191127223759244" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cz4u6zi1j315q0fktds.jpg" class="lazyload"> </p><h3 id="句型的短语"><a href="#句型的短语" class="headerlink" title="句型的短语"></a>句型的短语</h3><p>给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个<code>短语</code>。</p><p>如果子树只有父子两代节点，那么这课子树的边缘称为该句型的一个<code>直接短语</code>。</p><p><strong>直接短语一定是产生式的右部，但产生式的右部不一定是给定句型的直接短语，但可能是其他句型的直接短语</strong></p><p><img alt="image-20191127224229562" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cz9jcs2rj316609077h.jpg" class="lazyload"></p><p>例：人民、生活、水平是该句子的直接短语，而高人、民生、活水虽然也是第5个产生式的右部，但是在这棵分析树中，它们不是直接短语。</p><p><img alt="image-20191127225119891" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cziqh449j30o40bigub.jpg" class="lazyload"></p><h3 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h3><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。</p><p>下面这个例子产生二义的原因是else可以跟第一个if条件语句和第二个if条件语句相配。</p><p><code>消歧规则</code>：每个else和最近的尚未匹配的if进行匹配，所以只有第一个分析树</p><p><img alt="image-20191127225609332" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cznqxtqrj315y0fcadz.jpg" class="lazyload"></p><h3 id="二义性文法的判定"><a href="#二义性文法的判定" class="headerlink" title="二义性文法的判定"></a>二义性文法的判定</h3><p>对于任意一个上下文无关文法，不存在一个算法，判断它是无二义性的，但能给出一组充分条件，满足这组充分条件的文法是无二义性的。</p><ul><li>满足，肯定无二义性</li><li>不满足，也未必就是有二义性的</li></ul><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>词法分析这一章从正则表达式到有穷自动机，讲述了如何利用<strong>确定性的有穷自动机</strong>来进行单词的识别。其中正则表达式和有穷自动机之间也有相应的<strong>转化</strong>关系。</p><p>本文内容：介绍正则定义，正则表达式，有穷自动机（确定的有穷自动机 DFA，不确定的有穷自动机 NFA），NFA 转换为等价的 DFA，DFA 的化简，识别单词的 DFA ，典型例题及详细解答。</p><p>在前面我们说过，程序设计语言中的大多数单词都可以用<strong>正则文法</strong>来描述，在这一章中我们将介绍描述<strong>正则语言的更紧凑的方法——正则表达式</strong>。</p><h2 id="正则表达式（RE）"><a href="#正则表达式（RE）" class="headerlink" title="正则表达式（RE）"></a>正则表达式（RE）</h2><h2 id="正则定义（Regular-Definition）"><a href="#正则定义（Regular-Definition）" class="headerlink" title="正则定义（Regular Definition）"></a>正则定义（Regular Definition）</h2><h2 id="有穷自动机（FA）"><a href="#有穷自动机（FA）" class="headerlink" title="有穷自动机（FA）"></a>有穷自动机（FA）</h2><h2 id="有穷自动机的分类"><a href="#有穷自动机的分类" class="headerlink" title="有穷自动机的分类"></a>有穷自动机的分类</h2><h3 id="确定的有穷自动机-DFA"><a href="#确定的有穷自动机-DFA" class="headerlink" title="确定的有穷自动机 (DFA)"></a>确定的有穷自动机 (DFA)</h3><h3 id="非确定的FA-NFA"><a href="#非确定的FA-NFA" class="headerlink" title="非确定的FA (NFA)"></a>非确定的FA (NFA)</h3><h3 id="DFA和NFA的等价性"><a href="#DFA和NFA的等价性" class="headerlink" title="DFA和NFA的等价性"></a>DFA和NFA的等价性</h3><h2 id="正则表达式和有穷自动机之间的转换"><a href="#正则表达式和有穷自动机之间的转换" class="headerlink" title="正则表达式和有穷自动机之间的转换"></a>正则表达式和有穷自动机之间的转换</h2><h3 id="从RE到NFA"><a href="#从RE到NFA" class="headerlink" title="从RE到NFA"></a>从RE到NFA</h3><h3 id="从NFA到DFA"><a href="#从NFA到DFA" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h3><h2 id="识别单词的DFA"><a href="#识别单词的DFA" class="headerlink" title="识别单词的DFA"></a>识别单词的DFA</h2><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><blockquote><p>11.07</p></blockquote><p>1.概念：算符(要相邻)，素短语，算符优先关系</p><p>2.例题：书本P89<br>3.判断是否为算法优先文法，算符之间只能有一个关系<br>4.算符优先关系表<br>5.FIRSTVT和LASTVT，可以用来构造优先关系表<br>6.PPT41页例题和书本P91笔记<br>7.根据PPT41写出PPT44例题<br>8.PPT46的素短语和最左素短语<br>9.PPT47的规约过程<br>10.PPT51页例题<br>11.规约准确率高，算符优先法速度快</p><blockquote><p>11.14<br>一、复习<br>1.规约：找句柄<br>2.算符优先文法：找最左素短语，i直接返回为最顶端的N，有算符才能规约，否则都是占位符，一定要包含算符。速度快但有时不准确，前提是符合算符优先文法才能用。很多都不适用<br>3.另一种：LR分析法</p></blockquote><p>二、LR分析法：<br>1.从左到右扫描符号串，用最左规约，最右推导。能解决大部分语法规则，但二义文法，需要处理才能用。<br>2.LR(1)分析表，算FIRST和FELLOW，有多个候选式。而LR分析法我们用的是LR分析法，有很多能自动构造LR分析表。<br>3.课本P101例题，状态栈和符号栈，遇到s5:状态转为5，移入i，指针后移；r2：用(2)表达式进行规约右侧符号，消除此时状态，写入规约后符号，查询Goto表更新状态。栈顶的状态显示了分析的历史信息/进度。<br>4.根据有限状态自动机DFA，LR(0)item组成的集合</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程课堂笔记</title>
      <link href="/2019/11/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>格式说明</p><p>每章节/附录用一级标题</p><blockquote><p>用这个表示每章节的重点内容回顾和考点分析</p></blockquote><p>考点用<code>重点考题</code>标识</p><p>其他考点总结附在最后</p><ul><li><input disabled type="checkbox"> chapter 8</li><li><input checked disabled type="checkbox"> 附件-正规技术评审</li><li><input disabled type="checkbox"> chapter 9</li><li><input disabled type="checkbox"> 附件-领域模型和设计类图的区别</li></ul><h1 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h1><h2 id="PPT内容整理"><a href="#PPT内容整理" class="headerlink" title="PPT内容整理"></a>PPT内容整理</h2><p><img alt="image-20191127102108246" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cdu9088fj30pq03imyb.jpg" class="lazyload"></p><blockquote><p> Stockholders：甲方、乙方等</p></blockquote><blockquote><p>一定考：Elaboration阶段，分析建模阶段，得到一个完整的规约</p></blockquote><p>首先完善Use case图，每个Use case有acticity图、初步分析类图、可能还要有sequence图(对需要类图的哪些类以及类之间的交互)、初步状态图，明白各种图之间的关系，</p><p>画一下概念类图，学生、成绩、老师等：首先话Use case图，挑两个重要的Use case图构建初步类图和时序图</p><p>此时得到了需求规约(文字需求和用例图)和需求分析规约(功能、分析、行为建模)</p><p>评审：遗漏的、模糊的、不一致的地方，如用户名、密码数据结构描述、密码可以错几次等要清晰</p><h1 id="附件-正规技术评审"><a href="#附件-正规技术评审" class="headerlink" title="附件-正规技术评审"></a>附件-正规技术评审</h1><blockquote><p>正规技术评审(见附件)</p></blockquote><ol><li><p><code>意义(重点)</code>：质量保证的手段、是对软件开发过程中的需求规约、需求分析规约、概要设计规约、详细设计规约、代码进行评审的重要手段。</p></li><li><p><code>目的(重点重点考题)</code>：</p></li></ol><p>![image-20191127122638197](/Users/hamster/Library/Application Support/typora-user-images/image-20191127122638197.png)</p><p>具体如指针错误、代码风格、保证各阶段的输出可以成功辅助下一阶段(需求规约-&gt;需求分析规约)</p><ol start="3"><li><p><code>评审员Reviewer等角色</code></p></li><li><p><code>[?]检查要点列表（Checklist）(重点考题)</code>：**checkList内容具体有哪些，请举例：类图正确否变量调用的耦合、数组等</p></li><li><p>流程：先自己评审、汇总、召开评审会(控制评审时间两小时，过大的评审可分成子系统)、没有解决的问题在修正会继续讨论。评审会旨在<strong>阐明问题而非解决问题</strong>，适合需求规约、需求分析规约、概要设计规约、详细设计规约、代码各个阶段的评审。</p></li><li><p>评审也叫静态测试，即未运行代码的质量保证</p></li><li><p><code>[?]work through(重点考题)</code></p></li></ol><h1 id="Chapter-9-需求建模：基于类的方法"><a href="#Chapter-9-需求建模：基于类的方法" class="headerlink" title="Chapter 9  需求建模：基于类的方法"></a>Chapter 9  需求建模：基于类的方法</h1><h2 id="9-1-需求分析"><a href="#9-1-需求分析" class="headerlink" title="9.1 需求分析"></a>9.1 需求分析</h2><ul><li>基于场景的需求模型</li><li>基于对象</li><li>基于行为和模式</li></ul><blockquote><p>两种开发：面向对象、面向结构开发</p></blockquote><h1 id="附件-领域模型和设计类图的区别"><a href="#附件-领域模型和设计类图的区别" class="headerlink" title="附件-领域模型和设计类图的区别"></a>附件-领域模型和设计类图的区别</h1><p>考试一定考，自己看</p><h1 id="晚课笔记"><a href="#晚课笔记" class="headerlink" title="晚课笔记"></a>晚课笔记</h1><h2 id="11-23"><a href="#11-23" class="headerlink" title="11.23"></a>11.23</h2><ol><li><p>用例图中划分子系统</p><p><code>(重点考题)</code>子系统1与子系统中2中的方法相互调用与返回，过多方法间的访问，维护成本大，所以更改为：在子系统1和子系统中2各定义一个接口类，两个子系统之间的方法互相通过接口进行访问。如果项目使用了这个则加分。</p></li><li><p>架构是在<strong>概要设计</strong>中进行设计。</p></li><li><p>工具：spring cloud contract</p></li></ol><h1 id="Exexcise"><a href="#Exexcise" class="headerlink" title="Exexcise"></a>Exexcise</h1><blockquote><p>一、web 1.0 至 web 4.0 发展历程</p></blockquote><p><a href="https://www.teambition.com/project/5cc325db29ef4c0019136fe3/works/5cc325db29ef4c0019136fe6/work/5dcbcf7ab951ed0018e4e2bc" target="_blank" rel="noopener">参考资料：Web4.0时代的创新探究</a></p><ul><li><p>Web 1.0：信息共享</p></li><li><p>Web 2.0：信息共建</p></li><li><p>Web 3.0：知识传承</p></li><li><p>Web 4.0：知识分配</p></li></ul><h4 id="web-4-0-与其他-web-对比"><a href="#web-4-0-与其他-web-对比" class="headerlink" title="web 4.0 与其他 web 对比"></a>web 4.0 与其他 web 对比</h4><p><img alt data-src="https://wx3.sinaimg.cn/mw690/007CtYmwly1g8wk3dbs4vj30xc0s010h.jpg" class="lazyload"></p><h4 id="web-4-0-发展历程"><a href="#web-4-0-发展历程" class="headerlink" title="web 4.0 发展历程"></a>web 4.0 发展历程</h4><p><img alt data-src="https://wx4.sinaimg.cn/mw690/007CtYmwly1g8wk62tjwwj30ws0bmq6m.jpg" class="lazyload"></p><blockquote><p>二、云平台架构</p></blockquote><h4 id="对比于传统的服务器"><a href="#对比于传统的服务器" class="headerlink" title="对比于传统的服务器"></a>对比于传统的服务器</h4><ul><li>云平台可以将物理资源虚拟化为<strong>虚拟机资源池</strong>，灵活调用软硬件资源，实现对用户的按需访问。</li><li>在运行过程中根据用户并发量不同，<strong>实时迁移虚拟机资源</strong>，一方面保证提供高质量服务，另一方面最小化资源成本，提高CPU、内存等利用率。</li><li>4层架构，从底层到上层分别是资源层、虚拟层、中间件层、应用层。</li></ul><h4 id="资源层或基础设施层（IaaS）"><a href="#资源层或基础设施层（IaaS）" class="headerlink" title="资源层或基础设施层（IaaS）"></a>资源层或基础设施层（IaaS）</h4><ul><li><p>由<strong>服务器集群</strong>组成。传统服务器要想提供高质量服务，需要性能特别好的服务器（内存高，CPU快，磁盘空间大等），价格昂贵。而服务器集群可以使用以前性能不太好的服务器，利用<strong>分布式处理技术</strong>，依然可以提供可靠服务，节省费用。</p></li><li><p>有了物理机集群后，我们需要在物理机上建立虚拟机。建立虚拟机的目的是为了最小化资源成本（最大化资源利用率）。试想一下某台物理机有64G内存，当某段时间连续有小任务量的应用需要处理时，物理机的内存利用率会很低，所以为最大化资源利用率，可以在物理机上独立开辟几个虚拟机，每台虚拟机相当于一个小型服务器，依然可以处理应用请求。我们采用KVM（Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，同样还有XEN和OVM）来给每一台虚拟机分配适量的内存、CPU、网络带宽和磁盘，形成虚拟机池。</p></li></ul><h4 id="中间件层或平台层（PaaS）"><a href="#中间件层或平台层（PaaS）" class="headerlink" title="中间件层或平台层（PaaS）"></a>中间件层或平台层（PaaS）</h4><ul><li><strong>云平台的核心层</strong>，主要功能为：对虚拟机池资源状态进行监测、预警、优化决策。</li><li>①资源监测：实时监测当前各台虚拟机CPU、内存等使用情况，当然也监测用户应用请求，以便根据应用规模大小进行决策。</li><li>②预警：防患于未然，根据当前虚拟机资源使用情况预测下一秒用户请求量，以便做出相应资源调整，防止宕机。比如CPU使用率上限为70%，所以当预测下一秒达到该触发点时，应有相应响应。当然，触发阈值应该有更科学的设定。</li><li>③优化决策：预警之后，虚拟机要进行资源调度(迁移或伸缩)，采用何种调度策略，才能保证服务和资源利用率是研究重点。由于该层需要对应用进行响应处理，所以需要在虚拟机上搭建操作系统，文件存储系统，以及服务器，当然还有负载均衡系统，如，Nginx，其实现中间件层功能，相当于网络中的路由器不处理数据，只进行数据转发，数据处理交有虚拟机上的tomcat服务器执行。（也相当于hadoop中的Namenode，其他虚拟机相当于datanode）。</li></ul><h4 id="应用层或软件服务层（SaaS）"><a href="#应用层或软件服务层（SaaS）" class="headerlink" title="应用层或软件服务层（SaaS）"></a>应用层或软件服务层（SaaS）</h4><ul><li>给用户提供可视化界面，应用若为存储：比如百度云会给用户提供交互界面，建立文件夹，进行数据存储，在线播放视频等界面，供用户选择操作。应用若为租用服务器：界面应该有租用的服务器资源状态。</li><li>另外，该平台是面向服务的体系架构(SOA)，给用户的应用提供的是服务。这里面有个概念为组件服务。组件是已经编译好，并且可以使用的二进制代码，组件之间的组合可以组成一个应用程序。比如用户的应用为在线播放视频，那么云平台提供的组件应有在线播放组件及相关联组件，给用户提供的服务就是在线播放视频。而不同的组件组合，需要不同大小的虚拟机资源，所以为使资源利用率最大，需要合理进行组合。</li></ul><h4 id="通用的官方表述"><a href="#通用的官方表述" class="headerlink" title="通用的官方表述"></a>通用的官方表述</h4><ul><li><p>一般来说，目前大家比较公认的云架构是划分为基础设施层、平台层和软件服务层三个层次的。对应名称为IaaS，PaaS和SaaS。如下图所示。<br><img alt="IMG_256" data-src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=bc9d96f0a00f4bfb98dd960662261395/f9198618367adab47472e22c8fd4b31c8701e43b.jpg" class="lazyload">  </p></li><li><p>IaaS, Infrastructure as a Service，IaaS主要包括计算机服务器、通信设备、存储设备等，能够按需向用户提供的计算能力、存储能力或网络能力等IT基础设施类服务，也就是能在基础设施层面提供的服务。今天IaaS能够得到成熟应用的核心在于虚拟化技术，通过虚拟化技术可以将形形色色计算设备统一虚拟化为虚拟资源池中的计算资源，将存储设备统一虚拟化为虚拟资源池中的存储资源，将网络设备统一虚拟化为虚拟资源池中的网络资源。当用户订购这些资源时，数据中心管理者直接将订购的份额打包提供给用户，从而实现了IaaS。</p></li><li><p>PaaS, Platform as a Service，中文名为平台即服务。如果以传统计算机架构中“硬件+操作系统/开发工具+应用软件”的观点来看待，那么云计算的平台层应该提供类似操作系统和开发工具的功能。实际上也的确如此，PaaS定位于通过互联网为用户提供一整套开发、运行和运营应用软件的支撑平台。就像在个人计算机软件开发模式下，程序员可能会在一台装有Windows或Linux操作系统的计算机上使用开发工具开发并部署应用软件一样。微软公司的Windows Azure和谷歌公司的GAE，可以算是目前PaaS平台中最为知名的两个产品了。</p></li><li><p>SaaS，软件即服务。简单地说，就是一种通过互联网提供软件服务的软件应用模式。在这种模式下，用户不需要再花费大量投资用于硬件、软件和开发团队的建设，只需要支付一定的租赁费用，就可以通过互联网享受到相应的服务，而且整个系统的维护也由厂商负责。</p></li></ul><blockquote><p>三、过程管理工具</p></blockquote><p>Teambition：<a href="https://www.teambition.com/" target="_blank" rel="noopener">Teambition官方网站</a></p><blockquote><p>(4) find a project that developed by XP or Scrum, and discuss it.</p></blockquote><p>在国外硅谷等地，敏捷式开发也早已经被Google、Facebook、LinkedIn等企业应用。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DB2</title>
      <link href="/2019/11/26/DB2/"/>
      <url>/2019/11/26/DB2/</url>
      
        <content type="html"><![CDATA[<h1 id="DB2基本使用"><a href="#DB2基本使用" class="headerlink" title="DB2基本使用"></a>DB2基本使用</h1><h1 id="DB2常用命令"><a href="#DB2常用命令" class="headerlink" title="DB2常用命令"></a>DB2常用命令</h1><h1 id="DB2管理电子书，实验三-十"><a href="#DB2管理电子书，实验三-十" class="headerlink" title="DB2管理电子书，实验三-十"></a>DB2管理电子书，实验三-十</h1><h2 id="Unit-3"><a href="#Unit-3" class="headerlink" title="Unit 3"></a>Unit 3</h2><blockquote><p>实验原理介绍</p></blockquote><h3 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h3><h3 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h3><p>参考链接：<a href="https://www.tutorialspoint.com/db2/index.htm" target="_blank" rel="noopener">DB2英文教程</a></p><h1 id="DB2应用开发"><a href="#DB2应用开发" class="headerlink" title="DB2应用开发"></a>DB2应用开发</h1><h1 id="期末小论文"><a href="#期末小论文" class="headerlink" title="期末小论文"></a>期末小论文</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本编辑器使用手册</title>
      <link href="/2019/11/26/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2019/11/26/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-Markdown"><a href="#Typora-Markdown" class="headerlink" title="Typora - Markdown"></a>Typora - Markdown</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>opt_cmd+m：最小化</li><li>opt+cmd+t：表格</li><li>crtl+m：内敛公式</li></ul><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>参考链接：<a href="https://blog.csdn.net/mingzhuo_126/article/details/82722455" target="_blank" rel="noopener">使用Typora添加数学公式</a></p><h3 id="打开Typora选择数学模块"><a href="#打开Typora选择数学模块" class="headerlink" title="打开Typora选择数学模块"></a>打开Typora选择数学模块</h3><ul><li>快捷键：crtl+m</li><li>“$$”+回车</li></ul><ul><li>点击“段落”—&gt;“公式块”</li></ul><p>以上三种方式都能打开数学公式的编辑如下，所输入的公式居中。</p><p><img alt="image-20191127184323885" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cscr9jecj313a064ab2.jpg" class="lazyload"></p><h3 id="常见公式的代码"><a href="#常见公式的代码" class="headerlink" title="常见公式的代码"></a>常见公式的代码</h3><h4 id="上-下标"><a href="#上-下标" class="headerlink" title="上/下标"></a><strong>上/下标</strong></h4><table><thead><tr><th align="center"><strong>算式</strong></th><th align="center"><strong>Markdown</strong></th></tr></thead><tbody><tr><td align="center">$x^2 $</td><td align="center">$x^2 $</td></tr><tr><td align="center">$y_1 $</td><td align="center">$y_1 $</td></tr></tbody></table><h4 id="分式"><a href="#分式" class="headerlink" title="分式"></a><strong>分式</strong></h4>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本编辑器使用手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长短句</title>
      <link href="/2019/11/26/%E7%88%AC%E8%99%AB/"/>
      <url>/2019/11/26/%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-11"><a href="#2019-11" class="headerlink" title="2019-11"></a>2019-11</h1><ol><li>精卫衔微木，将以填沧海。   ———— 陶渊明《读〈山海经〉·精卫衔微木》</li><li>敏而好学，不耻下问。      ———— 《论语·公冶长》</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文哲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长短句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络实验报告</title>
      <link href="/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
      <url>/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="异步串行传输实验"><a href="#异步串行传输实验" class="headerlink" title="异步串行传输实验"></a>异步串行传输实验</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">异步串行实验</td><td align="center">2019-10-30</td></tr></tbody></table><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>本实验是有关OSI模型物理层的实验，通过串⼝的字符收发，加深对通信基本原理的理解。</p><ol><li><p>理解通信基本原理；</p></li><li><p>理解异步串⾏传输的基本概念；</p></li><li><p>了解掌握RS－232接⼝标准以及RS-232帧格式；</p></li><li><p>了解通信双⽅参数匹配是正常通信的基本保证，了解波特率等主要通信参数含义。</p></li></ol><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><ol><li>两台带COM口的计算机[？型号]</li><li>⼀根串⾏交叉线</li></ol><h2 id="实验网络拓扑"><a href="#实验网络拓扑" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191126185241335" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bn043xicj30te05w3ym.jpg" class="lazyload"></p><p>​    异步串行通信实验拓扑结构如上图所示，实验环境主要由两台带COM口的计算机和一根串行交叉线组成。将单根串行交叉线将两个计算机的COM串口对接起来；两台计算机超级终端将作为路由器管理的操作平台。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><blockquote><p>一、异步串行通信原理</p></blockquote><ol><li><p>串行方式：任何通信用户单独只能占用一条通信线路。</p></li><li><p>串行传输：串行传输结构示意图如下图所示，每次只能传输一个数位，0或1。</p><p><img alt="img" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bnchjolaj305o041web.jpg" class="lazyload"></p></li><li><p>串行通信：在数据通信中，将传送的每个字符的二进制代码按照顺序依次发送的方式称为串行通信。串行通信方式广泛应用在远程通信中。</p></li><li><p>串行传输模式在实际运用中，又分为同步传输模式和异步传输模式。</p><ul><li><p>同步传输模式：要求通信的收发双方在时间基准上保持一致。</p></li><li><p>异步传输模式：接发两端使用不固定的时间模式，传输前也不需要协调，只要直接发送，不需要对方作为应答，但必须在传输两个数据包之间加入间隔符号，作为分隔。</p></li></ul></li><li><p>常用的串行通信接口标准包括RS-232、RS-449、V.24、V.35等。其中，RS-232是最常用的串行通信标准之一。</p></li></ol><blockquote><p>二、RS232接口</p></blockquote><ol><li>RS232接口是1970年由美国电子工业协会（EIA）联合贝尔系统、调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标准。</li><li>主要内容：定义数据终端设备DTE（data terminal equipment）和数据通信设备DCE（data circuit equipment）之间的接口标准。</li><li>RS-232传输对象是字符，每次传输一个字符，计算机内部所有的数据都使用二进制，需要规定二进制数字表示哪个符号，称编码标准，现在我们字符使用的标准是ASCII编码。</li></ol><blockquote><p>三、ASCII码表</p></blockquote><ol><li>ASCII(American Standard Code for Information Interchange)，美国信息交换标准代码,是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，使用一个字（byte）来表示英语字母，比如，字母a,十进制编码值是97，二进制是0110 0001，一般用十六进制来表示，0x61，0x是16进制的前缀，ASCII编码详见附件。</li></ol><blockquote><p>四、S232数据桢格式</p></blockquote><ol><li><p>RS232在传输一个字符时，将字符转换成ASCII码，并组织成RS232数据桢进行传输</p></li><li><p>RS232数据桢格式：</p><ul><li>起始位为0，以一位低电平开始，表示发送端开始发送一帧数据；</li><li>数据位，字符的ASCII码，一般低位在前，高位在后，数据位长度一般为8位；</li><li>校验位，用于校验数据的正确性，使用奇校验或者偶校验；</li><li>停止位为1，一帧信息已经发送完毕，长度一般为1~2位；</li><li>空闲位：空闲位也为1，用于通知接受端等待下一个数据帧的传输；一旦开始传输下一个字符，发出新的开始位。</li><li>RS232数据桢格式如下图所示：</li></ul><p><img alt="image-20191126192641093" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bnzhpqplj30qa034ta0.jpg" class="lazyload"></p></li></ol><blockquote><p>五、波特率</p></blockquote><ol><li><strong>波特率</strong>：也称调制速率，指<u>单位时间内通信信号变化的次数</u>，它同时间模式中的时间间隔长度刚好成反比关系。</li><li>波特率决定着每个数位的传输速率，显然，涉及到接发两端的两个设备配置，为保证两者在发送信号和检测信号时的时间同步，就必须设置成相同的波特率。</li><li>发送设备和接收设备采用相同波特率称之为<u>波特率匹配</u>。如果接发双方baud rate波特率不匹配就会发生错误, 称之为<u>帧错误</u>。</li></ol><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、实验概述</p></blockquote><p>使用超级终端进行两台计算机之间的串行通信，一端从键盘输入字符发送，另一端观看接收到的内容。主要实验内容：</p><ol><li><p>测试相同通信参数下的通信，进行相互间的字符接发送；</p></li><li><p>测试不同波特率条件下的通信，其他参数保持相同，进行相互间的字符接发送；通过相互传输字符，来检测通信参数的匹配。</p></li></ol><blockquote><p>二、实验步骤</p></blockquote><p>【准备过程】</p><ol><li>按照实验拓扑结构要求将两台计算机的COM口用串口反接连接线连接起来。  </li><li>Host1：运行超级终端，建⽴串⼝通信连接test1，设置缺省通信参数。  </li><li>Host2：运行超级终端，建⽴串⼝通信连接test2，设置缺省通信参数。  </li></ol><p>【实验一】：测试在相同通信参数下的字符传输</p><ol><li><p>Host2的超级终端输⼊如下内容，此时Host2超级终端无内容显示</p><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">hhh2</span><br></pre></td></tr></table></figure></li><li><p>Host1的超级终端接收到如下字符串</p><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">hhh2</span><br></pre></td></tr></table></figure></li></ol><p>【实验二】：测试采用不同波特率下的字符传输  </p><ol><li><p>Host1和Host2均断开连接，在“文件-&gt;属性-&gt;配置”中修改参数如下：</p><table><thead><tr><th align="center">连接名</th><th align="center">波特率</th><th align="center">数据位</th><th align="center">奇偶校验</th><th align="center">停止位</th></tr></thead><tbody><tr><td align="center">test1</td><td align="center">4800</td><td align="center">8</td><td align="center">奇校验</td><td align="center">1</td></tr><tr><td align="center">test2</td><td align="center">9600</td><td align="center">8</td><td align="center">奇校验</td><td align="center">1</td></tr></tbody></table></li><li><p>进行通信测试。首先在Host1终端从键盘键入以下字符串，Host1屏幕上并不会显示输入内容，Host2屏幕上显示乱码。</p><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> <span class="number">35</span> <span class="number">46</span> <span class="number">77</span></span><br></pre></td></tr></table></figure></li><li><p>在Host2终端从键盘键入以下字符串，Host2屏幕上并不会显示输入内容，Host1屏幕上显示不同乱码。</p><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> <span class="number">35</span> <span class="number">46</span> <span class="number">77</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实验问题与结果分析"><a href="#实验问题与结果分析" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><ol><li><p>实验1中，两台计算机的通信参数相同，波特率匹配，不会发⽣帧错误，因此字符传输正常。</p></li><li><p>实验2中，两台计算机的波特率不同，则它们单位时间内通信信号发⽣变化的次数不同，相应的检测信号的间隔也不一致，因此两台计算机显示出乱码且乱码值不同。</p></li><li><p>这个实验比较简单，是后面实验的基础。通过动手操作串⼝的字符接收和发送，加深了对通信基本原理的理解。在理解通信基本原理和异步串⾏传输的基础上，进一步掌握RS－232接⼝标准以及RS-232帧格式，通过实验一和实验二的具体操作切实理解了通信双⽅参数匹配是正常通信的基本保证，明白了波特率等主要通信参数含义。</p></li></ol><h1 id="VLAN-基本操作实验"><a href="#VLAN-基本操作实验" class="headerlink" title="VLAN 基本操作实验"></a>VLAN 基本操作实验</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">VLAN基本操作实验</td><td align="center">2019-10-30</td></tr></tbody></table><h2 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h2><p>​        了解和掌握VLAN基本概念和操作</p><h2 id="实验设备-1"><a href="#实验设备-1" class="headerlink" title="实验设备"></a>实验设备</h2><ol><li>一台cisco2950交换机</li><li>两台作为操作平台的计算机</li><li>若干条线</li></ol><h2 id="实验网络拓扑-1"><a href="#实验网络拓扑-1" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191126210550455" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bqunjs6rj30wk0a4q3k.jpg" class="lazyload"></p><h2 id="实验原理-1"><a href="#实验原理-1" class="headerlink" title="实验原理"></a>实验原理</h2><ol><li>VLAN是通过软件把网络按<u>逻辑</u>分组，不受物理上交换机端口所限制，把不同地理位置的主机分割到相同VLAN内，VLAN是在交换机上实现。</li><li>VLAN能够解决<u>广播风暴</u>问题。交换机的每个端口是一个冲突域，但不能隔离广播，而一个VLAN就是一个广播域。</li></ol><h2 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、未配置前端⼝通信实验</p></blockquote><ol><li><p>配置两主机IP地址: 192.168.0.2 及 192.168.0.5</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.0.2 连接到交换机的端⼝:1</span><br><span class="line">192.168.0.5 连接到交换机的端⼝:24</span><br></pre></td></tr></table></figure></li><li><p>测试192.168.0.2: ping 192.168.0.5，可连通192.168.0.2 和 192.168.0.5 </p></li></ol><blockquote><p>二、配置VLAN2</p></blockquote><ol><li><p>连接交换机，使用console线将计算机串口com2与路由器console口直接相连；</p></li><li><p>建立HyperTerminal：开始 -&gt; 程序 -&gt; 附件 -&gt; 通讯 -&gt; 超级终端 -&gt; 名称=<strong>switch</strong> -&gt; 连接=<strong>com2</strong> -&gt; (波特率)Baut Rate=<strong>9600</strong>,8,no parity, 1 stop bit；</p></li><li><p>进入特权模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch01&gt; en(able) </span><br><span class="line"><span class="built_in">pwd</span> = cisco //输入密码</span><br></pre></td></tr></table></figure></li><li><p>查看VLAN配置，可查看到当前所有端口以及VLAN的配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch01<span class="comment">#sh vlan</span></span><br></pre></td></tr></table></figure></li><li><p>建立VLAN2和VLAN3</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入VLAN配置模式</span><br><span class="line">switch01<span class="comment">#vlan database </span></span><br><span class="line">// 建⽴VLAN2</span><br><span class="line">switch01(vlan)<span class="comment">#vlan 2 name vlan2</span></span><br><span class="line">// 建⽴VLAN3</span><br><span class="line">switch01(vlan)<span class="comment">#vlan 3 name vlan3</span></span><br><span class="line">// 退出</span><br><span class="line">switch01(vlan)<span class="comment">#exit</span></span><br></pre></td></tr></table></figure></li><li><p>为VLAN2分配端口f0/1，最终通过查看VLAN2配置观察是否成功分配，注意要先两次exit才能退出配置模式进行查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">switch01<span class="comment">#config t</span></span><br><span class="line">// 进入f0/1端口</span><br><span class="line">switch01(config)<span class="comment">#in f0/1</span></span><br><span class="line">// 将端口f0/1分配给vlan2</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#switchport access vlan 2</span></span><br><span class="line">// 退出，使得配置生效</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#exit</span></span><br><span class="line">switch01(config)<span class="comment">#exit</span></span><br><span class="line">// 查看VLAN2配置，VLAN2被成功分配了端口f0/1</span><br><span class="line">switch01<span class="comment"># sh vlan name vlan2</span></span><br></pre></td></tr></table></figure></li><li><p>测试192.168.0.2: ping 192.168.0.5 ，不可连通</p></li><li><p>为VLAN2分配新端口f0/24，最终通过查看VLAN2配置观察是否成功分配</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">switch01<span class="comment">#config t</span></span><br><span class="line">// 进入f0/24端口</span><br><span class="line">switch01(config)<span class="comment">#in f0/24</span></span><br><span class="line">// 将端口f0/24分配给vlan2</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#switchport access vlan 2</span></span><br><span class="line">// 退出，使得配置生效</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#exit</span></span><br><span class="line">switch01(config)<span class="comment">#exit</span></span><br><span class="line">// 查看VLAN2配置，VLAN2被成功分配了端口f0/24</span><br><span class="line">switch01<span class="comment"># sh vlan name vlan2</span></span><br></pre></td></tr></table></figure></li><li><p>测试192.168.0.2: ping 192.168.0.5 ，连通</p></li></ol><blockquote><p>三、配置VLAN3</p></blockquote><ol><li><p>为VLAN3分配端口f0/1，最终通过查看VLAN3配置观察是否成功分配</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入配置模式</span><br><span class="line">switch01<span class="comment">#config t</span></span><br><span class="line">// 进入f0/1端口</span><br><span class="line">switch01(config)<span class="comment">#in f0/1</span></span><br><span class="line">// 将端口f0/1分配给vlan3</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#switchport access vlan 3</span></span><br><span class="line">// 退出，使得配置生效</span><br><span class="line">switch01(config -<span class="keyword">if</span>)<span class="comment">#exit</span></span><br><span class="line">switch01(config)<span class="comment">#exit</span></span><br><span class="line">// 查看VLAN3配置，VLAN3被成功分配了端口f0/1</span><br><span class="line">switch01<span class="comment"># sh vlan name vlan3</span></span><br></pre></td></tr></table></figure></li><li><p>测试192.168.0.2: ping 192.168.0.5 ，不可连通</p></li></ol><blockquote><p>四、删除VLAN</p></blockquote><ol><li><p>删除VLAN3的端口f0/1和VLAN2的f0/24</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进⼊配置模式</span><br><span class="line">switch01<span class="comment">#config t</span></span><br><span class="line">// 进⼊f0/1端⼝</span><br><span class="line">switch01(config)<span class="comment">#in f0/1</span></span><br><span class="line">// 将f0/1端⼝返还给VLAN1</span><br><span class="line">switch01(config-if)<span class="comment">#switchport access vlan 1</span></span><br><span class="line">// 退出</span><br><span class="line">switch01(config-if)<span class="comment">#exit</span></span><br><span class="line"></span><br><span class="line">// 进⼊f0/24端⼝</span><br><span class="line">switch01(config)<span class="comment">#in f0/24</span></span><br><span class="line">// 将f0/24端⼝返还给VLAN1</span><br><span class="line">switch01(config-if)<span class="comment">#switchport access vlan 1</span></span><br><span class="line">// 退出使配置⽣效</span><br><span class="line">switch01(config-if)<span class="comment">#exit</span></span><br><span class="line">switch01(config)<span class="comment">#exit</span></span><br></pre></td></tr></table></figure></li><li><p>查看VLAN配置，查看当前所有端口以及VLAN的配置。端口返还成功给VLAN1，VLAN2和VLAN3没有分配到任何端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch01<span class="comment">#sh vlan</span></span><br></pre></td></tr></table></figure></li><li><p>删除VLAN2和VLAN3</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入VLAN配置模式</span><br><span class="line">switch01<span class="comment">#vlan database</span></span><br><span class="line">//删除VLAN2</span><br><span class="line">switch01(vlan)<span class="comment">#no vlan 2</span></span><br><span class="line">//删除VLAN3</span><br><span class="line">switch01(vlan)<span class="comment">#no vlan 3</span></span><br><span class="line">//退出使配置⽣效</span><br><span class="line">switch01(vlan)<span class="comment">#exit</span></span><br></pre></td></tr></table></figure></li><li><p>查看VLAN配置，VLAN2和VLAN3被删除</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch01<span class="comment">#sh vlan</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实验问题与结果分析-1"><a href="#实验问题与结果分析-1" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><blockquote><p>一、测试192.168.0.2: ping 192.168.0.5能否连通</p></blockquote><ol><li>尚未配置VLAN前，VLAN1拥有所有端口，一个VLAN即一个广播域，在同一广播域下的92.168.0.2与192.168.0.5可以连通。</li><li>建立了VLAN2和VLAN3后，端⼝f0/1分配给VLAN2时，192.168.0.2与192.168.0.5位于不同的VLAN，不同VLAN中的两台计算机在不进⾏其他配置的情况下，不可连通</li><li>将端⼝f0/24分配给VLAN2后，两台计算机⼜处于同⼀VLAN，可以连通；</li><li>将端⼝f0/1分配给VLAN3后查看VLAN配置，⼀个端⼝只能被分配给⼀个VLAN(一个VLAN可以拥有多个端口，一对多关系)，两台计算机处于不同VLAN，不可连通；</li></ol><blockquote><p>二、实验注意事项</p></blockquote><ol><li>分配完端口后需查看VLAN2配置，观察是否成功分配，且要退出配置模式才能进行查看；</li><li>在进⾏实验前要注意清除两台计算机的DNS，并关闭防⽕墙；</li><li>有时端口不可用，可切换到其他端口进行实验；</li><li>注意连接交换机时，使用console线将计算机串口com2与路由器console口直接相连。</li></ol><h1 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h1><table><thead><tr><th align="center">课程名称</th><th align="center">姓名</th><th align="center">学号</th><th align="center">专业</th><th align="center">实验名称</th><th align="center">实验日期</th></tr></thead><tbody><tr><td align="center">计算机网络实验</td><td align="center">黄钰琳</td><td align="center">1751720</td><td align="center">软件工程</td><td align="center">NAT网络地址转换</td><td align="center">2019-11-27</td></tr></tbody></table><h2 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li>了解和掌握路由器地址转换功能，作为网络安全内容。  </li></ol><h2 id="实验设备-2"><a href="#实验设备-2" class="headerlink" title="实验设备"></a>实验设备</h2><ol><li>两台路由器，使⽤串⾏线将两个0串⼝对接；</li><li>两台计算机作为操作平台；</li><li>⼀台交换机担当⽹络连接。</li></ol><h2 id="实验网络拓扑-2"><a href="#实验网络拓扑-2" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h2><p><img alt="image-20191127153440440" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cmwf6r09j30x60ey0tu.jpg" class="lazyload"></p><h2 id="实验原理-2"><a href="#实验原理-2" class="headerlink" title="实验原理"></a>实验原理</h2><ol><li>网络地址转换（Network Address Translation，缩写为NAT），也叫做网络掩蔽或者IP掩蔽（IP masquerading），是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。它是一个方便且得到了广泛应用的技术。</li><li>NAT缺点：让主机之间的通信变得复杂，导致了通信效率的降低。</li><li>NAT将网络划分为内部网络(inside)和外部网络(outside)两部分。局域网主机利用NAT访问网络时，是将局域网内部的本地地址转换为全局地址(互联网合法IP地址)后转发数据包。</li><li>NAT有三种类型：静态NAT(StaticNAT)、动态地址NAT(PooledNAT)、网络地址端口转换NAPT（Port-LevelNAT）。</li><li>网络地址端口转换NAPT（NetworkAddressPortTranslation）则是把内部地址映射到外部网络的一个IP地址的不同端口上。它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的端口号。 NAPT是使用最普遍的一种转换方式。</li></ol><h2 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote><p>一、连接路由器</p></blockquote><ol><li><p>打开路由器电源</p></li><li><p>连接交换机，使用console线将计算机串口com1与路由器console口直接相连；</p></li><li><p>建立HyperTerminal：开始 -&gt; 程序 -&gt; 附件 -&gt; 通讯 -&gt; 超级终端 -&gt; 名称=<strong>router</strong> -&gt; 连接=<strong>com1</strong> -&gt; (波特率)Baut Rate=<strong>9600</strong>,8,no parity, 1 stop bit；</p></li><li><p>进入特权模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01&gt;en(able)</span><br><span class="line"><span class="built_in">pwd</span>=cisco //输入密码</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>二、转换方案</p></blockquote><ol><li><p>转换方案如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 不转换，内网访问</span><br><span class="line">192.168.1.1～15 </span><br><span class="line">// 转换，外网访问</span><br><span class="line">192.168.1.16～31 -&gt; 202.168.1.4～6</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>三、建立NAT</p></blockquote><ol><li><p>在Router01建立访问控制组和转换地址池。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 建立访问控制组</span><br><span class="line">router01(config)<span class="comment"># access-list 1 permit 192.168.1.16 0.0.0.15</span></span><br><span class="line">// 建立转换地址池</span><br><span class="line">router01(config)<span class="comment"># ip nat pool mypool 202.168.1.4 202.168.1.6 netmask 255.255.255.0</span></span><br></pre></td></tr></table></figure></li><li><p>设置动态NAT关系</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 设置动态NAT关系</span><br><span class="line">router05(config)<span class="comment"># ip nat inside source list 1 pool mypool</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>四、端口设置</p></blockquote><ol><li><p>设置Router01出口，端口 s2/0    </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 设置端口 s0/0</span><br><span class="line">router01 (config)<span class="comment">#in s2/0</span></span><br><span class="line">// 设置地址</span><br><span class="line">router01 (config-if)<span class="comment">#ip address 202.168.1.1 255.255.255.0</span></span><br><span class="line">// 设置转换方向，出口</span><br><span class="line">router01 (config-if)<span class="comment">#ip nat outside</span></span><br></pre></td></tr></table></figure></li><li><p>设置Router01进口，端口 f0/0  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 设置端口 f0/0</span><br><span class="line">router01 (config)<span class="comment">#in f0/0</span></span><br><span class="line">// 设置地址</span><br><span class="line">router01 (config-if)<span class="comment">#ip address 192.168.1.1 255.255.255.0</span></span><br><span class="line">// 设置转换方向，进口</span><br><span class="line">router01 (config-if)<span class="comment">#ip nat inside</span></span><br></pre></td></tr></table></figure></li><li><p>设置单向路由  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01 (config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 202.168.1.2</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>五、测试</p></blockquote><ol><li><p>检测         </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01<span class="comment"># debug ip nat</span></span><br></pre></td></tr></table></figure></li><li><p>配置计算机Host1的IP地址如下，此时是内网访问，不会被转成202.168.1.4~6，不能ping通</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host1的IP地址：192.168.1.15  </span><br><span class="line">ping 192.168.2.1</span><br></pre></td></tr></table></figure></li><li><p>配置计算机Host1的IP地址如下，此时是外网访问，会被转成202.168.1.4~6，能ping通</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host1的IP地址：192.168.1.17  </span><br><span class="line">ping 192.168.2.1</span><br></pre></td></tr></table></figure></li><li><p>查看转换地址表，动态转换只有才完成时才会显示。    </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">router01<span class="comment"># sh ip nat translation</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实验问题与结果分析-2"><a href="#实验问题与结果分析-2" class="headerlink" title="实验问题与结果分析"></a>实验问题与结果分析</h2><ol><li>NAT全称是“NetworkAddressTranslation”，即“网络地址转换”。</li><li>实验场景类似于微观角度的同济校园网，允许一个整体机构以一个公用IP（InternetProtocol）地址出现Internet上，是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。</li><li>记得设置端口方向inside和outside。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络实验报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长短句</title>
      <link href="/2019/11/26/%E9%95%BF%E7%9F%AD%E5%8F%A5/"/>
      <url>/2019/11/26/%E9%95%BF%E7%9F%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-11"><a href="#2019-11" class="headerlink" title="2019-11"></a>2019-11</h1><ol><li>精卫衔微木，将以填沧海。   ———— 陶渊明《读〈山海经〉·精卫衔微木》</li><li>敏而好学，不耻下问。      ———— 《论语·公冶长》</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文哲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长短句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2019/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="关系型数据库-NoSQL-分布式数据库"><a href="#关系型数据库-NoSQL-分布式数据库" class="headerlink" title="关系型数据库 - NoSQL - 分布式数据库"></a>关系型数据库 - NoSQL - 分布式数据库</h1><blockquote><p>参考网址：<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">百度搜索 - 数据库</a></p><p>参考网址：<a href="https://blog.csdn.net/qq_36411874/article/details/82013020" target="_blank" rel="noopener">关系型数据库与非关系型数据库Nosql区别汇总</a></p></blockquote><h2 id="发展现状"><a href="#发展现状" class="headerlink" title="发展现状"></a>发展现状</h2><p>数据库先后经历了层次数据库、网状数据库和关系数据库等各个阶段的发展，其中关系型数据库已成为目前数据库产品中最重要的一员，80年代以来，几乎所有的数据库厂商新出的数据库产品都支持关系型数据库，即使一些非关系数据库产品也几乎都有支持关系数据库的接口。这主要是传统的关系型数据库可以比较好的解决管理和存储关系型数据的问题。</p><p>随着云计算的发展和大数据时代的到来，由于越来越多的半关系型和非关系型数据需要用数据库进行存储管理，以此同时，分布式技术等新技术的出现也对数据库的技术提出了新的要求，于是越来越多的非关系型数据库就开始出现，这类数据库与传统的关系型数据库在设计和数据结构有了很大的不同，它们更强调数据库数据的高并发读写和存储大数据，这类数据库一般被称为NoSQL（Not only SQL）数据库。但传统的关系型数据库在一些传统领域依然保持了强大的生命力。</p><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。常见的关系型数据库有Mysql，SqlServer等。通过外键关联来建立表与表之间的关系。</p><p>数据库的SELECT，INSERT，UPDATE，DELETE对应了我们常用的增删改查四种操作。对于结构化数据的处理更合适，如学生成绩、地址等，这样的数据一般情况下需要使用结构化的查询，例如join，<br>这样的情况下，关系型数据库就会比NoSQL数据库性能更优，而且精确度更高。由于结构化数据的规模不算太大，数据规模的增长通常也是可预期的，所以针对结构化数据使用关系型数据库更好。关系型数据库十分注意数据操作的事务性、一致性，如果对这方面的要求关系型数据库无疑可以很好的满足。</p><p><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926113945323-238845177.png" class="lazyload"></p><h3 id="标准SQL语句"><a href="#标准SQL语句" class="headerlink" title="标准SQL语句"></a>标准SQL语句</h3><p>虽然关系型数据库有很多，但是大多数都遵循SQL（结构化查询语言，Structured Query Language）标准。常见的操作有查询，新增，更新，删除，求和，排序等。</p><ul><li>查询语句：SELECT param FROM table WHERE condition 该语句可以理解为从 table 中查询出满足 condition 条件的字段 param。</li><li>新增语句：INSERT INTO table （param1，param2，param3） VALUES （value1，value2，value3） 该语句可以理解为向table中的param1，param2，param3字段中分别插入value1，value2，value3。 </li><li>更新语句：UPDATE table SET param=new_value WHERE condition 该语句可以理解为将满足condition条件的字段param更新为 new_value 值。 [2] </li><li>删除语句：DELETE FROM table WHERE condition 该语句可以理解为将满足condition条件的数据全部删除。</li><li>去重查询：SELECT DISTINCT param FROM table WHERE condition 该语句可以理解为从表table中查询出满足条件condition的字段param，但是param中重复的值只能出现一次。 </li><li>排序查询：SELECT param FROM table WHERE condition ORDER BY param1该语句可以理解为从表table 中查询出满足condition条件的param，并且要按照param1升序的顺序进行排序。</li></ul><h2 id="非关系型数据库-NoSQL"><a href="#非关系型数据库-NoSQL" class="headerlink" title="非关系型数据库(NoSQL)"></a>非关系型数据库(NoSQL)</h2><p>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库中，我们查询一条数据，结果出来一个数组，关系型数据库中，查询一条数据结果是一个对象。</p><p>随着近些年技术方向的不断拓展，大量的NoSql数据库如MongoDB、Redis、Memcache出于简化数据库结构、避免冗余、影响性能的表连接、摒弃复杂分布式的目的被设计。</p><p><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114007198-781865994.png" class="lazyload"></p><p>NoSQL是分布式的、非关系型的、不保证遵循ACID原则的数据存储系统。NoSQL数据库技术与<code>CAP理论、一致性哈希算法</code>有密切关系。</p><ul><li><p>CAP理论：简单来说就是一个分布式系统不可能满足可用性、一致性与分区容错性这三个要求，一次性满足两种要求是该系统的上限。</p></li><li><p>一致性哈希算：指的是NoSQL数据库在应用过程中，为满足工作需求而在通常情况下产生的一种数据算法，该算法能有效解决工作方面的诸多问题但也存在弊端，即工作完成质量会随着节点的变化而产生波动，当节点过多时，相关工作结果就无法那么准确。这一问题使整个系统的工作效率受到影响，导致整个数据库系统的数据乱码与出错率大大提高，甚至会出现数据节点的内容迁移，产生错误的代码信息。</p></li></ul><p>但尽管如此，NoSQL数据库技术还是具有非常明显的应用优势，如数据库结构相对简单，在大数据量下的读写性能好；能满足随时存储自定义数据格式需求，非常适用于大数据处理工作。</p><p>NoSQL数据库适合追求速度和可扩展性、业务多变的应用场景。对于非结构化数据的处理更合适，如文章、评论，这些数据如全文搜索、机器学习通常只用于模糊处理，并不需要像结构化数据一样，进行精确查询，而且这类数据的数据规模往往是海量的，数据规模的增长往往也是不可能预期的，而NoSQL数据库的扩展能力几乎也是无限的，所以NoSQL数据库可以很好的满足这一类数据的存储。NoSQL数据库利用key-value可以大量的获取大量的非结构化数据，并且数据的获取效率很高，但用它查询结构化数据效果就比较差。</p><h3 id="NoSQL数据库分类"><a href="#NoSQL数据库分类" class="headerlink" title="NoSQL数据库分类"></a>NoSQL数据库分类</h3><p>目前NoSQL数据库仍然没有一个统一的标准，它现在有四种大的分类：</p><ul><li>键值对存储（key-value）：代表软件Redis，它的优点能够进行数据的快速查询，而缺点是需要存储数据之间的关系。<br><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114118589-2082748939.png" class="lazyload"></li><li>列存储：代表软件Hbase，它的优点是对数据能快速查询，数据存储的扩展性强。而缺点是数据库的功能有局限性。<br><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114133792-1420784459.png" class="lazyload"></li><li>文档数据库存储：代表软件MongoDB，它的优点是对数据结构要求不特别的严格。而缺点是查询性的性能不好，同时缺少一种统一查询语言。<br><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114108995-605863133.png" class="lazyload"></li><li>图形数据库存储：代表软件InfoGrid，它的优点可以方便的利用图结构相关算法进行计算。而缺点是要想得到结果必须进行整个图的计算，而且遇到不适合的数据模型时，图形数据库很难使用。<br><img alt data-src="https://images2017.cnblogs.com/blog/1013528/201709/1013528-20170926114142948-896683327.png" class="lazyload"></li></ul><h2 id="关系型数据库与NoSQL的区别"><a href="#关系型数据库与NoSQL的区别" class="headerlink" title="关系型数据库与NoSQL的区别"></a>关系型数据库与NoSQL的区别</h2><table><thead><tr><th align="center">区别</th><th align="left">关系型数据库</th><th align="left">非关系型数据库（Nosql）</th></tr></thead><tbody><tr><td align="center">存储方式</td><td align="left">表格式存储。存储在表的行和列中。他们之间很容易关联协作存储，提取数据很方便</td><td align="left">Nosql数据库则与其相反，他是大块的组合在一起。通常存储在数据集中，就像文档、键值对或者图结构。</td></tr><tr><td align="center">存储结构</td><td align="left"><code>结构化数据</code>。数据表都预先定义了结构（列的定义），结构描述了数据的形式和内容。这一点对数据建模至关重要，虽然预定义结构带来了可靠性和稳定性（优点），但是修改这些数据比较困难（缺点）。</td><td align="left">而Nosql数据库基于动态结构，使用<code>非结构化数据</code>。因为Nosql数据库是动态结构，可以很容易适应数据类型和结构的变化。</td></tr><tr><td align="center">存储规范</td><td align="left">数据存储为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。虽然管理起来很清晰，但是单个操作设计到多张表的时候，数据管理就显得有点麻烦</td><td align="left">而Nosql数据存储在平面数据集中，数据经常可能会重复。单个数据库很少被分隔开，而是存储成了一个整体，这样整块数据更加便于读写</td></tr><tr><td align="center">存储扩展</td><td align="left">系型数据库是<code>纵向扩展</code>，也就是说想要提高处理能力，要使用速度更快的计算机。因为数据存储在关系表中，操作的性能瓶颈可能涉及到多个表，需要通过提升计算机性能来克服。虽然有很大的扩展空间，但是最终会达到纵向扩展的上限</td><td align="left">而Nosql数据库是<code>横向扩展</code>的，它的存储天然就是分布式的，可以通过给资源池添加更多的普通数据库服务器来分担负载。</td></tr><tr><td align="center">查询方式</td><td align="left">结构化查询语言来操作数据库（就是我们通常说的SQL），使用关系型数据库表中<code>主键</code>，关系型数据库使用预定义优化方式（比如索引）来加快查询操作</td><td align="left">以块为单元操作数据，使用的是非结构化查询语言（UnQl），它是没有标准的，使用Nosql中存储文档的<code>D</code>,是更简单更精确的数据访问模式</td></tr><tr><td align="center">事务</td><td align="left">遵循<code>ACID规则</code>（原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)），支持对事务原子性细粒度控制，并且易于回滚事务。</td><td align="left">遵循<code>BASE原则</code>（基本可用（Basically Availble）、软/柔性事务（Soft-state ）、最终一致性（Eventual Consistency））Nosql数据库是在CAP（一致性、可用性、分区容忍度）中任选两项，因为基于节点的分布式系统中，很难全部满足，所以对事务的支持不是很好，虽然也可以使用事务，但是并不是Nosql的闪光点。</td></tr><tr><td align="center">性能</td><td align="left">为了维护数据的一致性付出了巨大的代价，读写性能比较差。在面对高并发读写性能非常差，面对海量数据的时候效率非常低。</td><td align="left">Nosql存储的格式都是key-value类型的，并且存储在内存中，非常容易存储，而且对于数据的 一致性是 弱要求。Nosql无需sql的解析，提高了读写性能。</td></tr><tr><td align="center">授权方式</td><td align="left">关系型数据库通常有SQL Server，Mysql，Oracle。大多数的关系型数据库都是付费的并且价格昂贵，成本较大。</td><td align="left">主流的Nosql数据库有redis，memcache，MongoDb。Nosql数据库通常都是开源的。</td></tr></tbody></table><h2 id="关系型数据库与NoSQL优缺点对比"><a href="#关系型数据库与NoSQL优缺点对比" class="headerlink" title="关系型数据库与NoSQL优缺点对比"></a>关系型数据库与NoSQL优缺点对比</h2><table><thead><tr><th align="center">类型</th><th align="left">关系型数据库 SQLite、Oracle、mysql</th><th align="left">非关系型数据库MongoDb、redis、HBase</th></tr></thead><tbody><tr><td align="center">特性</td><td align="left">1. 关系型数据库，是指采用了关系模型来组织数据的数据库；<br> 2. 关系型数据库的最大特点就是事务的一致性；<br> 3. 简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</td><td align="left">1. 使用键值对存储数据；<br> 2. 分布式；<br> 3. 一般不支持ACID特性；<br> 4. 非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</td></tr><tr><td align="center">优点</td><td align="left">1. 容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2. 使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3. 易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br> 4. 复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</td><td align="left">1. 速度快：无需经过sql层的解析，读写性能很高，nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>2. 高扩展性：基于键值对，数据没有耦合性，容易扩展；<br>3. 数据存储格式灵活：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。<br>4. 成本低：nosql数据库部署简单，基本都是开源软件。</td></tr><tr><td align="center">缺点</td><td align="left">1. 为了维护一致性所付出的巨大代价就是其读写性能比较差，尤其是海量数据的高效率读写；<br>2. 固定的表结构，灵活度稍欠；<br>3. 高并发读写需求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈；<br> 4. 难以进行海量数据的高效率读写；</td><td align="left">1. 不提供sql支持，学习和使用成本较高；<br>2. 无事务处理，附加功能bi和报表等支持也不好；</td></tr></tbody></table><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>所谓的分布式数据库技术，就是结合了数据库技术与分布式技术的一种结合。具体指的是把那些在地理意义上分散开的各个数据库节点，但在计算机系统逻辑上又是属于同一个系统的数据结合起来的一种数据库技术。既有着数据库间的协调性也有着数据的分布性。这个系统并不注重系统的集中控制，而是注重每个数据库节点的自治性，此外为了让程序员能够在编写程序时可以减轻工作量以及系统出错的可能性，一般都是完全不考虑数据的分布情况，这样的结果就使得系统数据的分布情况一直保持着透明性。 </p><p>数据独立性概念在分布式数据库管理系统中同样是十分重要的一环，但是不仅如此，分布式数据管理系统还增加了一个叫分布式透明性的新概念。这个新概念的作用是让数据进行转移时使程序正确性不受影响，就像数据并没有在编写程序时被分布一样。 </p><p>在分布式数据库里，数据冗杂是一种被需要的特性，这点和一般的集中式数据库系统不一样。第一点是为了提高局部的应用性而要在那些被需要的数据库节点复制数据。第二点是因为如果某个数据库节点出现系统错误，在修复好之前，可以通过操作其他的数据库节点里复制好的数据来让系统能够继续使用，提高系统的有效性。 </p><h1 id="数据库常见面试知识总结"><a href="#数据库常见面试知识总结" class="headerlink" title="数据库常见面试知识总结"></a>数据库常见面试知识总结</h1><p>这里是一些面试相关时数据库相关知识</p><blockquote><p>参考网址：<a href="https://github.com/huihut/interview#-%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">Github - 面试基础知识总结</a></p></blockquote><blockquote><p>本节部分知识点来自《数据库系统概论（第 5 版）》</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>数据（data）：描述事物的符号记录称为数据。</li><li>数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。</li><li>数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。</li><li>数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。</li><li>属性（attribute）：实体所具有的某一特性称为属性。</li><li>码（key）：唯一标识实体的属性集称为码。</li><li>实体（entity）：客观存在并可相互区别的事物称为实体。</li><li>实体(类)型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体(类)型。</li><li>实体集（entity set）：同一实体型的集合称为实体集。</li><li>联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。</li><li>模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li><li>外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li><li>内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。</li></ul><h2 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h2><ul><li>层次模型（hierarchical model）</li><li>网状模型（network model）</li><li>关系模型（relational model）<ul><li>关系（relation）：一个关系对应通常说的一张表</li><li>元组（tuple）：表中的一行即为一个元组</li><li>属性（attribute）：表中的一列即为一个属性</li><li>码（key）：表中可以唯一确定一个元组的某个属性组</li><li>域（domain）：一组具有相同数据类型的值的集合</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，一般表示为 <code>关系名(属性1, 属性2, ..., 属性n)</code></li></ul></li><li>面向对象数据模型（object oriented data model）</li><li>对象关系数据模型（object relational data model）</li><li>半结构化数据模型（semistructure data model）</li></ul><h2 id="常用-SQL-操作"><a href="#常用-SQL-操作" class="headerlink" title="常用 SQL 操作"></a>常用 SQL 操作</h2><table>  <tr>    <th>对象类型</th>    <th>对象</th>    <th>操作类型</th>  </tr>  <tr>    <td rowspan="4">数据库模式</td>    <td>模式</td>    <td><code>CREATE SCHEMA</code></td>  </tr>  <tr>    <td>基本表</td>    <td><code>CREATE SCHEMA</code>，<code>ALTER TABLE</code></td>  </tr>    <tr>    <td>视图</td>    <td><code>CREATE VIEW</code></td>  </tr>    <tr>    <td>索引</td>    <td><code>CREATE INDEX</code></td>  </tr>    <tr>    <td rowspan="2">数据</td>    <td>基本表和视图</td>    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>  </tr>    <tr>    <td>属性列</td>    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>  </tr></table><br><br><blockquote><p>SQL 语法教程：<a href="http://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">菜鸟Runoob - SQL 教程</a></p></blockquote><blockquote><p>DB2 教程：<a href="https://www.yiibai.com/db2/db2_databases.html" target="_blank" rel="noopener">易百 - DB2 教程</a></p></blockquote><h2 id="关系型数据库-1"><a href="#关系型数据库-1" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><ul><li><p>基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改</p></li><li><p>关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性。</p><ul><li>实体完整性：要求每个数据表都必须有主键，而作为主键的所有字段，其属性必须是独一及非空值。</li><li>参照完整性：相关联的两个表之间的约束，要求关系中不允许引用不存在的实体。</li><li>用户定义的完整性：用户自定义完整性是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。主要包括非空约束、唯一约束、检查约束、主键约束、外键约束</li></ul></li><li><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3></li><li><p>数据库索引：顺序索引、B+ 树索引、hash 索引</p></li><li><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></p></li></ul><h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><ul><li>数据库的完整性是指数据的正确性和相容性。<ul><li>完整性：为了防止数据库中存在不符合语义（不正确）的数据。</li><li>安全性：为了保护数据库防止恶意破坏和非法存取。</li></ul></li><li>触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。</li></ul><h2 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h2><ul><li>数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。</li><li>最重要的数据依赖：函数依赖、多值依赖。</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li>第一范式（1NF）：属性（字段）是最小单位不可再分。</li><li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。</li><li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）。</li><li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。</li><li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。</li></ul><h2 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h2><ul><li>事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li><li>事物的 ACID 特性：原子性、一致性、隔离性、持续性。</li><li>恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。</li><li>建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。</li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul><li>事务是并发控制的基本单位。</li><li>并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。</li><li>并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。</li><li>基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。</li><li>活锁死锁：<ul><li>活锁：事务永远处于等待状态，可通过先来先服务的策略避免。</li><li>死锁：事物永远不能结束<ul><li>预防：一次封锁法、顺序封锁法；</li><li>诊断：超时法、等待图法；</li><li>解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。</li></ul></li></ul></li><li>可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。</li></ul><h1 id="常见大型数据库"><a href="#常见大型数据库" class="headerlink" title="常见大型数据库"></a>常见大型数据库</h1><blockquote><p>参考网址：<a href="https://blog.csdn.net/jxcjxinxing/article/details/2088900" target="_blank" rel="noopener">常用大型数据库比较</a></p></blockquote><p>目前商品化的数据库管理系统以关系型数据库为主导产品，技术比较成熟。国际国内的主导关系型数据库管理系统有ORACLE、SYBASE、INFORMIX和INGRES。这些产品都支持多平台，如UNIX、VMS、 WINDOWS，但支持的程度不一样。</p><p>IBM 的 DB2 也是成熟的关系型数据库。但是，DB2是内嵌于IBM的 AS/400系列机中，只支持OS/400操作系统。</p><p>根据选择数据库管理系统的依据，我们比较、分析一下这几种数据库管理系统的性能：</p><h2 id="ORACLE数据库管理系统"><a href="#ORACLE数据库管理系统" class="headerlink" title="ORACLE数据库管理系统"></a>ORACLE数据库管理系统</h2><ul><li>无范式要求，可根据实际系统需求构造数据库。</li><li>采用标准的SQL结构化查询语言。</li><li>具有丰富的开发工具，覆盖开发周期的各阶段。</li><li>支持大型数据库，数据类型支持数字、字符、大至2GB的二进制数<br>据，为数据库的面向对象存储提供数据支持。</li><li>具有第四代语言的开发工具（SQL<em>FORMS、SQL</em>REPORTS、SQL*MENU等）。</li><li>具有字符界面和图形界面，易于开发。ORACLE7。1版本具有面<br>向对象的开发环境CDE2。</li><li>通过SQL*DBA控制用户权限，提供数据保护功能，监控数据库的<br>运行状态，调整数据缓冲区的大小。</li><li>分布优化查询功能。</li><li>具有数据透明、网络透明，支持异种网络、异构数据库系统。并行<br>处理采用动态数据分片技术。</li><li>支持客户机/服务器体系结构及混合的体系结构（集中式、分布式、<br>客户机/服务器）。</li><li>实现了两阶段提交、多线索查询手段。</li><li>支持多种系统平台（HPUX、SUNOS、OSF/1、VMS、<br>WINDOWS、WINDOWS/NT、OS/2）。</li><li>数据安全保护措施：没有读锁，采取快照SNAP方式完全消除了分<br>布读写冲突。自动检测死锁和冲突并解决。</li><li>数据安全级别为C2级（最高级）。</li><li>数据库内模支持多字节码制，支持多种语言文字编码。</li><li>具有面向制造系统的管理信息系统和财务系统应用系统。</li><li>ORACLE7。1版本服务器支持1000—10000个用户。<br>WORKGROUP/2000具有ORACLE7WORKGROUP服务器，<br>POWER OBJECTS（图形开发环境，支持OS/2、UNIX、 WINDOWS/NT平台。</li><li>在中国的销售份额占50%以上。</li></ul><h2 id="DB2数据库管理系统"><a href="#DB2数据库管理系统" class="headerlink" title="DB2数据库管理系统"></a>DB2数据库管理系统</h2><p>DB2是内嵌于IBM的AS/400系统上的数据库管理系统，直接由硬件支持。它支持标准的SQL语言，具有与异种数据库相连的GATEWAY。因此它具有速度快、可靠性好的优点。</p><p>但是，只有硬件平台选择了IBM的AS/400，才能选择使用DB2数据库管理系统。</p><h2 id="SYBASE-10-数据库管理系统"><a href="#SYBASE-10-数据库管理系统" class="headerlink" title="SYBASE 10 数据库管理系统"></a>SYBASE 10 数据库管理系统</h2><p>SYBASE数据库系统从1992年11月开始开发，历经12 — 24个月的开发形成产品，产品包括：SQL SERVER 10（数据库管理系统的核心），REPLICATION SERVER（实现数据库分布的服务器），BACKUP SERVER（网络环境下的快速备份服务器），OMINI SQL GATEWAY（异构数据库库关）， NAVIGATION SERVER（网络上可扩充的并行处理能力服务器），CONTROL SERVER（数据库管理员服务器）。属于客户机/服务器体系结构，提供了在网络环境下的各节点上的数据库数据的互访。</p><h3 id="SYBASE的技术特点"><a href="#SYBASE的技术特点" class="headerlink" title="SYBASE的技术特点"></a>SYBASE的技术特点</h3><ul><li>完全的客户机/服务器体系结构，能适应OLTP（ON—LINE<br>TRANSACTION PROCESSING）要求，能为数百用户提供高性能需求。</li><li>采用单进程多线索（SINGLE PORCESS AND MULTI—THREADED）<br>技术进行查询，节省系统开销，提高内存的利用率。</li><li>支持存储过程，客户只需通过网络发出执行请求，就可马<br>上执行，有效地加快了数据库访问速度，明显减少网络通讯量，<br>有可能极大的改善网络环境的运行效率，增加数据库的服务容量。</li><li>虚服务器体系结构与对称多处理器（SMP）技术结合，充分发<br>挥多CPU硬件平台的高性能。</li><li>数据库管理系统DBA在线调整监控数据库系统的性能。</li><li>提供日志与数据库的镜象，提高数据库容错能力。</li><li>支持计算机蔟族（CLUSTER）环境下的快速故障切换。</li><li>通过存储和触发器（TRIGGER）由服务器制约数据的完整性。</li><li>多种安全机制对表、视图、存储过程、命令进行授权。</li><li>分布式事务处理采用2PC（TWO PHASE COMMIT）技术访问</li><li>支持IMAGE和TEXT的数据类型，为工程数据库和多媒体应<br>用提供了良好的基础。</li></ul><h3 id="SYBASE的开发工具"><a href="#SYBASE的开发工具" class="headerlink" title="SYBASE的开发工具"></a>SYBASE的开发工具</h3><ul><li>DATA WORKBENCH</li><li>VISUAL QUERY LANGUANGE（图形查询语言）</li><li>REPORT WORKBENCH（报表系统）</li><li>INTERACTIVE SQL（交互式SQL环境）</li><li>DATA ENTRY（快速录入数据）<br>APT WORKBENCH<br>EMBEDED SQL</li><li>SQR WORKBENCH（开放式报表系统）</li><li>EASY SQR（基于菜单的报表生成器）</li><li>SQR 4GL（第四代语言报表生成器）</li><li>SQR DEBUG（调试工具）</li><li>SQL—EXECUTE（动态表格配置）<br>GAIN MOMENTUM（面向对象的多媒体开发平台，可以<br>编辑动画、声音、位图）</li></ul><h3 id="SYBASE的不足"><a href="#SYBASE的不足" class="headerlink" title="SYBASE的不足"></a>SYBASE的不足</h3><ul><li>多服务器系统不支持分布透明</li><li>REPLICATION SERVER数据方面的性能较差，并不能<br>与操作系统集成</li><li>对中文的支持较差</li><li>多用于银行系统等</li><li>尚无在此数据库基础上的企业管理信息系统</li></ul><h2 id="INGRES智能关系性数据库管理系统"><a href="#INGRES智能关系性数据库管理系统" class="headerlink" title="INGRES智能关系性数据库管理系统"></a>INGRES智能关系性数据库管理系统</h2><p>INGRES数据库系统的多项技术直接采用了伯克利大学最新研究成果。技术上一直处于领先水平。INGRES数据库不仅能管理数据，而且还能管理知识和对象（对象是指数据与操作的结合体，计算机把他们作为整体处理）。 </p><p>INGRES产品分为三类：第一类为数据库基本系统，包括了数据管理、知识管理、和对象管理。第二类为开发工具。第三类为开放互联产品。</p><h3 id="INGRES的特点"><a href="#INGRES的特点" class="headerlink" title="INGRES的特点"></a>INGRES的特点</h3><ul><li>开放的客户机/服务器体系结构，允许用户建立多个多线索服务器。</li><li>编译的数据库过程。数据库过程用INGRES第四代语言编<br>写。由服务器编译管理，用来实现预定义的事务处理，减小CPU负载，减小网络开销。</li><li>智能优化功能。根据查询语言的要求自动地在网络环境中调 整查询顺序，寻找最佳路径。</li><li>数据的在线备份。无需中断系统的正常运行，备份保持一致性的数据库备份。</li><li>I/O减量处理。提供快速提交、成组提交、多块读出与写入的技术。减少I/O量。</li><li>多文件存储数据。一个表用一个文件存储，便于在异常情况下对数据库存进行恢复。</li><li>采用两阶段提交协议，保证了网络分布事务的一致性。</li><li>具有数据库规则系统。自动激活满足行为条件的规则，对每个表拥有的独立规则数不受限制，</li><li>无限制的向前推理和无限递归，确保数据库的一致性。</li><li>具有报警系统，当数据在规定的数据量极限时，自动作出相应的操作。</li><li>资源控制与查询优化相结合，由服务器控制查询的资源消耗，确保系统的可预测性能。</li><li>能够对用户自己定义的数据类型进行处理、存储，定义数据的有效区间。</li><li>允许用户将自己定义的函数嵌入到数据库管理系统中。</li></ul><h3 id="INGRES的开发工具"><a href="#INGRES的开发工具" class="headerlink" title="INGRES的开发工具"></a>INGRES的开发工具</h3><ul><li>INGRES/WINDOWS 4GL，该工具通过面向对象的第四代语言和调试器，提高程序员的生产率。支持MICROSOFT WINDOWS、OPEN LOOK、DECWIN等窗口环境。 </li><li>INGRES/VISION。是应用代码生成器，包括支持高级界面特征（应用结构的图形表示、菜单驱动、在线HELP、有效数据的动态选择）。还允许用户调整生成的代码。用户决策支持工具。包括GQL（GRAPHIC QUERY LANGUAGE）、GRAFSMAN、IPM（INTERACTIVE PERFORMANCE MONITOR </li><li>INGRES/NET，是一种基于全局通信体系结构，能与OSI兼容的客户机/服务器通信协议。支持诗句的透明性、网络的透明性、多平台透明性。 </li><li>INGRE/STAR，是一种分布信息管理机制，他允许用户将分布在不同场地的数据库视为整体，为分布式数据库提供多数据库存的集成、分布数据字典、分布 查询优化、分布处理。 </li><li>INGRES/GATEWAY，非INGRES数据库系统与INGRES数据库互联产品。</li><li>INGRES ENHANCED SECURITY增强保安系统，按美国B1 安全指标设计的安全系统，满足数据一致性、可用性、可信性要求，具有行层标签、底层多层安全系统、安全标签数据类型和复杂的一致性机制。</li></ul><h3 id="INGRES的不足"><a href="#INGRES的不足" class="headerlink" title="INGRES的不足"></a>INGRES的不足</h3><p>学术价值大于实用价值。即在学术方面掌握领先技术，在产品服务上比较薄弱。</p><h2 id="INFORMIX数据库管理系统"><a href="#INFORMIX数据库管理系统" class="headerlink" title="INFORMIX数据库管理系统"></a>INFORMIX数据库管理系统</h2><p>INFORMIX运行在UNIX平台，支持SUNOS、HPUX、 ALFAOSF/1。采用双引擎机制，占用资源小，简单易用。适用于中小型数据库管理。</p><h3 id="INFORMIX的特点"><a href="#INFORMIX的特点" class="headerlink" title="INFORMIX的特点"></a>INFORMIX的特点</h3><ul><li>DSA（DYMANIC SCALABLE ARCHITECTURE）动态可调整结构支持SMP查询语句</li><li>多线索查询机制</li><li>具有三个任务队列</li><li>具有虚拟处理器</li><li>提供并行索引功能，是高性能的OLTP数据库</li><li>数据物理结构为静态分片</li><li>支持双机簇族（CLUSTER）（只支持SESQUENT 平台）</li><li>具有对复杂系统应用开发的INFORMIX 4GL CADE工具</li></ul><h3 id="INFORMIX的主要产品"><a href="#INFORMIX的主要产品" class="headerlink" title="INFORMIX的主要产品"></a>INFORMIX的主要产品</h3><ul><li>INFORMIX—SE</li><li>INFORMIX—ONLINE</li><li>INFORMIX—SQL</li><li>INFORMIX—4GL</li><li>INFORMIX—OPEN CASE/TOOL BUS</li><li>INFORMIX—VIEW POINT</li><li>INFORMIX—STAR</li><li>INFORMIX—NET</li><li>INFORMIX—GATEWAY</li></ul><h3 id="INFORMIX的不足"><a href="#INFORMIX的不足" class="headerlink" title="INFORMIX的不足"></a>INFORMIX的不足</h3><ul><li>网络性能不好，不支持异种网络。即只支持数据透明不支持网络透明。</li><li>并发控制易死锁。</li><li>数据备份具有软件镜象功能，速度慢、可靠性差。</li><li>对大型数据库系统不能得到很好的性能。</li><li>开发工具不成熟，只具有字符界面，多媒体数据弱，无覆盖全开发过程的CASE工具。</li><li>无CLIENT/SERVER分布式处理模式</li><li>可移植性差，不同版本的数据结构不兼容。</li><li>4GL与CADE的代码不可移植。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ebook微服务学习笔记</title>
      <link href="/2019/11/12/ebook%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
      <url>/2019/11/12/ebook%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>这里是构建基于微服务的ebook的一些记录。将会继续更新</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://www.bilibili.com/video/av74750602?p=46" target="_blank" rel="noopener">黑马乐优项目12月视频合集</a>：[45]搭建聚合工程及注册中心,[46]搭建聚合工程及注册中心,[47]添加路由规则,[56-73]vue学习,[76]运行后台管理前端工程,[77]同一环境,[78]域名访问项目,[79]nginx</p></li><li><p><a href="https://www.bilibili.com/video/av29882762?p=4" target="_blank" rel="noopener">千锋教育iToken视频合集</a>：敏捷开发、XP、部署持续集成、nginx反向代理</p></li></ol><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>才发现居然没有用Docker。。。</p><p><img alt="乐优架构图" data-src="https://wx3.sinaimg.cn/mw690/007CtYmwgy1g8vqesx7l2j30pt0smdjz.jpg" class="lazyload"></p><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><h4 id="nginx-千锋iToken笔记"><a href="#nginx-千锋iToken笔记" class="headerlink" title="nginx(千锋iToken笔记)"></a>nginx(千锋iToken笔记)</h4><p>nginx像一个伪CDN，功能有：</p><ol><li>服务器：要通过浏览器请求，就必须有一个服务器比如tomcat。tomcat既是一个服务器也是一个servler容器，但nginx就是一个静态服务器</li><li>虚拟主机：一个服务器上虚拟出多个网站，例如个人网站使用的虚拟主机，tomcat也有这个功能，多配几个host就多了几个虚拟主机</li><li>反向代理、负载均衡：多并发时，需要多台服务器集群时可以用nginx时可以用它反向代理，且可以使得多台服务器平均分担负载</li></ol><h2 id="开发填坑"><a href="#开发填坑" class="headerlink" title="开发填坑"></a>开发填坑</h2><h4 id="sudo-nginx报错"><a href="#sudo-nginx报错" class="headerlink" title="sudo nginx报错"></a>sudo nginx报错</h4><p>原因是8080端口被占用。报错如图所示：<br><img alt data-src="https://wx4.sinaimg.cn/mw690/007CtYmwgy1g8vqe6vq2zj30vi04040g.jpg" class="lazyload"></p><p>解决方法如下：</p><ul><li><p>8080端口被占用，根据进程PID(38871)关闭进程</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">kill</span> -9 38871</span><br></pre></td></tr></table></figure></li><li><p>重新启动nginx：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo nginx -c /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>浏览器中打开 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>，启动成功</p></li><li><p>打开nginx.conf文件进行编辑</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ open /usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>修改nginx后输入  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure></li></ul><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>接下来要实现用nginx管理zuul网关，后台api赶快连一下。</p><h2 id="随笔记录"><a href="#随笔记录" class="headerlink" title="随笔记录"></a>随笔记录</h2><p>上传了一下项目到github上，收到了24封dependabot邮件,有空看一下</p><p>乐优是通过更改host为leyou.com来实现伪域名的，目前停在了这里。</p><p>nginx的作用是用来管理zuul网关，用于实现高可用性。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发备忘录</title>
      <link href="/2019/11/12/%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>/2019/11/12/%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="git与github"><a href="#git与github" class="headerlink" title="git与github"></a>git与github</h3><p>参考视频：<a href="https://www.bilibili.com/video/av55780016?p=3" target="_blank" rel="noopener">bilibili：1小时玩转 Git/Github</a></p><h4 id="保存到远程仓库"><a href="#保存到远程仓库" class="headerlink" title="保存到远程仓库"></a>保存到远程仓库</h4><ol><li>新建一个仓库后，在电脑创建一个空文件[如/code]，然后cd到该文件，终端里输入, <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> code</span><br><span class="line">$ git <span class="built_in">clone</span> &lt;&lt;iwork项目的SSH或HTTPS&gt;&gt;</span><br></pre></td></tr></table></figure></li><li>cd到[/code/iwork]下，输入sudo git status查看状态<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> iwork</span><br></pre></td></tr></table></figure></li><li>在本地文件夹里增加文件，然后输入sudo git add &lt;文件名.md&gt;或sudo git add .此时文件保存到git的index中，但是还没有同步到远程上。此时sudo git status查看一下状态，会发现新文件但没有commit。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo git add .</span><br></pre></td></tr></table></figure></li><li>输入sudo git commit  -m “the message you want when commit”，可以sudo git status查看一下状态，文件已经commit <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo git commit  -m “the message you want when commit”</span><br></pre></td></tr></table></figure></li><li>输入 git push 后github上远程可见 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure></li></ol><h3 id="Mac查看IP地址和MAC"><a href="#Mac查看IP地址和MAC" class="headerlink" title="Mac查看IP地址和MAC"></a>Mac查看IP地址和MAC</h3><ol><li>终端输入ifconfig然后回车   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo git commit  -m “the message you want when commit”</span><br></pre></td></tr></table></figure></li><li>其中“eth0”表示以太网网卡，“lo0”表示环回地址。下图的以太网网卡IP地址是“192.168.239.141”，MAC地址是38:0c:29:26:bc:07”</li></ol><p><img alt data-src="/Users/hamster/Desktop/Life/github/iBlog/iBlog/source/_posts/images/20191113_1.jpg" class="lazyload"></p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h4 id="创建SSH"><a href="#创建SSH" class="headerlink" title="创建SSH"></a>创建SSH</h4>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Butterfly的建站日志</title>
      <link href="/2019/11/10/%E5%9F%BA%E4%BA%8EButterfly%E7%9A%84%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
      <url>/2019/11/10/%E5%9F%BA%E4%BA%8EButterfly%E7%9A%84%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Butterfly文档配置"><a href="#Butterfly文档配置" class="headerlink" title="Butterfly文档配置"></a>Butterfly文档配置</h3><h4 id="1-主页文章节选"><a href="#1-主页文章节选" class="headerlink" title="1.主页文章节选"></a>1.主页文章节选</h4><p>主页文章节选只支持自动节选和文章页description两种，此处设置为文章页description，关闭了自动节选，因为文字和代码块等的显示可能因此导致不正常。以后写文档时注意⚠️。</p><h4 id="2-文章版权"><a href="#2-文章版权" class="headerlink" title="2.文章版权"></a>2.文章版权</h4><p>记得有空设置一下，然后写文章之前看一下文档的3.7-3.11</p><p>link:  <a href="https://jerryc.me/posts/21cfbf15/#文章相關項" target="_blank" rel="noopener">Butterfly文档</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">post_copyright:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  license: CC BY-NC-SA 4.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/</span><br></pre></td></tr></table></figure><h4 id="4-post的mg"><a href="#4-post的mg" class="headerlink" title="4.post的mg"></a>4.post的mg</h4><p>在markdown中通过微博相册存储文章top_img和cover_img，本来想github的但是加载有点慢</p><h4 id="5-配置文档"><a href="#5-配置文档" class="headerlink" title="5.配置文档"></a>5.配置文档</h4><p>配置参考dalao的文档：<a href="https://jerryc.me/posts/21cfbf15/#文章封面" target="_blank" rel="noopener">Butterfly文档</a></p><h4 id="6-note的example效果预览"><a href="#6-note的example效果预览" class="headerlink" title="6.note的example效果预览"></a>6.note的example效果预览</h4><p><a href="https://theme-next.org/docs/tag-plugins/note" target="_blank" rel="noopener">点击这里查看note官方文档</a></p><div class="note ">            <h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>(without define class style)</p>          </div><div class="note default">            <h4 id="Default-Header"><a href="#Default-Header" class="headerlink" title="Default Header"></a>Default Header</h4><p>Welcome to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note primary">            <h4 id="Primary-Header"><a href="#Primary-Header" class="headerlink" title="Primary Header"></a>Primary Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note info">            <h3 id="Info-Header"><a href="#Info-Header" class="headerlink" title="Info Header"></a>Info Header</h3><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note success">            <h4 id="Success-Header"><a href="#Success-Header" class="headerlink" title="Success Header"></a>Success Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note warning">            <h4 id="Warning-Header"><a href="#Warning-Header" class="headerlink" title="Warning Header"></a>Warning Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note danger">            <h4 id="Danger-Header"><a href="#Danger-Header" class="headerlink" title="Danger Header"></a>Danger Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><div class="note info no-icon">            <h4 id="No-icon-note"><a href="#No-icon-note" class="headerlink" title="No icon note"></a>No icon note</h4><p>Note <strong>without</strong> icon: <code>note info no-icon</code></p><p>note info, note info, note info<br>note info, note info, note info<br>note info, note info, note info</p>          </div><div class="note success">            <h4 id="Codeblock-in-note"><a href="#Codeblock-in-note" class="headerlink" title="Codeblock in note"></a>Codeblock in note</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br></pre></td></tr></table></figure>          </div><div class="note default">            <h4 id="Lists-in-note"><a href="#Lists-in-note" class="headerlink" title="Lists in note"></a>Lists in note</h4><ul><li>ul</li><li>ul<ul><li>ul</li><li>ul</li></ul></li><li>ul</li></ul><ol><li>ol</li><li>ol<ol><li>ol</li><li>ol</li></ol></li><li>ol</li></ol>          </div><h4 id="Table-in-Note"><a href="#Table-in-Note" class="headerlink" title="Table in Note"></a>Table in Note</h4><div class="note default">            <table><thead><tr><th>1</th><th>2</th></tr></thead><tbody><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table>          </div><h4 id="7-gallery相册的效果预览"><a href="#7-gallery相册的效果预览" class="headerlink" title="7.gallery相册的效果预览"></a>7.gallery相册的效果预览</h4><div class="justified-gallery"><p><img alt data-src="https://gratisography.com/wp-content/uploads/2019/10/gratisography-scary-pumpkin-hand-900x600.jpg" class="lazyload"><br><img alt data-src="https://gratisography.com/wp-content/uploads/2019/10/gratisography-fresh-fish-dinner-900x600.jpg" class="lazyload"><br><img alt data-src="https://gratisography.com/wp-content/uploads/2019/10/gratisography-mountain-cloud-landscape-900x600.jpg" class="lazyload"><br><img alt data-src="https://picjumbo.com/wp-content/uploads/iphone-free-stock-photos-2210x3315.jpg" class="lazyload"><br><img alt data-src="https://picjumbo.com/wp-content/uploads/young-millennial-girl-drinking-lemonade-and-overlooking-the-city-2210x1473.jpg" class="lazyload"><br><img alt data-src="https://picjumbo.com/wp-content/uploads/modern-graphic-designer-essentials_free_stock_photos_picjumbo_HNCK4919-2210x1474.jpg" class="lazyload"></p>          </div><h4 id="8-文章置顶"><a href="#8-文章置顶" class="headerlink" title="8.文章置顶"></a>8.文章置顶</h4><p>在想要置顶的markdown的文章的title中加一个属性：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxx</span><br><span class="line">tags:</span><br><span class="line">  - xxx</span><br><span class="line">date: 2018-08-08 08:08:08</span><br><span class="line">top: <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="3-29-32都弄完了"><a href="#3-29-32都弄完了" class="headerlink" title="3.29-32都弄完了"></a>3.29-32都弄完了</h4><h4 id="3-29-32都弄完了-1"><a href="#3-29-32都弄完了-1" class="headerlink" title="3.29-32都弄完了"></a>3.29-32都弄完了</h4><p>出现一个很奇怪的bug，运行hexo clean &amp; hexo g后public下的index.html就消失了，目前不知道哪里出了问题只能手动添加一下index.html再hexo s了</p><p>又看了一下，hexo clean的时候会删除整个public文件夹，hexo g的时候又会重新生成，但是没有index.html了,也不报错。。。</p><p>啊我个傻子，原因是配置文章置顶功能的时候，要先npm uninstall hexo-generator-index –save 然后 npm install hexo-generator-index-pin-top –save。<br>我只做了第一步。。。。。。。</p><p>个傻子，学会了认真看文档+版本管理QAQ</p><h4 id="8-先咕着"><a href="#8-先咕着" class="headerlink" title="8.先咕着"></a>8.先咕着</h4><h4 id="9-其他"><a href="#9-其他" class="headerlink" title="9.其他"></a>9.其他</h4><p>看着ffgg的加了一只狗狗，我们姑且叫他小咕</p><p>ffgg的加密不能用，会与目录冲突，先放着</p><p>评论不能加，蹲一波dalao的回复。找到一篇博主的文章，但还是失败了<br><a href="https://blog.csdn.net/weixin_30721077/article/details/96266356" target="_blank" rel="noopener">【Valine评论设置——基于next】</a></p><h4 id="10-分享"><a href="#10-分享" class="headerlink" title="10.分享"></a>10.分享</h4><p>分享弄完了，push一下</p><h4 id="11-改进"><a href="#11-改进" class="headerlink" title="11.改进"></a>11.改进</h4><p>1.这个Sakura主题的blog好好看！！！！<br><a href="https://yremp.live/hexo-sakura/" target="_blank" rel="noopener">Sakura</a></p><p>喜欢鼠标、喜欢返回顶部和里面的代码！要是能八一八就好惹～</p><p>2.配置文件的<br>选择<a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">【Valine】</a>作为评论服务商。<br>注册完了但是失败。。。有空再调一下吧</p><p>搜索的Algolia没有弄，网站验证下次再说,不想搞，不想被发现QAQ<br>footer背景没弄,因为没找到合适的<br>PWA失败，再说吧</p><p>3.加一下音视频<br>加密继续，参考ffgg的配置，多看看别人的blog</p>]]></content>
      
      
      <categories>
          
          <category> 开发日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站日志 Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown手册</title>
      <link href="/2019/11/10/markdown%E6%89%8B%E5%86%8C/"/>
      <url>/2019/11/10/markdown%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="git与github版本管理"><a href="#git与github版本管理" class="headerlink" title="git与github版本管理"></a>git与github版本管理</h3><ul><li><input checked="" disabled="" type="checkbox"> P45 搭建聚合工程及注册中心</li><li><input checked="" disabled="" type="checkbox"> P46 搭建网关微服务及common工程</li><li><input checked="" disabled="" type="checkbox"> P47 添加路由规则</li><li><input disabled="" type="checkbox"> P48 56-73 vue学习</li><li><input checked="" disabled="" type="checkbox"> P76 运行后台管理前端工程<br>￼</li><li><input checked="" disabled="" type="checkbox"> P77 同一环境</li><li><input checked="" disabled="" type="checkbox"> P78 域名访问项目</li></ul>]]></content>
      
      
      <categories>
          
          <category> 手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手册 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

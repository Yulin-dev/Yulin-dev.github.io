<!DOCTYPE html><html lang="zh-CN" data-theme="pale night"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>编译原理 | 微木斋</title><meta name="description" content="编译原理"><meta name="keywords" content="编译原理"><meta name="author" content="不夜侯"><meta name="copyright" content="不夜侯"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="编译原理"><meta name="twitter:description" content="编译原理"><meta name="twitter:image" content="https://w.wallhaven.cc/full/ox/wallhaven-oxj7mm.jpg"><meta property="og:type" content="article"><meta property="og:title" content="编译原理"><meta property="og:url" content="http://yoursite.com/2019/11/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="微木斋"><meta property="og:description" content="编译原理"><meta property="og:image" content="https://w.wallhaven.cc/full/ox/wallhaven-oxj7mm.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2019/11/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><link rel="prev" title="iWork需求分析规约" href="http://yoursite.com/2019/12/15/iWork%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%A7%84%E7%BA%A6/"><link rel="next" title="软件工程" href="http://yoursite.com/2019/11/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">微木斋</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-photo"></i><span> Photo</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-photo"></i><span> Photo</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#绪论"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">绪论</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#课件PPT"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">课件PPT</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是编译"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">什么是编译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#编译系统的结构"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">编译系统的结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#词法分析概述"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">词法分析概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#语法分析概述"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">语法分析概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#语义分析概述"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">语义分析概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中间代码生成及编译器后端概述"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">中间代码生成及编译器后端概述</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#语言及其文法"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">语言及其文法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#基本概念"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">基本概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#字母表"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">字母表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#字母表上的运算"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">字母表上的运算</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#符号串"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">符号串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#串上的运算"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text">串上的运算</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文法的定义"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">文法的定义</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#文法的形式化定义"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">文法的形式化定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#产生式的简写"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">产生式的简写</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#符号的约定"><span class="toc_mobile_items-number">2.2.3.</span> <span class="toc_mobile_items-text">符号的约定</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#语言的定义"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">语言的定义</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#推导与规约"><span class="toc_mobile_items-number">2.3.1.</span> <span class="toc_mobile_items-text">推导与规约</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#句型和句子"><span class="toc_mobile_items-number">2.3.2.</span> <span class="toc_mobile_items-text">句型和句子</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#语言的形式化定义"><span class="toc_mobile_items-number">2.3.3.</span> <span class="toc_mobile_items-text">语言的形式化定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#语言上的运算"><span class="toc_mobile_items-number">2.3.4.</span> <span class="toc_mobile_items-text">语言上的运算</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文法的分类"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">文法的分类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#0型文法，无限制文法，短语结构文法"><span class="toc_mobile_items-number">2.4.1.</span> <span class="toc_mobile_items-text">0型文法，无限制文法，短语结构文法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1型文法，上下文有关文法-CSG"><span class="toc_mobile_items-number">2.4.2.</span> <span class="toc_mobile_items-text">1型文法，上下文有关文法(CSG)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2型文法，上下文无关文法-CFG"><span class="toc_mobile_items-number">2.4.3.</span> <span class="toc_mobile_items-text">2型文法，上下文无关文法(CFG)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3型文法，正规文法，正则文法-RG"><span class="toc_mobile_items-number">2.4.4.</span> <span class="toc_mobile_items-text">3型文法，正规文法，正则文法(RG)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#四种文法之间的关系"><span class="toc_mobile_items-number">2.4.5.</span> <span class="toc_mobile_items-text">四种文法之间的关系</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#上下文无关文法的分析树"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">上下文无关文法的分析树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CFG分析树定义"><span class="toc_mobile_items-number">2.5.1.</span> <span class="toc_mobile_items-text">CFG分析树定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分析树是推导的图形化表示"><span class="toc_mobile_items-number">2.5.2.</span> <span class="toc_mobile_items-text">分析树是推导的图形化表示</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#句型的短语"><span class="toc_mobile_items-number">2.5.3.</span> <span class="toc_mobile_items-text">句型的短语</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二义性文法"><span class="toc_mobile_items-number">2.5.4.</span> <span class="toc_mobile_items-text">二义性文法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二义性文法的判定"><span class="toc_mobile_items-number">2.5.5.</span> <span class="toc_mobile_items-text">二义性文法的判定</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#词法分析"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">词法分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#正则表达式（RE）"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">正则表达式（RE）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#正则表达式的定义"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">正则表达式的定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#正则表达式的代数定律"><span class="toc_mobile_items-number">3.1.2.</span> <span class="toc_mobile_items-text">正则表达式的代数定律</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#正则定义"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">正则定义</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#例1：C语言的标识符"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">例1：C语言的标识符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#例2：无符号数"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">例2：无符号数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#有穷自动机（FA）"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">有穷自动机（FA）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#FA-的典型例子"><span class="toc_mobile_items-number">3.3.1.</span> <span class="toc_mobile_items-text">FA 的典型例子</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#FA-模型"><span class="toc_mobile_items-number">3.3.2.</span> <span class="toc_mobile_items-text">FA 模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#状态图"><span class="toc_mobile_items-number">3.3.3.</span> <span class="toc_mobile_items-text">状态图</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#FA定义（接受）的语言"><span class="toc_mobile_items-number">3.3.4.</span> <span class="toc_mobile_items-text">FA定义（接受）的语言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#最长子串匹配原则"><span class="toc_mobile_items-number">3.3.5.</span> <span class="toc_mobile_items-text">最长子串匹配原则</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#有穷自动机的分类"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">有穷自动机的分类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#确定的有穷自动机-DFA"><span class="toc_mobile_items-number">3.4.1.</span> <span class="toc_mobile_items-text">确定的有穷自动机 (DFA)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#非确定的FA-NFA"><span class="toc_mobile_items-number">3.4.2.</span> <span class="toc_mobile_items-text">非确定的FA (NFA)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#DFA和NFA的等价性-重点考点"><span class="toc_mobile_items-number">3.4.3.</span> <span class="toc_mobile_items-text">DFA和NFA的等价性(重点考点)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#正则表达式和有穷自动机之间的转换"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">正则表达式和有穷自动机之间的转换</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#从RE到NFA"><span class="toc_mobile_items-number">3.5.1.</span> <span class="toc_mobile_items-text">从RE到NFA</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#从NFA到DFA的转换"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">从NFA到DFA的转换</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#举例"><span class="toc_mobile_items-number">3.6.1.</span> <span class="toc_mobile_items-text">举例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#子集构造法"><span class="toc_mobile_items-number">3.6.2.</span> <span class="toc_mobile_items-text">子集构造法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#计算-ε-closure-空闭包函数"><span class="toc_mobile_items-number">3.6.3.</span> <span class="toc_mobile_items-text">计算 ε-closure 空闭包函数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#识别单词的DFA"><span class="toc_mobile_items-number">3.7.</span> <span class="toc_mobile_items-text">识别单词的DFA</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#识别标识符的-DFA"><span class="toc_mobile_items-number">3.7.1.</span> <span class="toc_mobile_items-text">识别标识符的 DFA</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#识别无符号数的-DFA"><span class="toc_mobile_items-number">3.7.2.</span> <span class="toc_mobile_items-text">识别无符号数的 DFA</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#识别各进制无符号整数的-DFA"><span class="toc_mobile_items-number">3.7.3.</span> <span class="toc_mobile_items-text">识别各进制无符号整数的 DFA</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#识别注释的-DFA"><span class="toc_mobile_items-number">3.7.4.</span> <span class="toc_mobile_items-text">识别注释的 DFA</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#识别-token-的-DFA"><span class="toc_mobile_items-number">3.7.5.</span> <span class="toc_mobile_items-text">识别 token 的 DFA</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#词法分析阶段的错误处理"><span class="toc_mobile_items-number">3.8.</span> <span class="toc_mobile_items-text">词法分析阶段的错误处理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#词法分析阶段可检测错误的类型"><span class="toc_mobile_items-number">3.8.1.</span> <span class="toc_mobile_items-text">词法分析阶段可检测错误的类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#错误处理程序"><span class="toc_mobile_items-number">3.8.2.</span> <span class="toc_mobile_items-text">错误处理程序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#错误恢复策略"><span class="toc_mobile_items-number">3.8.3.</span> <span class="toc_mobile_items-text">错误恢复策略</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#语法分析"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">语法分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#自顶向下分析概述"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">自顶向下分析概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#最左推导和最右推导"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">最左推导和最右推导</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#自顶向下的语法分析采用最左推导方式"><span class="toc_mobile_items-number">4.1.2.</span> <span class="toc_mobile_items-text">自顶向下的语法分析采用最左推导方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#自顶向下语法分析的通用形式"><span class="toc_mobile_items-number">4.1.3.</span> <span class="toc_mobile_items-text">自顶向下语法分析的通用形式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#预测分析-Predictive-Parsing"><span class="toc_mobile_items-number">4.1.4.</span> <span class="toc_mobile_items-text">预测分析(Predictive Parsing)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文法转化"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">文法转化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#LL-1-文法"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">LL(1)文法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#语法制导翻译"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">语法制导翻译</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#语法制导翻译概述"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">语法制导翻译概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#语法制导定义-SDD"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">语法制导定义(SDD)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#综合属性和继承属性"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">综合属性和继承属性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SDD的求值顺序"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">SDD的求值顺序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#S-属性定义与L-属性定义"><span class="toc_mobile_items-number">5.2.3.</span> <span class="toc_mobile_items-text">S-属性定义与L-属性定义</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#语法制导翻译方案"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">语法制导翻译方案</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#S-SDD转换为SDT"><span class="toc_mobile_items-number">5.3.1.</span> <span class="toc_mobile_items-text">S-SDD转换为SDT</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#L-SDD转换为SDT"><span class="toc_mobile_items-number">5.3.2.</span> <span class="toc_mobile_items-text">L-SDD转换为SDT</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#在非递归的预测分析过程中进行语义翻译"><span class="toc_mobile_items-number">5.3.3.</span> <span class="toc_mobile_items-text">在非递归的预测分析过程中进行语义翻译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#在递归的预测分析过程中进行语义翻译"><span class="toc_mobile_items-number">5.3.4.</span> <span class="toc_mobile_items-text">在递归的预测分析过程中进行语义翻译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#在LR分析过程中进行语义翻译"><span class="toc_mobile_items-number">5.3.5.</span> <span class="toc_mobile_items-text">在LR分析过程中进行语义翻译</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#中间代码的生成"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">中间代码的生成</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#课件PPT-1"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">课件PPT</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#中间语言"><span class="toc_mobile_items-number">6.1.1.</span> <span class="toc_mobile_items-text">中间语言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#说明语句的翻译"><span class="toc_mobile_items-number">6.1.2.</span> <span class="toc_mobile_items-text">说明语句的翻译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#赋值语句的翻译"><span class="toc_mobile_items-number">6.1.3.</span> <span class="toc_mobile_items-text">赋值语句的翻译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#布尔表达式的翻译"><span class="toc_mobile_items-number">6.1.4.</span> <span class="toc_mobile_items-text">布尔表达式的翻译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#控制语句的翻译"><span class="toc_mobile_items-number">6.1.5.</span> <span class="toc_mobile_items-text">控制语句的翻译</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#过程调用的处理"><span class="toc_mobile_items-number">6.1.6.</span> <span class="toc_mobile_items-text">过程调用的处理</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#控制流语句及STD"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">控制流语句及STD</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#课堂笔记"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">课堂笔记</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#11-07"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">11.07</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#11-28"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">11.28</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#12-05"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">12.05</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#控制语句的翻译-1"><span class="toc_mobile_items-number">7.3.1.</span> <span class="toc_mobile_items-text">控制语句的翻译</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#12-12"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">12.12</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#12-19"><span class="toc_mobile_items-number">7.5.</span> <span class="toc_mobile_items-text">12.19</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#局部优化"><span class="toc_mobile_items-number">7.5.1.</span> <span class="toc_mobile_items-text">局部优化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#目标代码生成——最后一章"><span class="toc_mobile_items-number">7.5.2.</span> <span class="toc_mobile_items-text">目标代码生成——最后一章</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#代码生成算法"><span class="toc_mobile_items-number">7.5.2.1.</span> <span class="toc_mobile_items-text">代码生成算法</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#作业习题"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">作业习题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#考试"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">考试</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#null"><span class="toc_mobile_items-number">9.0.1.</span> <span class="toc_mobile_items-text"></span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#绪论"><span class="toc-number">1.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#课件PPT"><span class="toc-number">1.1.</span> <span class="toc-text">课件PPT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是编译"><span class="toc-number">1.2.</span> <span class="toc-text">什么是编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译系统的结构"><span class="toc-number">1.3.</span> <span class="toc-text">编译系统的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#词法分析概述"><span class="toc-number">1.4.</span> <span class="toc-text">词法分析概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语法分析概述"><span class="toc-number">1.5.</span> <span class="toc-text">语法分析概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语义分析概述"><span class="toc-number">1.6.</span> <span class="toc-text">语义分析概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中间代码生成及编译器后端概述"><span class="toc-number">1.7.</span> <span class="toc-text">中间代码生成及编译器后端概述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#语言及其文法"><span class="toc-number">2.</span> <span class="toc-text">语言及其文法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-number">2.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字母表"><span class="toc-number">2.1.1.</span> <span class="toc-text">字母表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字母表上的运算"><span class="toc-number">2.1.2.</span> <span class="toc-text">字母表上的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符号串"><span class="toc-number">2.1.3.</span> <span class="toc-text">符号串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#串上的运算"><span class="toc-number">2.1.4.</span> <span class="toc-text">串上的运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文法的定义"><span class="toc-number">2.2.</span> <span class="toc-text">文法的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文法的形式化定义"><span class="toc-number">2.2.1.</span> <span class="toc-text">文法的形式化定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#产生式的简写"><span class="toc-number">2.2.2.</span> <span class="toc-text">产生式的简写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符号的约定"><span class="toc-number">2.2.3.</span> <span class="toc-text">符号的约定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语言的定义"><span class="toc-number">2.3.</span> <span class="toc-text">语言的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#推导与规约"><span class="toc-number">2.3.1.</span> <span class="toc-text">推导与规约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#句型和句子"><span class="toc-number">2.3.2.</span> <span class="toc-text">句型和句子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语言的形式化定义"><span class="toc-number">2.3.3.</span> <span class="toc-text">语言的形式化定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语言上的运算"><span class="toc-number">2.3.4.</span> <span class="toc-text">语言上的运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文法的分类"><span class="toc-number">2.4.</span> <span class="toc-text">文法的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0型文法，无限制文法，短语结构文法"><span class="toc-number">2.4.1.</span> <span class="toc-text">0型文法，无限制文法，短语结构文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1型文法，上下文有关文法-CSG"><span class="toc-number">2.4.2.</span> <span class="toc-text">1型文法，上下文有关文法(CSG)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2型文法，上下文无关文法-CFG"><span class="toc-number">2.4.3.</span> <span class="toc-text">2型文法，上下文无关文法(CFG)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3型文法，正规文法，正则文法-RG"><span class="toc-number">2.4.4.</span> <span class="toc-text">3型文法，正规文法，正则文法(RG)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四种文法之间的关系"><span class="toc-number">2.4.5.</span> <span class="toc-text">四种文法之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#上下文无关文法的分析树"><span class="toc-number">2.5.</span> <span class="toc-text">上下文无关文法的分析树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CFG分析树定义"><span class="toc-number">2.5.1.</span> <span class="toc-text">CFG分析树定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析树是推导的图形化表示"><span class="toc-number">2.5.2.</span> <span class="toc-text">分析树是推导的图形化表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#句型的短语"><span class="toc-number">2.5.3.</span> <span class="toc-text">句型的短语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二义性文法"><span class="toc-number">2.5.4.</span> <span class="toc-text">二义性文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二义性文法的判定"><span class="toc-number">2.5.5.</span> <span class="toc-text">二义性文法的判定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#词法分析"><span class="toc-number">3.</span> <span class="toc-text">词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式（RE）"><span class="toc-number">3.1.</span> <span class="toc-text">正则表达式（RE）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式的定义"><span class="toc-number">3.1.1.</span> <span class="toc-text">正则表达式的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式的代数定律"><span class="toc-number">3.1.2.</span> <span class="toc-text">正则表达式的代数定律</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则定义"><span class="toc-number">3.2.</span> <span class="toc-text">正则定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1：C语言的标识符"><span class="toc-number">3.2.1.</span> <span class="toc-text">例1：C语言的标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2：无符号数"><span class="toc-number">3.2.2.</span> <span class="toc-text">例2：无符号数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有穷自动机（FA）"><span class="toc-number">3.3.</span> <span class="toc-text">有穷自动机（FA）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FA-的典型例子"><span class="toc-number">3.3.1.</span> <span class="toc-text">FA 的典型例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FA-模型"><span class="toc-number">3.3.2.</span> <span class="toc-text">FA 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态图"><span class="toc-number">3.3.3.</span> <span class="toc-text">状态图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FA定义（接受）的语言"><span class="toc-number">3.3.4.</span> <span class="toc-text">FA定义（接受）的语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长子串匹配原则"><span class="toc-number">3.3.5.</span> <span class="toc-text">最长子串匹配原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有穷自动机的分类"><span class="toc-number">3.4.</span> <span class="toc-text">有穷自动机的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#确定的有穷自动机-DFA"><span class="toc-number">3.4.1.</span> <span class="toc-text">确定的有穷自动机 (DFA)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非确定的FA-NFA"><span class="toc-number">3.4.2.</span> <span class="toc-text">非确定的FA (NFA)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFA和NFA的等价性-重点考点"><span class="toc-number">3.4.3.</span> <span class="toc-text">DFA和NFA的等价性(重点考点)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式和有穷自动机之间的转换"><span class="toc-number">3.5.</span> <span class="toc-text">正则表达式和有穷自动机之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从RE到NFA"><span class="toc-number">3.5.1.</span> <span class="toc-text">从RE到NFA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从NFA到DFA的转换"><span class="toc-number">3.6.</span> <span class="toc-text">从NFA到DFA的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例"><span class="toc-number">3.6.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子集构造法"><span class="toc-number">3.6.2.</span> <span class="toc-text">子集构造法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算-ε-closure-空闭包函数"><span class="toc-number">3.6.3.</span> <span class="toc-text">计算 ε-closure 空闭包函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#识别单词的DFA"><span class="toc-number">3.7.</span> <span class="toc-text">识别单词的DFA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#识别标识符的-DFA"><span class="toc-number">3.7.1.</span> <span class="toc-text">识别标识符的 DFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#识别无符号数的-DFA"><span class="toc-number">3.7.2.</span> <span class="toc-text">识别无符号数的 DFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#识别各进制无符号整数的-DFA"><span class="toc-number">3.7.3.</span> <span class="toc-text">识别各进制无符号整数的 DFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#识别注释的-DFA"><span class="toc-number">3.7.4.</span> <span class="toc-text">识别注释的 DFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#识别-token-的-DFA"><span class="toc-number">3.7.5.</span> <span class="toc-text">识别 token 的 DFA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#词法分析阶段的错误处理"><span class="toc-number">3.8.</span> <span class="toc-text">词法分析阶段的错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#词法分析阶段可检测错误的类型"><span class="toc-number">3.8.1.</span> <span class="toc-text">词法分析阶段可检测错误的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理程序"><span class="toc-number">3.8.2.</span> <span class="toc-text">错误处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误恢复策略"><span class="toc-number">3.8.3.</span> <span class="toc-text">错误恢复策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#语法分析"><span class="toc-number">4.</span> <span class="toc-text">语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#自顶向下分析概述"><span class="toc-number">4.1.</span> <span class="toc-text">自顶向下分析概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最左推导和最右推导"><span class="toc-number">4.1.1.</span> <span class="toc-text">最左推导和最右推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自顶向下的语法分析采用最左推导方式"><span class="toc-number">4.1.2.</span> <span class="toc-text">自顶向下的语法分析采用最左推导方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自顶向下语法分析的通用形式"><span class="toc-number">4.1.3.</span> <span class="toc-text">自顶向下语法分析的通用形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预测分析-Predictive-Parsing"><span class="toc-number">4.1.4.</span> <span class="toc-text">预测分析(Predictive Parsing)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文法转化"><span class="toc-number">4.2.</span> <span class="toc-text">文法转化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LL-1-文法"><span class="toc-number">4.3.</span> <span class="toc-text">LL(1)文法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#语法制导翻译"><span class="toc-number">5.</span> <span class="toc-text">语法制导翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#语法制导翻译概述"><span class="toc-number">5.1.</span> <span class="toc-text">语法制导翻译概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语法制导定义-SDD"><span class="toc-number">5.2.</span> <span class="toc-text">语法制导定义(SDD)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#综合属性和继承属性"><span class="toc-number">5.2.1.</span> <span class="toc-text">综合属性和继承属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDD的求值顺序"><span class="toc-number">5.2.2.</span> <span class="toc-text">SDD的求值顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#S-属性定义与L-属性定义"><span class="toc-number">5.2.3.</span> <span class="toc-text">S-属性定义与L-属性定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语法制导翻译方案"><span class="toc-number">5.3.</span> <span class="toc-text">语法制导翻译方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#S-SDD转换为SDT"><span class="toc-number">5.3.1.</span> <span class="toc-text">S-SDD转换为SDT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-SDD转换为SDT"><span class="toc-number">5.3.2.</span> <span class="toc-text">L-SDD转换为SDT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在非递归的预测分析过程中进行语义翻译"><span class="toc-number">5.3.3.</span> <span class="toc-text">在非递归的预测分析过程中进行语义翻译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在递归的预测分析过程中进行语义翻译"><span class="toc-number">5.3.4.</span> <span class="toc-text">在递归的预测分析过程中进行语义翻译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在LR分析过程中进行语义翻译"><span class="toc-number">5.3.5.</span> <span class="toc-text">在LR分析过程中进行语义翻译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#中间代码的生成"><span class="toc-number">6.</span> <span class="toc-text">中间代码的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#课件PPT-1"><span class="toc-number">6.1.</span> <span class="toc-text">课件PPT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#中间语言"><span class="toc-number">6.1.1.</span> <span class="toc-text">中间语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明语句的翻译"><span class="toc-number">6.1.2.</span> <span class="toc-text">说明语句的翻译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值语句的翻译"><span class="toc-number">6.1.3.</span> <span class="toc-text">赋值语句的翻译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#布尔表达式的翻译"><span class="toc-number">6.1.4.</span> <span class="toc-text">布尔表达式的翻译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制语句的翻译"><span class="toc-number">6.1.5.</span> <span class="toc-text">控制语句的翻译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过程调用的处理"><span class="toc-number">6.1.6.</span> <span class="toc-text">过程调用的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制流语句及STD"><span class="toc-number">6.2.</span> <span class="toc-text">控制流语句及STD</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#课堂笔记"><span class="toc-number">7.</span> <span class="toc-text">课堂笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-07"><span class="toc-number">7.1.</span> <span class="toc-text">11.07</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-28"><span class="toc-number">7.2.</span> <span class="toc-text">11.28</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-05"><span class="toc-number">7.3.</span> <span class="toc-text">12.05</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#控制语句的翻译-1"><span class="toc-number">7.3.1.</span> <span class="toc-text">控制语句的翻译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-12"><span class="toc-number">7.4.</span> <span class="toc-text">12.12</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-19"><span class="toc-number">7.5.</span> <span class="toc-text">12.19</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#局部优化"><span class="toc-number">7.5.1.</span> <span class="toc-text">局部优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目标代码生成——最后一章"><span class="toc-number">7.5.2.</span> <span class="toc-text">目标代码生成——最后一章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码生成算法"><span class="toc-number">7.5.2.1.</span> <span class="toc-text">代码生成算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#作业习题"><span class="toc-number">8.</span> <span class="toc-text">作业习题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#考试"><span class="toc-number">9.</span> <span class="toc-text">考试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">9.0.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/ox/wallhaven-oxj7mm.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">编译原理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-27<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-31</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">12k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 37 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><blockquote>
<p>复习要求：翻看笔记+高珍老师PPT，然后挑重点理解，要记得刷题</p>
</blockquote>
<ul>
<li><input disabled type="checkbox"> 绪论</li>
<li><input disabled type="checkbox"> 高级语言及其文法</li>
<li><input disabled type="checkbox"> 词法分析</li>
<li><input disabled type="checkbox"> 语法分析</li>
<li><input disabled type="checkbox"> 语法制导翻译</li>
<li><input disabled type="checkbox"> 中间代码生成</li>
<li><input disabled type="checkbox"> 优化</li>
</ul>
<blockquote>
<p>视频：</p>
</blockquote>
<ul>
<li><input disabled type="checkbox"> 绪论 1-6</li>
<li><input disabled type="checkbox"> 语言及其文法 2.5完整看完</li>
<li><input checked disabled type="checkbox"> 你</li>
<li><input disabled type="checkbox"> chapter 9</li>
<li><input disabled type="checkbox"> </li>
<li><input disabled type="checkbox"> </li>
</ul>
<p>考点用<code>重点考点</code>进行标识</p>
<p>需要补充的地方<code>[?]</code></p>
<p>参考网址：<a href="https://blog.csdn.net/qq_33414271/category_9292415.html" target="_blank" rel="noopener">编译原理MOOC笔记</a></p>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="课件PPT"><a href="#课件PPT" class="headerlink" title="课件PPT"></a>课件PPT</h2><p><img alt="image-20191212212425319" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u9az56ptj30ve0c60uj.jpg" class="lazyload"></p>
<h2 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h2><p>计算机程序语言可以自顶向下可以分为高级语言、汇编语言和机器语言三种，其中开发程序员最长接触的为高级语言，如JAVA，高级语言经过编译就会生成汇编语言或机器语言，具体关系如下图：</p>
<p><img alt="image-20191127165753230" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpaz1yxvj312i0n84a1.jpg" class="lazyload"></p>
<p>编译的过程就是将<code>高级语言</code>翻译成<code>汇编语言或机器语言</code>的过程 ，即将<code>源语言</code>转化为<code>目标语言</code>的过程。</p>
<p>编译器在语言处理系统中的位置如下图所示：</p>
<p><img alt="image-20191127165935095" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpcqqihfj310o0oan77.jpg" class="lazyload"></p>
<ul>
<li><p>可重定位(Relocatable)： 在内存中存放的起始位置L不是固定的</p>
</li>
<li><p>加载器：修改可重定位地址；将修改后的指令和数据放到内存中适当的位置</p>
<center>起始位置+相对地址=绝对地址</center>
</li>
<li><p><code>链接器</code>的作用：</p>
<ol>
<li>将多个可重定位的机器代码文件（包括库文件）</li>
<li>连接到一起解决外部内存地址问题</li>
</ol>
</li>
</ul>
<h2 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h2><p>在有了高级语言程序之后（如一段C语言代码），编译器应该怎么翻译成汇编语言程序或机器语言程序呢？</p>
<p>我们先来看一下人工英汉怎么进行翻译的，编译器所做的工作有类似之处。</p>
<p><img alt="image-20191127170344850" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cph2jthrj311m0k07e8.jpg" class="lazyload"></p>
<p>首先我们分析源语言，即英文，先拆分名词、动词等，然后组成短语，最终才能组合成句。即一段语言的分析理解包括了<code>3个基本的小部分</code>,最终才能连接成为一个完整的句子</p>
<ol>
<li>词法分析（Lexical Analysis）</li>
<li>语法分析（Syntax Analysis）</li>
<li>语义分析（Semantic Analysis）</li>
</ol>
<p>那么一个完整的编译器结构如下图所示：</p>
<p><img alt="image-20191127170550711" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpj9ct2bj30so0tu7d2.jpg" class="lazyload"></p>
<h2 id="词法分析概述"><a href="#词法分析概述" class="headerlink" title="词法分析概述"></a>词法分析概述</h2><p>词法分析顾名思义就是通过扫描源程序，识别出每一个单词，确定单词类型，然后转化为统一的机内表示——<code>词法单元（token）</code>形式。</p>
<p>token：&lt; 种别码，属性值&gt;</p>
<p>例如if、else对应唯一的表示形式。具体的表示形式如下表所示：</p>
<p><img alt="image-20191127170722792" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cpkudcwfj30yc0dkte0.jpg" class="lazyload"></p>
<p>例如有一句代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(value!=<span class="number">100</span>)&#123;num++;&#125;</span><br></pre></td></tr></table></figure>

<p>则经过词法分析后如下所示，其中每句后的&lt;-,-&gt;表示每个单词的含义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>      &lt; WHILE ,    -  &gt;  <span class="comment">// 关键词，一词一码</span></span><br><span class="line">(          &lt;SLP    ,    -  &gt;  <span class="comment">// 界限符，一词一码</span></span><br><span class="line">value      &lt;IDN    ,  value&gt;  <span class="comment">// 标识符，多词一码，&lt; 种别码，属性值value&gt;</span></span><br><span class="line">!=         &lt;NE     ,    -  &gt;  <span class="comment">// 运算符，一词一码</span></span><br><span class="line"><span class="number">100</span>        &lt;CONST,<span class="number">100</span>&gt; 				<span class="comment">// 常 量，一型一码</span></span><br><span class="line">)          &lt;SRP,-&gt;            <span class="comment">// 界限符，一词一码</span></span><br><span class="line">&#123;          &lt;LP,-&gt;             <span class="comment">// 界限符，一词一码</span></span><br><span class="line">num        &lt;IDN,num&gt;          <span class="comment">// 标识符，多词一码，&lt; 种别码，属性值value&gt;</span></span><br><span class="line">++         &lt;INC,-&gt;            <span class="comment">// 运算符，一词一码</span></span><br><span class="line">;          &lt;SEMI,-&gt;           <span class="comment">// 界限符，一词一码</span></span><br><span class="line">&#125;          &lt;RP,-&gt;             <span class="comment">// 界限符，一词一码</span></span><br></pre></td></tr></table></figure>

<h2 id="语法分析概述"><a href="#语法分析概述" class="headerlink" title="语法分析概述"></a>语法分析概述</h2><p>语法分析器(parser)从词法分析器输出的token序列中识别出各类短语，并构造<code>语法分析树(parsetree)</code>。简而言之就是将词法分析后识别出来的单词构成短语，将短语整合成一个完整的句子。</p>
<p>语法分析树描述了句子的语法结构。如下是<code>赋值语句</code>的语法分析树：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">position</span>      =      initial      +    rate      *    <span class="number">60</span>     ;  </span><br><span class="line">&lt;id，<span class="built_in">position</span>&gt;  &lt;=&gt;   &lt;id,initial&gt;  &lt;+&gt; &lt;id, rate&gt; &lt;*&gt; &lt;num,<span class="number">60</span>&gt; &lt;;&gt;</span><br></pre></td></tr></table></figure>

<p><img alt="image-20191127180738395" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9crbjmk6gj312o0dytcs.jpg" class="lazyload"></p>
<p>例如我们需要得到<code>变量声明的分析树</code>，变量声明可以是int a；也可以是int a,b,c；抽象成文法（变量声明的规则）和分析树为：</p>
<p><img alt="image-20191127181449598" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9crj1i7inj31460fg78x.jpg" class="lazyload"></p>
<h2 id="语义分析概述"><a href="#语义分析概述" class="headerlink" title="语义分析概述"></a>语义分析概述</h2><p>语义分析的主要任务是<code>收集标识符的属性信息</code>，其中包括种属（简单变量、复合变量···）、类型（整型、实型···）、存储位置、长度等；除此之外语义分析还要进行<code>语义检查</code>，其中包括变量是否是没有声明就使用了。</p>
<h2 id="中间代码生成及编译器后端概述"><a href="#中间代码生成及编译器后端概述" class="headerlink" title="中间代码生成及编译器后端概述"></a>中间代码生成及编译器后端概述</h2><p>常见的中间表示形式为：</p>
<ul>
<li><p><code>三地址码(Three-address Code)</code>：三地址码由类似于汇编语言的指令序列组成， 每个指令最多有三个操作数(operand)。</p>
</li>
<li><p><code>语法结构树/语法树(Syntax Trees)</code></p>
</li>
</ul>
<p>常见的为三地址形式，其中表示方法为<code>四元式(Quadruples)</code>：(op, y, z, x)。</p>
<p><img alt="image-20191127182026339" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9crouz1dzj310s0p8wn7.jpg" class="lazyload"></p>
<p>中间代码生成的案例为：</p>
<blockquote>
<p>[!!!重点题]先画出语法分析树，然后再进行分析</p>
</blockquote>
<p><img alt="image-20191127182553003" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cruj4rhyj313o0hcwn5.jpg" class="lazyload"></p>
<h1 id="语言及其文法"><a href="#语言及其文法" class="headerlink" title="语言及其文法"></a>语言及其文法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>正如英语是由句子组成的集合，而句子又是由单词和标点符号组成的序列那样。程序设计语言 C 语言，是由 C 程序所组成的集合，而程序是由类似 if , begin, end 的符号，字母和数字这样一些基本符号所组成。</p>
<p>从字面上看，每个程序都是一个“基本符号”串，设有一基本符号串，那么 C 语言可看成是在这个基本符号集上定义的，按一定规则构成的一切基本符号串组成的集合。</p>
<h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表$$\sum$$是一个<strong>有穷</strong>的符号集合，其中符号包括<strong>字母、数字和标点符号</strong>等</p>
<p>如:</p>
<ul>
<li><p>二进制字母表：{ 0,1 } ；</p>
</li>
<li><p>ASCII字符集 ；</p>
</li>
<li><p>Unicode字符。</p>
</li>
</ul>
<h3 id="字母表上的运算"><a href="#字母表上的运算" class="headerlink" title="字母表上的运算"></a>字母表上的运算</h3><blockquote>
<p> 字母表 $\sum_1$ 和 $\sum_2$ 的<code>乘积</code>( product)</p>
</blockquote>
<p><img alt="image-20191127203325412" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvj89hi8j30rs07gabz.jpg" class="lazyload"></p>
<blockquote>
<p>字母表 $\sum$ 的<code>n次幂</code>( power)：长度为n的符号串构成的集合</p>
</blockquote>
<p><img alt="image-20191127203359267" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvjtdnjzj30u80a6go6.jpg" class="lazyload"></p>
<blockquote>
<p> 字母表 $\sum$ 的<code>正闭包</code>( positive closure)：长度为正数的符号串构成的集合</p>
</blockquote>
<p><img alt="image-20191127203508021" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvl0gye3j30wu09iad6.jpg" class="lazyload"></p>
<blockquote>
<p>字母表 $\sum$ 的克林闭包(Kleene closure)：任意符号串(<code>跟正闭包相比长度可以为零</code>）构成的集合</p>
</blockquote>
<p><img alt="image-20191127203705801" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvn26xlzj30ym08itbn.jpg" class="lazyload"></p>
<h3 id="符号串"><a href="#符号串" class="headerlink" title="符号串"></a>符号串</h3><p><strong>由字母表中的符号组成的任何有穷序列称为符号串。</strong></p>
<p><strong>串 s 的长度</strong>，通常记作 |s| ，是指 s 中符号的个数。例：|aab|=3。</p>
<p><strong>空串是长度为 0 的串</strong>，用 ε 表示，|ε|=0。</p>
<h3 id="串上的运算"><a href="#串上的运算" class="headerlink" title="串上的运算"></a>串上的运算</h3><blockquote>
<p>串的连接</p>
</blockquote>
<p>如果 x 和 y 是串，那么 x 和 y 的连接，是把 y 附加到 x 后面而形成的串，记作 xy。</p>
<p>例如，如果 x=dog 且 y=house，那么 xy=doghouse。</p>
<p>空串是连接运算的单位元，即，对于任何串 s 都有， εs=sε=s。</p>
<blockquote>
<p>串的幂运算：将 n 个 串连接起来。</p>
</blockquote>
<p><img alt="image-20191127204538740" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cvvyj03cj30xs0buwh1.jpg" class="lazyload"></p>
<h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><p>自然语言中句子的构成规则为：句子由名词短语构和动词短语成，名词短语由形容词和名词短语构成···，直到最终特定的名词、动词、形容词等。</p>
<p><strong>分析一个自然语言的例子，得出句子的构成规则。</strong></p>
<p><img alt="image-20191127201802385" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9cv3an5odj314g0k8qcd.jpg" class="lazyload"></p>
<h3 id="文法的形式化定义"><a href="#文法的形式化定义" class="headerlink" title="文法的形式化定义"></a>文法的形式化定义</h3><p>$$<br>G = (V_T , V_N , P , S )<br>$$</p>
<ul>
<li><p>G：表示文法，文法由一个四元组定义</p>
</li>
<li><p><strong>终结符集合和非终结符集合都是字母表</strong></p>
</li>
<li><p><strong>终结符集合与非终结符集合是不相交的</strong> -&gt; $V_T∩V_N=Φ$ </p>
</li>
<li><p><strong>终结符集合与非终结符集合的并集是文法符号集</strong> -&gt; $V_T∪V_N$：文法符号集</p>
</li>
<li><p>$V_T$：</p>
<p><img alt="image-20191127210706311" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwiac7sij30y807amzp.jpg" class="lazyload"></p>
</li>
<li><p>$V_N$：<strong>因为从它们可以推出其他的语法成分，所以被称为非终结符</strong></p>
<p><img alt="image-20191127210747647" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwjbrw6nj30wi08kmzw.jpg" class="lazyload"></p>
</li>
<li><p>P：产生式集合，注意左部和右部的取值，左部是正闭包，右部是克林闭包</p>
<p>例： P = &lt;句子&gt; → &lt;名词短语&gt;&lt;动词短语&gt;, &lt;名词短语&gt; → &lt;形容词&gt;&lt;名词短语&gt;</p>
<p><img alt="image-20191127211430931" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwq1999lj30x60aqwie.jpg" class="lazyload"></p>
</li>
<li><p>S：开始符号</p>
<p>$S∈V_N$，开始符号(start symbol)表示的是该文法中最大的语法成分。例：S = &lt;句子&gt;</p>
<p><img alt="image-20191127212009896" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwvvddqrj30yg050gn9.jpg" class="lazyload"></p>
<p>例：<img alt="image-20191127212046791" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cwwi6n07j30y408kgok.jpg" class="lazyload"></p>
</li>
</ul>
<h3 id="产生式的简写"><a href="#产生式的简写" class="headerlink" title="产生式的简写"></a>产生式的简写</h3><p><img alt="image-20191127212509659" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx138jbzj30ys0gsq7a.jpg" class="lazyload"></p>
<h3 id="符号的约定"><a href="#符号的约定" class="headerlink" title="符号的约定"></a>符号的约定</h3><ul>
<li><p>终结符</p>
<p><img alt="image-20191127213016136" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx6fd6qwj30xg0cuwkb.jpg" class="lazyload"></p>
</li>
<li><p>非终结符</p>
</li>
</ul>
<p><img alt="image-20191127213110142" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cx7ceu2nj30yw0ck0zh.jpg" class="lazyload"></p>
<ul>
<li><p>其他</p>
<p><img alt="image-20191127213523082" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxbpc4g8j30ny0aqdqa.jpg" class="lazyload"></p>
</li>
</ul>
<h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><h3 id="推导与规约"><a href="#推导与规约" class="headerlink" title="推导与规约"></a>推导与规约</h3><p>假设自然语言的<strong>文法</strong>可以表示为</p>
<p><img alt="image-20191127213748634" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxe85up2j30sg0jijz9.jpg" class="lazyload"></p>
<p><strong>单词串</strong>：little boy eats apple</p>
<p>有了文法（语言规则），如何判定一个单词串是否是满足文法的句子？</p>
<p>答案是：<strong>推导和规约</strong>。</p>
<p>$ a_0$ 经过 n 步推导出$ a_n$ ，可简记为：$ a_0 -&gt; a_n$ </p>
<p><img alt="image-20191127215130972" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxsi5orij316209udl7.jpg" class="lazyload"></p>
<p><img alt="image-20191127215144948" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxspwvmpj31600ce42p.jpg" class="lazyload"></p>
<p>例：</p>
<p>由上而下为推导，即具体化的过程——-从生成语言的角度</p>
<p>由下而上为规约，即抽象化的过程——从识别语言的角度</p>
<p><img alt="image-20191127214236911" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxj8iz9dj315i0k444b.jpg" class="lazyload"></p>
<h3 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h3><blockquote>
<p>句型：</p>
</blockquote>
<p><img alt="image-20191127214426061" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxl48vy4j315y07owhd.jpg" class="lazyload"></p>
<blockquote>
<p>句子：<strong>句子是不包含非终结符的句型</strong></p>
</blockquote>
<p><img alt="image-20191127214450796" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxljms1mj316a024q3r.jpg" class="lazyload"></p>
<p>例：</p>
<p><img alt="image-20191127214531118" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxm92s64j31600fm0yl.jpg" class="lazyload"></p>
<h3 id="语言的形式化定义"><a href="#语言的形式化定义" class="headerlink" title="语言的形式化定义"></a>语言的形式化定义</h3><p>由文法 G 的开始符号 S 推导出的所有<code>句子</code>构成的集合称为<code>文法G生成的语言</code>，记作 L(G)，即：`</p>
<p><img alt="image-20191127215520196" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxwg8l4aj315g0203ym.jpg" class="lazyload"></p>
<blockquote>
<p>例1：</p>
</blockquote>
<p>$E-&gt;E+E | E * E | (E) | id$ 生成的语言中包含多少个<code>句子</code></p>
<p>答案是无数个，文法解决了无穷语言的有穷表示问题</p>
<blockquote>
<p>例2：</p>
</blockquote>
<p>我们现在拥有的文法 G 如下所示，其生成的语言标识符，即以字母开头的字符串。因为S定义为一个字母或以字母开头的字母数字串，即用于表示标识符。</p>
<p><img alt="image-20191127215638460" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cxxthzt9j31640fo42p.jpg" class="lazyload"></p>
<h3 id="语言上的运算"><a href="#语言上的运算" class="headerlink" title="语言上的运算"></a>语言上的运算</h3><p><img alt="image-20191127220637268" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cy87ik0hj315w0fogrn.jpg" class="lazyload"></p>
<h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><h3 id="0型文法，无限制文法，短语结构文法"><a href="#0型文法，无限制文法，短语结构文法" class="headerlink" title="0型文法，无限制文法，短语结构文法"></a>0型文法，无限制文法，短语结构文法</h3><ul>
<li>α中至少包含1个非终结符</li>
</ul>
<p><img alt="image-20191127221027086" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyc6uglwj31600fe78m.jpg" class="lazyload"></p>
<h3 id="1型文法，上下文有关文法-CSG"><a href="#1型文法，上下文有关文法-CSG" class="headerlink" title="1型文法，上下文有关文法(CSG)"></a>1型文法，上下文有关文法(CSG)</h3><ul>
<li><p>产生式左部符号的个数不能多于右部</p>
</li>
<li><p>CSG不包含 $\varepsilon$ 产生式，即产生式<strong>右部是空串的产生式</strong>，因为左部至少包含一个非终结符，左部长度至少为1，如果右部是 $\varepsilon$ ，右部长度为1，与CGS定义不符合。</p>
</li>
</ul>
<p><img alt="image-20191127221328301" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyfbx748j315y0i2afd.jpg" class="lazyload"></p>
<h3 id="2型文法，上下文无关文法-CFG"><a href="#2型文法，上下文无关文法-CFG" class="headerlink" title="2型文法，上下文无关文法(CFG)"></a>2型文法，上下文无关文法(CFG)</h3><ul>
<li>左边是一个非终结符，将其替换不需要考虑其上下文</li>
<li>所举的例子即2型文法</li>
</ul>
<p><img alt="image-20191127221344869" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyfm18zwj315w0ig786.jpg" class="lazyload"></p>
<h3 id="3型文法，正规文法，正则文法-RG"><a href="#3型文法，正规文法，正则文法-RG" class="headerlink" title="3型文法，正规文法，正则文法(RG)"></a>3型文法，正规文法，正则文法(RG)</h3><ul>
<li>3型文法分为2种文法</li>
<li>产生式右部最多只有一个非终结符，且只能在一侧</li>
<li>例子中的两个文法都是指标识符，即一个字母或以字母开头的字母数字串</li>
<li>程序语言中的多数单词都能用正则文法表示</li>
</ul>
<p><img alt="image-20191127222052426" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyn3744ej315u0ian4k.jpg" class="lazyload"></p>
<h3 id="四种文法之间的关系"><a href="#四种文法之间的关系" class="headerlink" title="四种文法之间的关系"></a>四种文法之间的关系</h3><p><img alt="image-20191127222635614" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyszv3q5j31620fi43y.jpg" class="lazyload"></p>
<h2 id="上下文无关文法的分析树"><a href="#上下文无关文法的分析树" class="headerlink" title="上下文无关文法的分析树"></a>上下文无关文法的分析树</h2><p>程序语言中的多数单词都能用正则文法表示，但正则文法生成能力有限，句子构造则需要用上下文无关文法进行描述。</p>
<h3 id="CFG分析树定义"><a href="#CFG分析树定义" class="headerlink" title="CFG分析树定义"></a>CFG分析树定义</h3><p>例：图中跟节点表示的是对第三个式子的应用</p>
<p><img alt="image-20191127222833264" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cyv3e5bpj315y0hwq9o.jpg" class="lazyload"></p>
<h3 id="分析树是推导的图形化表示"><a href="#分析树是推导的图形化表示" class="headerlink" title="分析树是推导的图形化表示"></a>分析树是推导的图形化表示</h3><p>推导过程中产生许多<code>句型</code>,最终推导出分析树的边缘</p>
<p><img alt="image-20191127223759244" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cz4u6zi1j315q0fktds.jpg" class="lazyload"> </p>
<h3 id="句型的短语"><a href="#句型的短语" class="headerlink" title="句型的短语"></a>句型的短语</h3><p>给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个<code>短语</code>。</p>
<p>如果子树只有父子两代节点，那么这课子树的边缘称为该句型的一个<code>直接短语</code>。</p>
<p><strong>直接短语一定是产生式的右部，但产生式的右部不一定是给定句型的直接短语，但可能是其他句型的直接短语</strong></p>
<p><img alt="image-20191127224229562" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cz9jcs2rj316609077h.jpg" class="lazyload"></p>
<p>例：人民、生活、水平是该句子的直接短语，而高人、民生、活水虽然也是第5个产生式的右部，但是在这棵分析树中，它们不是直接短语。</p>
<p><img alt="image-20191127225119891" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cziqh449j30o40bigub.jpg" class="lazyload"></p>
<h3 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h3><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。</p>
<p>下面这个例子产生二义的原因是else可以跟第一个if条件语句和第二个if条件语句相配。</p>
<p><code>消歧规则</code>：每个else和最近的尚未匹配的if进行匹配，所以只有第一个分析树</p>
<p><img alt="image-20191127225609332" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cznqxtqrj315y0fcadz.jpg" class="lazyload"></p>
<h3 id="二义性文法的判定"><a href="#二义性文法的判定" class="headerlink" title="二义性文法的判定"></a>二义性文法的判定</h3><p>对于任意一个上下文无关文法，不存在一个算法，判断它是无二义性的，但能给出一组充分条件，满足这组充分条件的文法是无二义性的。</p>
<ul>
<li>满足，肯定无二义性</li>
<li>不满足，也未必就是有二义性的</li>
</ul>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>词法分析这一章从正则表达式到有穷自动机，讲述了如何利用<strong>确定性的有穷自动机</strong>来进行单词的识别。其中正则表达式和有穷自动机之间也有相应的<strong>转化</strong>关系。</p>
<p>本文内容：介绍正则定义，正则表达式，有穷自动机（确定的有穷自动机 DFA，不确定的有穷自动机 NFA），NFA 转换为等价的 DFA，DFA 的化简，识别单词的 DFA ，典型例题及详细解答。</p>
<p>在前面我们说过，程序设计语言中的大多数单词都可以用<strong>正则文法</strong>来描述，在这一章中我们将介绍描述<strong>正则语言的更紧凑的方法——正则表达式</strong>。</p>
<h2 id="正则表达式（RE）"><a href="#正则表达式（RE）" class="headerlink" title="正则表达式（RE）"></a>正则表达式（RE）</h2><p>语言是一个集合，因此我们可以在语言上进行多种集合运算。比如说并运算，乘积运算（即连接运算），闭包运算等等。</p>
<blockquote>
<p>正则表达式示例</p>
</blockquote>
<p>接下来我们看一个语言的例子，如下图所示：</p>
<p><img alt="image-20191127234530543" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d138lzjdj30na0bmdnz.jpg" class="lazyload"></p>
<p>这个语言的字首是字母 a，接下来连接一个任意长度的 a,b 串，再接下来连接一个空串。连接一个空串就代表句子已经结束了。除此之外，我们还可以连接一个点号（.）或者下划线（_）或者一个长度大于等于1 的 a,b串。</p>
<p>这个式子写起来比较复杂，因此我们要介绍正则表达式。</p>
<p><strong>正则表达式（Regular Expression，RE）是一种用来描述正则语言的更紧凑的表达方式。</strong></p>
<p>例如上面的语言可以用正则表达式来表示，如上图所示。</p>
<p>这个正则表达式表示，句子的第一个符号是字母 a ，接下来连接<strong>一个任意长度的 a,b串</strong>，再接下来连接一个空串。连接一个空串就代表句子已经结束了。除此之外，我们还可以连接一个点号（.）或者下划线（_）或者一个长度大于等于1 的 a,b 串。</p>
<p>从这个例子中，我们可以看出，正则表达式可以用<strong>较小的正则表达式</strong>根据特定规则来<code>递归</code>构建。</p>
<p>每个正则表达式 r 定义（表示）一个语言，记为 $L(r)$。这个语言也是根据 r 的子表达式所表示的语言<code>递归</code>定义的。</p>
<h3 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h3><ul>
<li>空串是一个正则表达式，那么它所表达的语言也只包括空串。</li>
<li>字母表上的任何一个符号都是一个正则表达式，那么它所表示的语言只包含它本身。</li>
<li>假设 r 和 s 都是正则表达式，它们表示的语言分别是 $L(r)$ 和  $L(s)$ ，则:<ul>
<li>$r|s$ （r 或 s）也是一个正则表达式，它表示的语言是 $L(r|s) = L(r) ∪ L(s)$</li>
<li>rs（r 和 s 的连接）也是一个正则表达式，它表示的语言是 $L(rs) = L(r)L(s)$</li>
<li>$r^<em>$（r 的克林闭包）也是一个正则表达式，它表示的语言是也 $L(r^</em>) = (L(r))^*$</li>
<li>$(r)$ 是一个正则表达式，它表示的语言就是 $L(r)$，即 $L((r))=L(r)$</li>
</ul>
</li>
</ul>
<p><img alt="image-20191127234942937" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d17haqe3j31680fs0xj.jpg" class="lazyload"></p>
<blockquote>
<p>例：</p>
</blockquote>
<p>假设符号表中有 a,b。则 a 是一个正则表达式，b 也是一个正则表达式。可以推导出以下的正则表达式：</p>
<p><img alt="image-20191127235851699" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1h3chy5j315y0gi0x5.jpg" class="lazyload"></p>
<p>例：</p>
<p>描述 C 语言中无符号整数的正则表达式</p>
<ul>
<li>十进制整数的正则表达式：第一个符号是1<del>9中的一个数字，接下来连接若干个 0</del>9 的数字，或者连接符号 0。</li>
<li>八进制整数的正则表达式：<strong>第一个符号是数字0</strong>，第二个符号是1<del>7中的一个数字，接下来连接若干个 0</del>7 中的数字。</li>
<li>十六进制整数的正则表达式：<strong>第一个符号是0，第二个符号是 x</strong>，第三个符号是 1～f 中的符号，接下来连接若干个 0～f 中的符号。</li>
</ul>
<p><img alt="image-20191128000002054" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1i7wi9kj315w0g20wu.jpg" class="lazyload"></p>
<h3 id="正则表达式的代数定律"><a href="#正则表达式的代数定律" class="headerlink" title="正则表达式的代数定律"></a>正则表达式的代数定律</h3><blockquote>
<p>正则语言：可以用正则表达式定义的语言叫做正则语言或正则集合。</p>
</blockquote>
<p>正则表达式也遵循一些<strong>代数定律</strong>，如下图所示：</p>
<p><img alt="image-20191128000355664" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1mdaijjj315w0g2q76.jpg" class="lazyload"></p>
<p><strong>正则文法与正则表达式等价</strong>：</p>
<ul>
<li><p>对于任何一个正则文法 G，存在定义同一语言的正则表达式 r。</p>
</li>
<li><p>对任何正则表达式 r，存在生成同一语言的正则文法 G。</p>
</li>
<li><p>总之，有 G 就有 r ，有 r 就有 G 。</p>
</li>
</ul>
<h2 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h2><p>为了方便起见，我们可以给某些<code>正则表达式命名</code>，像使用字母表中的符号一样，使用这些名字来构造正则表达式。（这就是正则定义提出的定义和基本思想）</p>
<p>正则定义就是给正则表达式命名，右侧是字母表与已定义的正则定义的并集</p>
<p><img alt="image-20191128000623988" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1p2ykz0j315y0igwm9.jpg" class="lazyload"></p>
<h3 id="例1：C语言的标识符"><a href="#例1：C语言的标识符" class="headerlink" title="例1：C语言的标识符"></a>例1：C语言的标识符</h3><p><strong>C语言中标识符的正则定义</strong>：</p>
<ul>
<li><p>第一个正则表达式，表示0~9中的某个数字，我们给它取一个名字，digit</p>
</li>
<li><p>第二个正则表示式，表示一个字母（小写字母或大写字母）和一个下划线。我们给它取一个名字，letter_</p>
</li>
<li><p>接下来我们用起好的这两个名字，来构造第三个正则表达式。</p>
</li>
<li><p>第三个正则表示式，首先是一个 letter_，接下来连接一个 letter _ 或 digit 构成的字符串。这个表达式表示的是字母打头的字符数字串。（正是标识符的定义）</p>
</li>
</ul>
<p><img alt="image-20191128001129801" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1u5ogn2j315m0aqmzw.jpg" class="lazyload"></p>
<h3 id="例2：无符号数"><a href="#例2：无符号数" class="headerlink" title="例2：无符号数"></a>例2：无符号数</h3><p><strong>（整型或浮点数）无符号数的正则定义</strong>：</p>
<ul>
<li><p>digit，还是表示一个数字</p>
</li>
<li><p>digits，digit <strong>连接</strong>上一个 digit 的克林闭包，表示的是一个长度&gt;=1 的数字串。</p>
</li>
<li><p>optionalFraction，点号（.）后面连接一个 digits 或 这个表达式是一个空串。（这个符号表示的是一个小数部分，或一个空串）代表<strong>可选</strong>的小数部分。</p>
</li>
<li><p>optionalExponent，大写字母 E 后面连接一个 + （正号）或 一个 -（负号）或直接连接一个长度大于等于1 的数字串（digits），或者这个表达式为空串。可选的指数部分。</p>
</li>
<li><p>number，长度大于等于1 的数字串，连接一个可选的小数部分，连接一个可选的指数部分。</p>
<ul>
<li><p>当可选的小数部分为空串时，这个表达式为一个整数的若干次幂，如 2E-3<br>若可选的指数部分为空串时，这个正则表达式为小数。比如说 2.15</p>
</li>
<li><p>若可选的小数部分和可选的指数部分都为空串时，这个正则表达式为整数。比如说 2</p>
</li>
<li><p>若可选的小数部分和可选的指数部分都不为空串时，这个正则表达式为指数形式的浮点数。比如说 2.15E+3, 2.15E-3。<br>当指数为正号时，指数是可以省略的，如 2.15E3</p>
</li>
</ul>
</li>
</ul>
<p><img alt="image-20191128001235949" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d1vanyfbj31600hygrx.jpg" class="lazyload"></p>
<h2 id="有穷自动机（FA）"><a href="#有穷自动机（FA）" class="headerlink" title="有穷自动机（FA）"></a>有穷自动机（FA）</h2><p>有穷自动机（Finite Automata，FA）由两位神经物理学家Meculoch 和 Pitts 于 1948年提出，是对一类处理系统建立的数学模型。</p>
<p><strong>重要的理论基础</strong></p>
<p>这类系统具有一系列<code>离散的输入输出信息和有穷数目的内部状态</code>。</p>
<p>系统只需要根据当前所处的状态和当前面临的输入信息，就可以决定系统的<strong>后继行为</strong>。每当系统处理了当前的输入后，系统的<strong>内部状态也将发生改变</strong>。</p>
<h3 id="FA-的典型例子"><a href="#FA-的典型例子" class="headerlink" title="FA 的典型例子"></a>FA 的典型例子</h3><p>电梯控制装置</p>
<ul>
<li>输入：顾客的<strong>乘梯需求</strong>（所要到达的层号）</li>
<li>状态：电梯<strong>所处的层数+运动方向</strong></li>
<li>电梯控制装置<strong>并不需要记住先前全部的服务要求</strong>，只需要知道电梯<strong>当前所处的状态</strong>以及<strong>还没有满足的所有服务请求</strong>。</li>
</ul>
<h3 id="FA-模型"><a href="#FA-模型" class="headerlink" title="FA 模型"></a>FA 模型</h3><p><strong>FA模型</strong>由以下三部分组成：</p>
<ul>
<li><p>输入带：用来存放输入符号串</p>
</li>
<li><p>读头：<strong>从左向右</strong>逐个读取输入符号，不能修改（只读），不能往返移动</p>
</li>
<li><p>有穷控制器：具有有穷个状态数，根据<strong>当前的状态 + 当前输入符号</strong>控制转入<strong>下一状态</strong>。</p>
</li>
</ul>
<p><img alt="image-20191128002151798" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d24xnuskj315w07qaat.jpg" class="lazyload"></p>
<h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>有穷自动机可以用<strong>转换图</strong>来表示。</p>
<p><strong>结点</strong>：FA 的<strong>状态</strong></p>
<ul>
<li>初始状态（开始状态）：只有一个，由 <strong>start 箭头指向</strong></li>
<li>终止状态：可以由多个，用<strong>双圈</strong>表示（下例中的 3）</li>
</ul>
<p>带标记的<strong>有向边</strong>：如果对于<strong>输入 a</strong> ，存在一个从状态 p 到状态 q 的转换，就在 p、q 之间画一条有向边，并标记上 a。</p>
<p><img alt="image-20191128002520110" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d28lwfx1j316205yq43.jpg" class="lazyload"></p>
<p>在这个图中，一共有4个状态，分别为状态0，状态1，状态2，状态3。状态0为初始状态，由start箭头指向，状态3为终止状态，用双圈表示。</p>
<h3 id="FA定义（接受）的语言"><a href="#FA定义（接受）的语言" class="headerlink" title="FA定义（接受）的语言"></a>FA定义（接受）的语言</h3><p>给定输入串 x，如果存在一个对应于串 x 的<strong>从初始状态到某个终止状态的转换序列</strong>，则称 <strong>串 x 被该 FA 接受</strong>。</p>
<p>由一个<strong>有穷自动机 M 接受的所有串构成的集合</strong>称为是<strong>该 FA定义（或接收）的语言，记为  $ L(M)$</strong>。</p>
<p><img alt="image-20191128002951076" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2d8z3s8j315w080419.jpg" class="lazyload"></p>
<p>对于 abbaabb来说，我们可以判断是否为这个 FA 所接受。能。</p>
<p>接受第一个 a后，由初始状态0转换到状态 0，再遇到两个 b 后，依然保持状态 0，遇到下个 a 时，还保持状态 0，再遇到一个 a 时，转换到状态1，接下来两个 b，分别转换到状态2，和最终状态3。</p>
<h3 id="最长子串匹配原则"><a href="#最长子串匹配原则" class="headerlink" title="最长子串匹配原则"></a>最长子串匹配原则</h3><p>当<strong>输入串的多个前缀与一个或多个模式匹配时</strong>，我们总是<strong>选择最长的前缀</strong>进行匹配。</p>
<p><img alt="image-20191128003035729" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2e05g95j315y066q44.jpg" class="lazyload"></p>
<p>对于上图来说，当遇到 &lt; 号时，转换到状态1，当遇到 &lt; = 号时，转换到状态2。</p>
<p>即：在到达某个<code>终态</code>之后，只要输入带上还有符号，DFA 就<strong>继续前进</strong>，以便找到尽可能长的匹配。</p>
<h2 id="有穷自动机的分类"><a href="#有穷自动机的分类" class="headerlink" title="有穷自动机的分类"></a>有穷自动机的分类</h2><ul>
<li>确定的有穷自动机（DFA）</li>
<li>不确定的有穷自动机（NFA）</li>
</ul>
<h3 id="确定的有穷自动机-DFA"><a href="#确定的有穷自动机-DFA" class="headerlink" title="确定的有穷自动机 (DFA)"></a>确定的有穷自动机 (DFA)</h3><ul>
<li><p>DFA定义为一个五元组</p>
</li>
<li><p>假设字母表中没有 $\varepsilon$</p>
</li>
</ul>
<p><img alt="image-20191128003106533" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2ejg4ayj315s0cgwjf.jpg" class="lazyload"></p>
<p>例：</p>
<p>在这个有穷自动机DFA 中，</p>
<p>状态集S 包含4个状态。分别是：状态0， 状态1， 状态2， 状态3。</p>
<p>输入字母表Σ 中包含的元素是：符号a，符号b。</p>
<p>转换函数 δ ，我们用一个转换表来表示。</p>
<p>例：状态0 遇到符号 a 时，变成状态1，状态0 遇到 符号 b 时，依旧是状态 0。以此类推，完成<code>转换表(重点考点)</code>。</p>
<ul>
<li>3是终止态，用 * 标识。</li>
</ul>
<blockquote>
<p>DFA可以用状态表或转换表两种等价方式来表示。</p>
</blockquote>
<p><img alt="image-20191128003129846" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d2eyc12zj31480cetbl.jpg" class="lazyload"></p>
<blockquote>
<p>DFA 的算法实现</p>
</blockquote>
<ul>
<li><p>输入：以文件结束符 eof 结尾的字符串 x，DFA 的开始状态为 s0，接受状态集 F，转换函数 move</p>
</li>
<li><p>输出：如果 D 接受 x，则回答“yes”，否则回答“no”</p>
</li>
<li><p>方法：将下述算法应用于输入串 x</p>
<p><img alt="image-20191128173024112" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dvv3vc2ej30po0eggzw.jpg" class="lazyload"></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s=s0;</span><br><span class="line">c=nextChar();    <span class="comment">//返回输入串x的下一个符号</span></span><br><span class="line"><span class="keyword">while</span>(c!=eof)</span><br><span class="line">&#123;</span><br><span class="line">    s=<span class="built_in">move</span>(s,c); <span class="comment">//从状态s出发，沿着标记为c的边所能到达的状态</span></span><br><span class="line">    c=nextChar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s在F中)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"yes"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"no"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="非确定的FA-NFA"><a href="#非确定的FA-NFA" class="headerlink" title="非确定的FA (NFA)"></a>非确定的FA (NFA)</h3><ul>
<li><p>DFA定义为一个五元组</p>
</li>
<li><p><strong>同样假设字母表中没有 $\varepsilon$</strong></p>
</li>
<li><p>NFA 与 DFA <strong><code>唯一的区别</code>是：从状态 s 出发，能到达的状态可能有多个。（并不是唯一确定的）</strong></p>
<p><strong>因此，转换函数为集合，而不是元素。</strong></p>
</li>
</ul>
<p><img alt="image-20191128011646974" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3q2x2fcj315w0cc78p.jpg" class="lazyload"></p>
<p>例：</p>
<p>在这个例子中，在初始状态0，遇到符号 a 的时候，它进入的状态包含状态0和状态1 ，两个元素。在状态0 时，遇到符号 b 时，它进入的状态只有 状态 0，因此集合中只有状态 0 一个元素。</p>
<p>如果转换函数 <strong>没有给出对应于状态-输入对的信息</strong>，就把<strong>空集放入到相应的表项中。</strong></p>
<p><img alt="image-20191128011817554" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3rmyp15j314c0cugpe.jpg" class="lazyload"></p>
<blockquote>
<p>带有 ε边 的 NFA</p>
</blockquote>
<p>在状态 a，不需要遇到任何符号，即可进入状态 b，在状态 b，不需要任何符号，即可进入状态 c。</p>
<p>一旦进入状态 b，就不再接受符号 0，同理，一旦进入状态 c，就不在接受符号 1。</p>
<p>这个带有 空边 的NFA 接受的语言是 由若干个 0 连接 若干个 1 再连接上 若干个 2。（r=0 * 1 * 2*）</p>
<p><img alt="image-20191128011907201" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3shyfkpj315m0do43u.jpg" class="lazyload"></p>
<blockquote>
<p>带有 ε边 和 不带有 ε边 的 NFA的等价性</p>
</blockquote>
<ul>
<li>不带空边的状态 A：由若干个 0 构成</li>
<li>不带空边的状态 B：由若干个 0 连接若干个 1 构成</li>
<li>不带空边的状态 C：由若干个 0 连接 若干个 1 连接 若干个 2 构成</li>
</ul>
<p>但是状态A,B,C 都可以概括为若干个 0 连接 若干个 1 再连接上 若干个 2 构成。</p>
<p><img alt="image-20191128012012232" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9d3tn0qdzj315o0b0tcb.jpg" class="lazyload"></p>
<h3 id="DFA和NFA的等价性-重点考点"><a href="#DFA和NFA的等价性-重点考点" class="headerlink" title="DFA和NFA的等价性(重点考点)"></a>DFA和NFA的等价性(重点考点)</h3><p>对任何非确定的有穷自动机 NFA，存在定义<strong>同一语言</strong>的确定的有穷自动机 DFA。</p>
<p>对任何确定的有穷自动机 DFA，存在定义同一语言的非确定的有穷自动机 NFA。</p>
<blockquote>
<p>DFA 和 NFA 可以识别相同的语言</p>
</blockquote>
<p>这两个 DFA 和 NFA 都识别的是以 abb结尾 的 a,b 串。</p>
<p><img alt="image-20191128163557050" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9duagii6zj31500cgdjt.jpg" class="lazyload"></p>
<blockquote>
<p>等价性<code>(重点考点)</code></p>
</blockquote>
<ol>
<li><p><code>(重点考点)</code>：正则文法(即3型文法，a-&gt;b形式) = 正则表达式(大概是字符串，正则表达式是正则语言更紧凑的表达方式) = 有穷自动机</p>
</li>
<li><p>给定正则文法，可以构造等价的有穷自动机，给定有穷自动机，能够构造出相应的正则文法。</p>
</li>
<li><p><code>(重点)</code>：DFA和NFA都可以识别同一种语言，但就在表现形式而言，NFA比DFA更加直观，就计算机实现而言，NFA比DFA更难实现。</p>
</li>
<li><p>从<strong>正则表达式</strong>构造<strong>NFA</strong>比较简单，然后再将NFA转换成<strong>DFA</strong></p>
</li>
<li><p>带有 ε边 和 不带有 ε边 的 NFA也具有等价性</p>
</li>
</ol>
<h2 id="正则表达式和有穷自动机之间的转换"><a href="#正则表达式和有穷自动机之间的转换" class="headerlink" title="正则表达式和有穷自动机之间的转换"></a>正则表达式和有穷自动机之间的转换</h2><p><code>(重点考点)</code></p>
<blockquote>
<p>记住几个常见的，然后把RE不停分解即可</p>
</blockquote>
<p>正则表达式是采用<strong>符号序列</strong>的模式，它可以很直观的描述单词的构成。但在构造分析器时，我们真正实现和模拟的是 <strong>DFA</strong>。因此这涉及到从正则表达式到有穷自动机的转换。</p>
<p>从<strong>正则表达式</strong>到 <strong>DFA</strong> 的转换是比较困难的。所以我们通常是 <strong>将正则表达式 转换成 NFA ，再将 NFA 转换 成 DFA。</strong></p>
<p>即：<strong>RE -&gt; NFA -&gt; DFA</strong></p>
<p><img alt="image-20191128163642655" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dub8l8j0j315m0dyq5w.jpg" class="lazyload"></p>
<h3 id="从RE到NFA"><a href="#从RE到NFA" class="headerlink" title="从RE到NFA"></a>从RE到NFA</h3><p><img alt="image-20191128214119559" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e346vsuwj315u0bmac9.jpg" class="lazyload"></p>
<p>正则表达式经过运算，仍然是正则表达式</p>
<p><img alt="image-20191128214307836" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e362sh7pj31660fkgpf.jpg" class="lazyload"></p>
<p><strong>不停的分解子表达式，即可求得最终的 NFA。</strong></p>
<p>例：</p>
<p>将正则表达式 r=（a|b）*abb 对应的 NFA，不断地进行分解。</p>
<p>首先将 （a|b)* abb 分解成 4 个子表达式连接的形式。再将 （a|b）* 继续进行分解，最终得到最后结果。</p>
<p><img alt="image-20191128214509128" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e386ff3xj315u0cytai.jpg" class="lazyload"></p>
<h2 id="从NFA到DFA的转换"><a href="#从NFA到DFA的转换" class="headerlink" title="从NFA到DFA的转换"></a>从NFA到DFA的转换</h2><p><code>(重点考点)</code></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>例1:</strong></p>
<p><img alt="image-20191128214827894" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3bmlyezj313g0dyn1p.jpg" class="lazyload"></p>
<blockquote>
<p> NFA转换表 -&gt; 根据表新的状态</p>
</blockquote>
<p><strong>从 NFA 转换到 DFA 时，我们要构造新的状态。</strong></p>
<p>比如说，在初始状态 a ，遇到符号 a 时，可能继续保持 状态 a，也有可能转换到 状态 b。因此构造新的状态 a,b。</p>
<p>验证NFA和DFA是否等价：表达的正则表达式一样</p>
<p><strong>DFA 的每个状态都是由 NFA 中的状态构成的集合</strong>，即 NFA 状态集合的一个子集。</p>
<p><strong>例2：</strong>带有 ε 边 的 NFA 到 DFA 的转换</p>
<p>==注意转换表的生成==，A遇到0可以到状态ABC，遇到1可以到状态BC,遇到2可以到状态C.</p>
<p><code>转换表中有几个非空集合，最后DFA就有几条状态转移线-&gt;这是错误的结论，应该跟着它的思路去推导出来，这种题要重新自己做一遍</code></p>
<p>因为 状态 A 不需要任何输入，即可转换成状态 B，状态 C。所有在遇到输入 0时，它既可以是状态 A，也可以是 状态 B，状态 C。后面同理，即可得状态表。</p>
<p>![image-20191128215348210](/Users/hamster/Library/Application Support/typora-user-images/image-20191128215348210.png)</p>
<p>把ABC组合起来构成start，同时也是终结态。注意<code>跟着这个表达式的结构画出NFA和DFA</code></p>
<h3 id="子集构造法"><a href="#子集构造法" class="headerlink" title="子集构造法"></a>子集构造法</h3><p><code>这个MOOC讲的比较模糊，建议结合课堂例题再看一下，感觉期末肯定会考</code></p>
<p>DFA的每个状态都是一个由 NFA中的状态构成的集合,即 NFA状态集合的一个<strong>子集</strong>：</p>
<p><img alt="image-20191128215642257" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3k7d3npj315u0j67b7.jpg" class="lazyload"></p>
<h3 id="计算-ε-closure-空闭包函数"><a href="#计算-ε-closure-空闭包函数" class="headerlink" title="计算 ε-closure 空闭包函数"></a>计算 ε-closure 空闭包函数</h3><p><img alt="image-20191128220820422" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3wanifwj31620f8tch.jpg" class="lazyload"></p>
<h2 id="识别单词的DFA"><a href="#识别单词的DFA" class="headerlink" title="识别单词的DFA"></a>识别单词的DFA</h2><p><code>过程总结：先写出正则定义，再写出NFA，最后把NFA转化成DFA</code> </p>
<h3 id="识别标识符的-DFA"><a href="#识别标识符的-DFA" class="headerlink" title="识别标识符的 DFA"></a>识别标识符的 DFA</h3><p>下面图中识别标识符的 DFA，第一部分识别字母和下划线，第二部分识别字母和下换线和数字组成的串。</p>
<p>因为这个 NFA 就是 DFA，因此不需要进行转换。</p>
<p><img alt="image-20191128220851091" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3wufgpzj315w0di777.jpg" class="lazyload"></p>
<h3 id="识别无符号数的-DFA"><a href="#识别无符号数的-DFA" class="headerlink" title="识别无符号数的 DFA"></a>识别无符号数的 DFA</h3><p>第一部分是长度大于等于1的数字串，第二部分是可选的小数部分（两个子表达式进行或运算得到的），第三部分是可选的指数部分（两个子表达式进行或运算得到的）。</p>
<p><img alt="image-20191128220929335" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3xhzsydj31620bygpj.jpg" class="lazyload"></p>
<p>再将 NFA 转换成 DFA，如下图所示：</p>
<p><code>自己推导一遍</code></p>
<p><img alt="image-20191128221020821" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3ydxik7j313a0fcgyy.jpg" class="lazyload"></p>
<h3 id="识别各进制无符号整数的-DFA"><a href="#识别各进制无符号整数的-DFA" class="headerlink" title="识别各进制无符号整数的 DFA"></a>识别各进制无符号整数的 DFA</h3><p><img alt="image-20191128221044975" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3ytas6aj315u0dkgrb.jpg" class="lazyload"></p>
<h3 id="识别注释的-DFA"><a href="#识别注释的-DFA" class="headerlink" title="识别注释的 DFA"></a>识别注释的 DFA</h3><p><img alt="image-20191128221107888" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3z7kk1oj315s05kabh.jpg" class="lazyload"></p>
<h3 id="识别-token-的-DFA"><a href="#识别-token-的-DFA" class="headerlink" title="识别 token 的 DFA"></a>识别 token 的 DFA</h3><p>识别关键字时把IDN与关键字表对照查询</p>
<p><img alt="image-20191128221135193" data-src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e3zop5plj315y0dgtcg.jpg" class="lazyload"></p>
<h2 id="词法分析阶段的错误处理"><a href="#词法分析阶段的错误处理" class="headerlink" title="词法分析阶段的错误处理"></a>词法分析阶段的错误处理</h2><h3 id="词法分析阶段可检测错误的类型"><a href="#词法分析阶段可检测错误的类型" class="headerlink" title="词法分析阶段可检测错误的类型"></a>词法分析阶段可检测错误的类型</h3><ol>
<li><p>单词拼写错误</p>
<p>例：int i=0x3G,float j=1.05e</p>
</li>
<li><p>非法字符</p>
<p>例：~@<br>词法错误检测<br>如果当前状态与当前输入符号在转换表对应项中的信息为空，而当前状态又不是终止状态，则调用错误处理程序。</p>
</li>
</ol>
<h3 id="错误处理程序"><a href="#错误处理程序" class="headerlink" title="错误处理程序"></a>错误处理程序</h3><p>根据<strong>最长子串匹配原则</strong>，查找已扫描字符串中最后一个对应于某终态的字符</p>
<ul>
<li>如果找到了，将该字符与其前面的字符识别成一个单词。然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词</li>
<li>如果没找到，则确定出错，采用错误恢复策略。</li>
</ul>
<h3 id="错误恢复策略"><a href="#错误恢复策略" class="headerlink" title="错误恢复策略"></a>错误恢复策略</h3><p>最简单的错误恢复策略：“<strong>恐慌模式</strong>”恢复</p>
<p>从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止。</p>
<h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>语法分析的任务是根据给定的文法，识别数据中的各类短语，并构造<strong>语法分析树</strong>。如果输入串的各个单词恰好自左至右地站在分析树的各个节点上，则该词串就是该语言的一个<strong>句子</strong>。</p>
<p>构造的方法主要分为2类，包括<strong>自顶向下分析</strong>和<strong>自底向上分析</strong>。</p>
<h2 id="自顶向下分析概述"><a href="#自顶向下分析概述" class="headerlink" title="自顶向下分析概述"></a>自顶向下分析概述</h2><p>自顶向下的分析是指从分析树的顶部（根节点）向底部（叶节点）方向构造分析树，可以看做是从文法<strong>开始符号S</strong>推导出单词串w的过程，例如：</p>
<p><img alt="image-20191130114221614" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9fx1lv4vwj315y0bgaeo.jpg" class="lazyload"></p>
<p>输入为id+(id+id)，可以理解为通过语法分析树可以最终得到id+(id+id)，即将叶子节点连接起来就可以构成id+(id+id)。</p>
<p>每次推导中都要作两个选择：</p>
<ul>
<li>替换哪一个非终结符</li>
<li>用哪个候选式来替换非终结符</li>
</ul>
<h3 id="最左推导和最右推导"><a href="#最左推导和最右推导" class="headerlink" title="最左推导和最右推导"></a>最左推导和最右推导</h3><p><strong>最左推导</strong></p>
<p>在最左推导中，从文法的开始符号起，总是选择每个句型的最左非终结符进行替换，得到的句型称 为当前文法的最左句型(left-sentential form)</p>
<p><strong>最右推导与最左规约</strong></p>
<p>在最右推导中，总是选择每个句型的最右非终结符进行替换</p>
<p><img alt="image-20191130114317278" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9fx2k8ypfj315s0bmgpm.jpg" class="lazyload"></p>
<p>在<strong>自底向上</strong>的分析中，总是采用<strong>最左归约</strong>的方式，因此把最左归约称为<strong>规范归约</strong>，而最右推导相应地称为<strong>规范推导</strong></p>
<blockquote>
<p>从右边开始推导比较规范</p>
<p>自底向上：最左规约</p>
<p>自顶向下：最左推导 </p>
</blockquote>
<p>最左推导和最右推导具有<strong>唯一性</strong>。</p>
<h3 id="自顶向下的语法分析采用最左推导方式"><a href="#自顶向下的语法分析采用最左推导方式" class="headerlink" title="自顶向下的语法分析采用最左推导方式"></a>自顶向下的语法分析采用最左推导方式</h3><p><img alt="image-20191201002921672" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9gj7pzz0jj30p405e79m.jpg" class="lazyload"></p>
<p><strong>自顶向下</strong>的语法分析采用<strong>最左推 导</strong>方式，总是选择每个句型的最左非终结符进行替换 ，根据输入流中的下一个终结符，选择最左非终结符的一个候选式。</p>
<p><code>试着写一下下面的题，用最左推导</code></p>
<p><img alt="image-20191130114354939" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9fx37mbodj315s0dmwhd.jpg" class="lazyload"></p>
<p>当非终结符的选择不止一种的时候，叶子节点是什么要参考当前的输入指针是什么。当前指针指向的符号已经使用则进行后移。如指针指向+号表示：此次要选择以+号开头的非终结符。</p>
<h3 id="自顶向下语法分析的通用形式"><a href="#自顶向下语法分析的通用形式" class="headerlink" title="自顶向下语法分析的通用形式"></a>自顶向下语法分析的通用形式</h3><p>递归下降分析(Recursive-Descent Parsing)，由一组<strong>过程</strong>组成，每个过程对应一个<strong>非终结符</strong> 。</p>
<p>从文法开始符号S对应的过程开始，其中递归调用文法中其它非终结符对应 的过程。如果S对应的过程体恰好扫描了整个输入串，则成功完成语法分析。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">( )</span> </span>&#123; </span><br><span class="line"><span class="number">1</span>)	选择一个A产生式，A →X1X2… Xk； </span><br><span class="line"><span class="number">2</span>)	<span class="keyword">for</span>( i = <span class="number">1</span> to k) &#123; </span><br><span class="line"><span class="number">3</span>)		<span class="keyword">if</span>( Xi是一个非终结符号) </span><br><span class="line"><span class="number">4</span>)			调用过程Xi ( ) ; </span><br><span class="line"><span class="number">5</span>)		<span class="keyword">else</span>  <span class="keyword">if</span> ( Xi等于当前的输入符号a)       </span><br><span class="line"><span class="number">6</span>)			读入下一个输入符号; </span><br><span class="line"><span class="number">7</span>)		<span class="keyword">else</span> <span class="comment">/* 发生了一个错误*/</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但可能需要回溯，从而导致效率比较低。需要回溯的分析器叫做不确定的分析器。</p>
<h3 id="预测分析-Predictive-Parsing"><a href="#预测分析-Predictive-Parsing" class="headerlink" title="预测分析(Predictive Parsing)"></a>预测分析(Predictive Parsing)</h3><p>预测分析是递归下降分析技术的一个特例，通过在输入中向前看固定个数（通常是一个）符号来选 择正确的A-产生式。</p>
<p>可以对某些文法构造出<strong>向前看k个</strong>输入符号的预测分析器，该类文法有时也称为<strong>LL(k) 文法</strong>类</p>
<p><strong>预测分析不需要回溯</strong>，是一种确定的自顶向下分析方法<br>。</p>
<h2 id="文法转化"><a href="#文法转化" class="headerlink" title="文法转化"></a>文法转化</h2><p>并不是所有的文法都适合自顶向下的分析。</p>
<p>同一非终结符的多个候选式存在<strong>共同前缀</strong>，将导致<strong>回溯现象</strong>，例如：</p>
<p><strong>问题1:</strong>此时就会在a的时候产生歧义。</p>
<p><img alt="image-20191201004042231" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9gjjg6a5tj30ke0a8dlx.jpg" class="lazyload"></p>
<p><strong>问题2</strong>:左递归文法会使递归下降分析器陷入<strong>无限循环</strong></p>
<p>含有A→Aα形式产生式的文法称为是直接左递归的 (immediate left recursive)</p>
<p>如果一个文法中有一个非终结符 A 使得对某个串α存 在一个推导A⇒+AαA\Rightarrow ^+AαA⇒<br>+<br> Aα ，那么这个文法就是左递归的。</p>
<p>经过两步或两步以上推导产生的左递归称为是间接左递归的。</p>
<p><img alt="image-20191201004426055" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9gjnbtvm9j30os08igqh.jpg" class="lazyload"></p>
<h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h2><h1 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h1><h2 id="语法制导翻译概述"><a href="#语法制导翻译概述" class="headerlink" title="语法制导翻译概述"></a>语法制导翻译概述</h2><p>将语义分析和中间代码生成统称为语义翻译，而语义翻译和语法分析统称为<strong>语法制导翻译</strong>，边分析语法，边完成制导翻译的过程</p>
<p><img alt="image-20191128110328713" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dkoj6pfyj312a0d40xh.jpg" class="lazyload"></p>
<h2 id="语法制导定义-SDD"><a href="#语法制导定义-SDD" class="headerlink" title="语法制导定义(SDD)"></a>语法制导定义(SDD)</h2><h3 id="综合属性和继承属性"><a href="#综合属性和继承属性" class="headerlink" title="综合属性和继承属性"></a>综合属性和继承属性</h3><h3 id="SDD的求值顺序"><a href="#SDD的求值顺序" class="headerlink" title="SDD的求值顺序"></a>SDD的求值顺序</h3><h3 id="S-属性定义与L-属性定义"><a href="#S-属性定义与L-属性定义" class="headerlink" title="S-属性定义与L-属性定义"></a>S-属性定义与L-属性定义</h3><h2 id="语法制导翻译方案"><a href="#语法制导翻译方案" class="headerlink" title="语法制导翻译方案"></a>语法制导翻译方案</h2><p>语法制导翻译方案(SDT)是在产生式右部中嵌入了程序片段(称为语义动作)的CFG。<strong>SDT可以看作是SDD的具体实施方案</strong>，本节主要关注如何使用SDT来实现两类重要的SDD， 因为在这两种情况下，SDT可在语法分析过程中实现 ：</p>
<ul>
<li>基本文法可以使用LR分析技术，且SDD是S属性的</li>
<li>基本文法可以使用LL分析技术，且SDD是L属性的</li>
</ul>
<h3 id="S-SDD转换为SDT"><a href="#S-SDD转换为SDT" class="headerlink" title="S-SDD转换为SDT"></a>S-SDD转换为SDT</h3><p>将一个S-SDD转换为SDT的方法：将每个语义动作 都放在产生式的最后。例如：</p>
<p><img alt="image-20191128104350111" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dk432vycj315q09u0zg.jpg" class="lazyload"></p>
<h3 id="L-SDD转换为SDT"><a href="#L-SDD转换为SDT" class="headerlink" title="L-SDD转换为SDT"></a>L-SDD转换为SDT</h3><h3 id="在非递归的预测分析过程中进行语义翻译"><a href="#在非递归的预测分析过程中进行语义翻译" class="headerlink" title="在非递归的预测分析过程中进行语义翻译"></a>在非递归的预测分析过程中进行语义翻译</h3><h3 id="在递归的预测分析过程中进行语义翻译"><a href="#在递归的预测分析过程中进行语义翻译" class="headerlink" title="在递归的预测分析过程中进行语义翻译"></a>在递归的预测分析过程中进行语义翻译</h3><h3 id="在LR分析过程中进行语义翻译"><a href="#在LR分析过程中进行语义翻译" class="headerlink" title="在LR分析过程中进行语义翻译"></a>在LR分析过程中进行语义翻译</h3><h1 id="中间代码的生成"><a href="#中间代码的生成" class="headerlink" title="中间代码的生成"></a>中间代码的生成</h1><h2 id="课件PPT-1"><a href="#课件PPT-1" class="headerlink" title="课件PPT"></a>课件PPT</h2><h3 id="中间语言"><a href="#中间语言" class="headerlink" title="中间语言"></a>中间语言</h3><p><code>?这个四元表达式之前有MOOC讲解的知识点，后期记得补上</code></p>
<ol>
<li>中间语言（复杂性界于<strong>源语言</strong>和<strong>目标语言</strong>之间） 的好处：</li>
</ol>
<p>中间代码也叫中间语言（Intermediate code /language）是：源程序的一种内部表示，不依赖目标机的结构，复杂性介于源语言和机器语言之间。</p>
<p><img alt="image-20191212214030712" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9u9ru5y9lj30wi05mgmm.jpg" class="lazyload"></p>
<ol start="2">
<li>常用中间语言，重点讲了三地址代码的四元式，==给一个语句要求写出四元式==</li>
</ol>
<p><img alt="image-20191212215641717" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ua8i7xbyj30to0fwjtp.jpg" class="lazyload"></p>
<ol start="3">
<li><blockquote>
<p>四元式<code>例题</code></p>
</blockquote>
</li>
</ol>
<ol start="4">
<li>三地址语句的种类，<code>?有些种类的不是到怎么写四元式</code></li>
</ol>
<p><img alt="image-20191212214431636" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u9vuauclj30v80e2gnp.jpg" class="lazyload"></p>
<h3 id="说明语句的翻译"><a href="#说明语句的翻译" class="headerlink" title="说明语句的翻译"></a>说明语句的翻译</h3><p><code>?PPT没有内容,要掌握吗</code></p>
<h3 id="赋值语句的翻译"><a href="#赋值语句的翻译" class="headerlink" title="赋值语句的翻译"></a>赋值语句的翻译</h3><ol>
<li><p>赋值语句的基本文法</p>
<p>赋值语句翻译的主要任务是生成对表达式求值的<strong>三地址码</strong></p>
<blockquote>
<p>例题，根据表达式写出三地址码和四元式 -&gt;</p>
</blockquote>
<p><img alt="image-20191212215432319" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ua697mt9j30wq0emq60.jpg" class="lazyload"></p>
</li>
<li><p>赋值语句对应的语法制导翻译SDT</p>
<p>赋值语句翻译的主要任务是生成对表达式求值的<strong>三地址码</strong>，因此为<strong>基本文法</strong>中的非终结符S和E分别设置了<strong>综合属性code</strong>，用来表示这两个文法符号对应的三地址码，另外E还有一个综合属性addr，用来表示表达式的值的存放地址</p>
</li>
</ol>
<p>   几个其中函数：</p>
<ul>
<li>lookup(name)：查询符号表 返回name对应的记录；</li>
<li>gen(code)：生成三地址指令code；</li>
<li>newtemp( )：生成一个新的临时变量t， 返回t的地址addr。</li>
</ul>
<ol start="3">
<li></li>
</ol>
<h3 id="布尔表达式的翻译"><a href="#布尔表达式的翻译" class="headerlink" title="布尔表达式的翻译"></a>布尔表达式的翻译</h3><h3 id="控制语句的翻译"><a href="#控制语句的翻译" class="headerlink" title="控制语句的翻译"></a>控制语句的翻译</h3><h3 id="过程调用的处理"><a href="#过程调用的处理" class="headerlink" title="过程调用的处理"></a>过程调用的处理</h3><p>dfsagg</p>
<h2 id="控制流语句及STD"><a href="#控制流语句及STD" class="headerlink" title="控制流语句及STD"></a>控制流语句及STD</h2><p>先分析控制流语句的代码结构，定义文法符号的属性</p>
<p>其中包含的继承属性为：</p>
<p>S.next：是一个地址，该地址中存放了紧跟在S代码之后的指令 (S的后继指令)的标号</p>
<p>B.true：是一个地址，该地址中 存放了当B为真时控制流转向的 指令的标号</p>
<p>B.false：是一个地址，该地址 中存放了当B为假时控制流转向 的指令的标号</p>
<p>用指令的<strong>标号</strong>标识一条三地址指令</p>
<p><img alt="image-20191212092405477" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9tohgoz5zj30uy0hc1ap.jpg" class="lazyload"></p>
<p>然后编写控制流语句的基本文法及STD</p>
<p>newlabel( ): 生成一个地址；</p>
<p>label(L): 将下一条 三地址指令的标号赋给L</p>
<p>1.P-&gt;S</p>
<p><img alt="image-20191212092630864" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9tojy0ne2j31280b8wj5.jpg" class="lazyload"></p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="11-07"><a href="#11-07" class="headerlink" title="11.07"></a>11.07</h2><p>1.概念：算符(要相邻)，素短语，算符优先关系</p>
<p>2.例题：书本P89<br>3.判断是否为算法优先文法，算符之间只能有一个关系<br>4.算符优先关系表<br>5.FIRSTVT和LASTVT，可以用来构造优先关系表<br>6.PPT41页例题和书本P91笔记<br>7.根据PPT41写出PPT44例题<br>8.PPT46的素短语和最左素短语<br>9.PPT47的规约过程<br>10.PPT51页例题<br>11.规约准确率高，算符优先法速度快</p>
<blockquote>
<p>11.14<br>一、复习<br>1.规约：找句柄<br>2.算符优先文法：找最左素短语，i直接返回为最顶端的N，有算符才能规约，否则都是占位符，一定要包含算符。速度快但有时不准确，前提是符合算符优先文法才能用。很多都不适用<br>3.另一种：LR分析法</p>
</blockquote>
<p>二、LR分析法：<br>1.从左到右扫描符号串，用最左规约，最右推导。能解决大部分语法规则，但二义文法，需要处理才能用。<br>2.LR(1)分析表，算FIRST和FELLOW，有多个候选式。而LR分析法我们用的是LR分析法，有很多能自动构造LR分析表。<br>3.课本P101例题，状态栈和符号栈，遇到s5:状态转为5，移入i，指针后移；r2：用(2)表达式进行规约右侧符号，消除此时状态，写入规约后符号，查询Goto表更新状态。栈顶的状态显示了分析的历史信息/进度。<br>4.根据有限状态自动机DFA，LR(0)item组成的集合</p>
<h2 id="11-28"><a href="#11-28" class="headerlink" title="11.28"></a>11.28</h2><p>一、书本125，二义文法不能用LR分析法，图5.11和表5.7的第7行，对于二义文法进行人为选择优先级以规避冲突</p>
<p>二、进入第六章</p>
<ul>
<li>综合属性、继承属性</li>
<li>终结符只有综合属性，比如digit</li>
<li>S-属性定义属于L-属性定义</li>
<li>L-属性需要综合属性时可能尚未计算结束，需要多扫描几遍才行，参考其他文件的从左到右计算</li>
<li>PPT第22页例题，10进制实数</li>
</ul>
<p>三、进入第7章</p>
<ol>
<li><p>语义分析和中间代码的生成</p>
</li>
<li><p>本章目录，这些翻译在参考资料里好像没有</p>
<p><img alt="image-20191128112512716" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dlb51a8cj31740ou426.jpg" class="lazyload"></p>
</li>
<li><p>常见的中间语言，用的比较多的是三地址代码，四元式表达</p>
<p><img alt="image-20191128110501843" data-src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dkq4j6pej30xo0g4mzh.jpg" class="lazyload"></p>
</li>
<li><p>本书涉及的三地址语句类型</p>
<p>布尔表达式和控制流语句，两种方法，一种按部就班，一种进行优化，一真一假的话短路掉部分计算</p>
</li>
</ol>
<h2 id="12-05"><a href="#12-05" class="headerlink" title="12.05"></a>12.05</h2><ol>
<li>条件为真/假的时候，出口不一样，还要加上一个GOTO语句</li>
<li>如果边分析边生成的话，会比较难一遍扫描完成-》回填机制</li>
<li>引入ture\false\next三个属性</li>
</ol>
<p><img alt="image-20191205101010915" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lmh87o3mj314i0u0n2y.jpg" class="lazyload"></p>
<p>循环体也要有一个GOTO,为S增加begin属性</p>
<p>顺序执行，保留S.next的原因，因为S可能是条件/循环语句等，</p>
<p><img alt="image-20191205101347847" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lmkzxugbj318k0r0dlf.jpg" class="lazyload"></p>
<p>布尔表达式两种翻译方式：</p>
<ul>
<li>两遍扫描：为给定的输入串构造一棵语法树；对语法树进行深度优先遍历，进行语义规则中规定的翻译。</li>
<li>一遍扫描</li>
</ul>
<p>分析语法都用LR分析法</p>
<p>一遍扫描的困难：</p>
<p>如If-then-else，在这个语句中，if会有两个jump（j, ， ,跳转地址），插入GOTO语句，用M来用链条连起来，用回填语句M整个扫描完后要规约为一个<strong>S</strong>;但是扫描到if的时候还不知道入口的跳转地址，定义一个M,示例PPT36页，</p>
<p><strong>emit是要增加一条中间代码</strong></p>
<p>merge合成一个</p>
<p>backpatch是用于回填，先用指针指向</p>
<blockquote>
<p>老师上课重点讲了这两个的作用，为了一遍扫描生成中间码</p>
</blockquote>
<p><code>M的作用</code>：用M.quad回填E.turelist，用于记录<strong>S1和S2的入口地址</strong>，两个backpatch回填</p>
<p><code>N的作用</code>：对于if-then，完成之后要跳出这个条件语句,强制跳转语句</p>
<p><strong>M与N都是空字</strong></p>
<p>这个语句知道E的真和假，E的假不用执行了，真需要回填</p>
<p>总共三个跳转：只回填真语句的回填，N的回填，假的回填不用</p>
<p>把不知道的地方放到S的属性，S.nextlist=merge(),不知道的先merge到S.nextlist上去，指针附在nextlist后面，什么时候回填还不知道，需要回填的时候在进行回填</p>
<p>边扫描边生成代码：不知道的全部空着，然后用链条把这个放到上一级S的属性，等到知道入口在哪里再进行回填</p>
<p><img alt="image-20191205102810201" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lmzy016oj31860u0af7.jpg" class="lazyload"></p>
<p>当E1为假才去看E2，用M记录入口地址</p>
<p><img alt="image-20191205104225017" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnetvevpj317c0mymyy.jpg" class="lazyload"></p>
<p>一条中间代码都没有产生。由于不知道E1和E2的真出口，所以要用第2句把E1和E2链接到E上，AorB都是假的话需要一个假出口，那么跳出，所以E2E2的假出口也是E的假出口，这时整个AorB都是假。</p>
<p>merge是链表的合并</p>
<p><img alt="image-20191205104611691" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnipey4wj315c0cs75r.jpg" class="lazyload"></p>
<p><strong>AND</strong></p>
<p>E1的真出口是E2的入口地址</p>
<p>E2的真出口是E的真出口</p>
<p>E2、E1的假出口都是E的假出口</p>
<p><img alt="image-20191205105832546" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnvjd9bjj316i0bkabk.jpg" class="lazyload">NOT () </p>
<p><img alt="image-20191205105903510" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnw2tduqj315u0haq4h.jpg" class="lazyload"></p>
<p>OR AND NOT （）都没有中间代码的生成，只有涉及到id的时候才产生中间代码。</p>
<p>中间代码：如果满足relop.op操作，操作数满足该关系，就往这个真出口出去，为假的话就强制执行假出口；所以这里总共有2个出口。</p>
<p>中间代码也有需要回填，所以要把真假出口挂到E的链条上</p>
<p>如果回填了的话nextquad会发生改变</p>
<p><img alt="image-20191205110007147" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lnx6yqlxj318k0logp4.jpg" class="lazyload"></p>
<p><code>举例</code>：E(C)的假出口需要往105回填为106，不知道怎么回填的出口还是挂到上一级。8条代码里3个地址确定，不确定的其他传到E上</p>
<p><img alt="image-20191205110523628" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9lo2ojzlaj315u0u046o.jpg" class="lazyload"></p>
<p>两种方法，以上一种(画图、生成中间代码)，<code>以下方法</code>：PPT28页</p>
<p>优先级：先做and后做or，图中标出了两个真出口和两个假出口</p>
<p><img alt="image-20191205111639649" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9loeec3wsj316s0migq9.jpg" class="lazyload"></p>
<h3 id="控制语句的翻译-1"><a href="#控制语句的翻译-1" class="headerlink" title="控制语句的翻译"></a>控制语句的翻译</h3><p>while要跳回头部判断，S1.begin</p>
<p>对E的真出口进行回填，假出口要挂在S上，S.nexilist也要回填！！！</p>
<p><img alt="image-20191205113019738" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9losp46jkj315i0hoq5o.jpg" class="lazyload"></p>
<p>例题，包含了布尔、控制、赋值语句</p>
<p>a&lt;b的假出口为S.next，不要随意写跳到107</p>
<p><img alt="image-20191205113230955" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9louvzm6jj315u0t8dkw.jpg" class="lazyload"></p>
<h2 id="12-12"><a href="#12-12" class="headerlink" title="12.12"></a>12.12</h2><blockquote>
<p>控制语句的翻译</p>
</blockquote>
<p>begin不见了，用M1代替</p>
<p><img alt="image-20191212101929099" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9tq3294s5j30ps0fkmzj.jpg" class="lazyload"></p>
<p><code>[？？？？]</code></p>
<p>S-&gt;begin L end</p>
<p>S-&gt;A  【S定义为一个语句】</p>
<p>{S.nextList:=makelist()}</p>
<p>A如果是一个赋值语句，因为要用S来表示它，A要规约为S，</p>
<p>为了和其他while等保持一致，留一个接口，但是直接给个空就行</p>
<p>L-&gt;S</p>
<p>{L.nextlist:=S.nextlist}</p>
<p>向前转移和向后转移</p>
<p><img alt="image-20191212103511132" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9tqjek7g0j30sy0f4gnm.jpg" class="lazyload"></p>
<p>L已经定义为了变量而不是标号或者还没定义，报错</p>
<p>L:</p>
<p><strong><img alt="image-20191212103721251" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9tqlnwz0bj30su0jwgrb.jpg" class="lazyload"></strong></p>
<p><strong>case语句</strong>，也有叫做switch</p>
<p>两种翻译法生成语义的方法是一样的，但是第一种比较方便优化</p>
<p>把L都标出来，最后统一做判断</p>
<blockquote>
<p>过程调用的处理</p>
</blockquote>
<p>我们只讲转地址，不讨论传参数</p>
<p>过程调用的翻译子程序</p>
<p>？？？ 没听懂</p>
<p>把MOOC看了</p>
<blockquote>
<p>优化</p>
</blockquote>
<p>符号表和内存，跳过</p>
<p>==先讲了循环优化啥的再讲的基本块==</p>
<p>单一入口没有入口和goto跳转，顺序执行的</p>
<p>循环是优化的重点</p>
<p><img alt="image-20191212112633270" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ts0uvh3oj30to0ge40w.jpg" class="lazyload"></p>
<h2 id="12-19"><a href="#12-19" class="headerlink" title="12.19"></a>12.19</h2><h3 id="局部优化"><a href="#局部优化" class="headerlink" title="局部优化"></a>局部优化</h3><p>什么是基本块、怎么划分、</p>
<p><img alt="image-20191219101408869" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1t9o0t1fj30uq0cwq70.jpg" class="lazyload"></p>
<p><img alt="image-20191219101658878" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1tcmg1v4j30uy0hsdlo.jpg" class="lazyload"></p>
<p>划分基本块，<code>课堂详讲的练习，讲了2次</code></p>
<p><img alt="image-20191219101826384" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1te5881rj30u20lon6g.jpg" class="lazyload"></p>
<blockquote>
<p>在一个基本块内进行优化</p>
</blockquote>
<p>基本块用DAG表示</p>
<p>叶子结点是标识符或常数，然后添加到上级结点(附加操作符)</p>
<p>常见DAG：</p>
<p>基本块的DAG构造算法：<code>举例课本P284，看！！！</code></p>
<p><img alt="image-20191219103216509" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1tsiyrwsj30v20m8b29.jpg" class="lazyload"></p>
<p>合并已知量：如果来两个都是常数，则删除，参考步骤b，还有其他规则。。。。建议看MOOC</p>
<p><code>DAG图的优化</code>：</p>
<p><img alt="image-20191219104454583" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1udoy4h8j30xm0jiwiu.jpg" class="lazyload">)<img alt="image-20191219105123608" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1ucfbnysj30v20n80ys.jpg" class="lazyload"></p>
<p>最后简化为4个运算，公共变量用S代替</p>
<h3 id="目标代码生成——最后一章"><a href="#目标代码生成——最后一章" class="headerlink" title="目标代码生成——最后一章"></a>目标代码生成——最后一章</h3><p>四元式有一个优化，最后代码也有一个优化</p>
<p>==第一个操作数==</p>
<p>了解一个简单的代码生成器</p>
<p>附加在四元式的待用/活跃信息表</p>
<p>每一个变量是否会在后面被引用</p>
<p>比如第一个表：T=A-B,T在第3个被引用，A在第2个引用，B在右操作数被引用</p>
<p><img alt="image-20191219111824648" data-src="https://tva1.sinaimg.cn/large/006tNbRwly1ga1v4jb5n8j311s0s2478.jpg" class="lazyload"></p>
<h4 id="代码生成算法"><a href="#代码生成算法" class="headerlink" title="代码生成算法"></a>代码生成算法</h4><h1 id="作业习题"><a href="#作业习题" class="headerlink" title="作业习题"></a>作业习题</h1><p>作业，P306 3(B2)</p>
<h1 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h1><p>选A卷</p>
<p>判断题10分，</p>
<p>目标码</p>
<p>前3重中之重</p>
<p>做过的题一定会做</p>
<p>词法分析</p>
<p>优化放在B卷考</p>
<p>词法、语法、中间代码。 伪代码，目标有一点</p>
<p>概念性的东西</p>
<p>2*5，2题，每题5分 判断</p>
<p>3*8 选</p>
<p>22*3 大题</p>
<p>词法分析 语法分析（分析器要会） 中间码生成（子程序提供，要用过程）蓝色基本上可以忽略</p>
<h3 id><a href="#" class="headerlink" title></a></h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">不夜侯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/11/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">http://yoursite.com/2019/11/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">微木斋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理    </a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/ox/wallhaven-oxj7mm.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/15/iWork%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%A7%84%E7%BA%A6/"><img class="prev_cover lazyload" data-src="https://w.wallhaven.cc/full/r2/wallhaven-r2e5lq.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>iWork需求分析规约</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><img class="next_cover lazyload" data-src="https://w.wallhaven.cc/full/73/wallhaven-73mjjo.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>软件工程</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="/js/src/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'ezY25SXgzlqMB8IIJlycOSGj-gzGzoHsz',
  appKey:'5F5o2QbGSOEbhc0qnyl7LGjS',
  placeholder:'ヾﾉ≧∀≦)o来啊，快活啊!',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-CN',
  recordIP: true
});</script></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 By 不夜侯</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><img id="go-up" src="img/scroll.png" title="回到顶部" aria-hidden="true"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400,"hOffset":40,"vOffset":-80},"mobile":{"show":true},"log":false});</script></body></html>